{"title":"Music Organizer","summary":"BlueJ Chapter 4","description":"`new MusicPlayer()`\n\n-> `startPlaying(\"/app/tmp_assets/music.mp3\")`","lastUpdated":1728551430388,"output":"terminal","classes":[{"name":"MusicOrganizer","content":"import java.util.ArrayList;\n\n/**\n * A class to hold details of audio tracks.\n * Individual tracks may be played.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class MusicOrganizer\n{\n    // An ArrayList for storing music tracks.\n    private ArrayList<Track> tracks;\n    // A player for the music tracks.\n    private MusicPlayer player;\n    // A reader that can read music files and load them as tracks.\n    private TrackReader reader;\n\n    /**\n     * Create a MusicOrganizer\n     */\n    public MusicOrganizer()\n    {\n        tracks = new ArrayList<>();\n        player = new MusicPlayer();\n        reader = new TrackReader();\n        readLibrary(\"../audio\");\n        System.out.println(\"Music library loaded. \" + getNumberOfTracks() + \" tracks.\");\n        System.out.println();\n    }\n    \n    /**\n     * Add a track file to the collection.\n     * @param filename The file name of the track to be added.\n     */\n    public void addFile(String filename)\n    {\n        tracks.add(new Track(filename));\n    }\n    \n    /**\n     * Add a track to the collection.\n     * @param track The track to be added.\n     */\n    public void addTrack(Track track)\n    {\n        tracks.add(track);\n    }\n    \n    /**\n     * Play a track in the collection.\n     * @param index The index of the track to be played.\n     */\n    public void playTrack(int index)\n    {\n        if(indexValid(index)) {\n            Track track = tracks.get(index);\n            player.startPlaying(track.getFilename());\n            System.out.println(\"Now playing: \" + track.getArtist() + \" - \" + track.getTitle());\n        }\n    }\n    \n    /**\n     * Return the number of tracks in the collection.\n     * @return The number of tracks in the collection.\n     */\n    public int getNumberOfTracks()\n    {\n        return tracks.size();\n    }\n    \n    /**\n     * List a track from the collection.\n     * @param index The index of the track to be listed.\n     */\n    public void listTrack(int index)\n    {\n        System.out.print(\"Track \" + index + \": \");\n        Track track = tracks.get(index);\n        System.out.println(track.getDetails());\n    }\n    \n    /**\n     * Show a list of all the tracks in the collection.\n     */\n    public void listAllTracks()\n    {\n        System.out.println(\"Track listing: \");\n\n        for(Track track : tracks) {\n            System.out.println(track.getDetails());\n        }\n        System.out.println();\n    }\n    \n    /**\n     * List all tracks by the given artist.\n     * @param artist The artist's name.\n     */\n    public void listByArtist(String artist)\n    {\n        for(Track track : tracks) {\n            if(track.getArtist().contains(artist)) {\n                System.out.println(track.getDetails());\n            }\n        }\n    }\n    \n    /**\n     * Remove a track from the collection.\n     * @param index The index of the track to be removed.\n     */\n    public void removeTrack(int index)\n    {\n        if(indexValid(index)) {\n            tracks.remove(index);\n        }\n    }\n    \n    /**\n     * Play the first track in the collection, if there is one.\n     */\n    public void playFirst()\n    {\n        if(tracks.size() > 0) {\n            player.startPlaying(tracks.get(0).getFilename());\n        }\n    }\n    \n    /**\n     * Stop the player.\n     */\n    public void stopPlaying()\n    {\n        player.stop();\n    }\n\n    /**\n     * Determine whether the given index is valid for the collection.\n     * Print an error message if it is not.\n     * @param index The index to be checked.\n     * @return true if the index is valid, false otherwise.\n     */\n    private boolean indexValid(int index)\n    {\n        // The return value.\n        // Set according to whether the index is valid or not.\n        boolean valid;\n        \n        if(index < 0) {\n            System.out.println(\"Index cannot be negative: \" + index);\n            valid = false;\n        }\n        else if(index >= tracks.size()) {\n            System.out.println(\"Index is too large: \" + index);\n            valid = false;\n        }\n        else {\n            valid = true;\n        }\n        return valid;\n    }\n    \n    private void readLibrary(String folderName)\n    {\n        ArrayList<Track> tempTracks = reader.readTracks(folderName, \".mp3\");\n\n        // Put all thetracks into the organizer.\n        for(Track track : tempTracks) {\n            addTrack(track);\n        }\n    }\n}\n","position":{"x":127.75562663606314,"y":196.0500638979314}},{"name":"MusicPlayer","content":"import java.io.BufferedInputStream;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.IOException;\nimport javazoom.jl.decoder.JavaLayerException;\nimport javazoom.jl.player.AudioDevice;\nimport javazoom.jl.player.FactoryRegistry;\n\n/**\n * Provide basic playing of MP3 files via the javazoom library.\n * See http://www.javazoom.net/\n * \n * @author David J. Barnes and Michael Kölling.\n * @version 2016.02.29\n */\npublic class MusicPlayer\n{\n    // The current player. It might be null.\n    private MyAdvancedPlayer player;\n    \n    /**\n     * Constructor for objects of class MusicFilePlayer\n     */\n    public MusicPlayer()\n    {\n        player = null;\n    }\n    \n    /**\n     * Play a part of the given file.\n     * The method returns once it has finished playing.\n     * @param filename The file to be played.\n     */\n    public void playSample(String filename)\n    {\n        try {\n            setupPlayer(filename);\n            player.play(500);\n        }\n        catch(JavaLayerException e) {\n            reportProblem(filename);\n        }\n        finally {\n            killPlayer();\n        }\n    }\n    \n    /**\n     * Start playing the given audio file.\n     * The method returns once the playing has been started.\n     * @param filename The file to be played.\n     */\n    public void startPlaying(String filename)\n    {\n        try {\n            setupPlayer(filename);\n            Thread playerThread = new Thread() {\n                public void run()\n                {\n                    try {\n                        player.play(5000);\n                    }\n                    catch(JavaLayerException e) {\n                        reportProblem(filename);\n                    }\n                    finally {\n                        killPlayer();\n                    }\n                }\n            };\n            playerThread.start();\n        }\n        catch (Exception ex) {\n            reportProblem(filename);\n        }\n    }\n    \n    public void stop()\n    {\n        killPlayer();\n    }\n    \n    /**\n     * Set up the player ready to play the given file.\n     * @param filename The name of the file to play.\n     */\n    private void setupPlayer(String filename)\n    {\n        try {\n            InputStream is = getInputStream(filename);\n            player = new MyAdvancedPlayer(is, createAudioDevice());\n        }\n        catch (IOException e) {\n            reportProblem(filename);\n            killPlayer();\n        }\n        catch(JavaLayerException e) {\n            reportProblem(filename);\n            killPlayer();\n        }\n    }\n\n    /**\n     * Return an InputStream for the given file.\n     * @param filename The file to be opened.\n     * @throws IOException If the file cannot be opened.\n     * @return An input stream for the file.\n     */\n    private InputStream getInputStream(String filename)\n        throws IOException\n    {\n        return new BufferedInputStream(\n                    new FileInputStream(filename));\n    }\n\n    /**\n     * Create an audio device.\n     * @throws JavaLayerException if the device cannot be created.\n     * @return An audio device.\n     */\n    private AudioDevice createAudioDevice()\n        throws JavaLayerException\n    {\n        return FactoryRegistry.systemRegistry().createAudioDevice();\n    }\n\n    /**\n     * Terminate the player, if there is one.\n     */\n    private void killPlayer()\n    {\n        synchronized(this) {\n            if(player != null) {\n                player.stop();\n                player = null;\n            }\n        }\n    }\n    \n    /**\n     * Report a problem playing the given file.\n     * @param filename The file being played.\n     */\n    private void reportProblem(String filename)\n    {\n        System.out.println(\"There was a problem playing: \" + filename);\n    }\n\n}\n","position":{"x":384.87926056432207,"y":107.22384940380002}},{"name":"Track","content":"/**\n * Store the details of a music track,\n * such as the artist, title, and file name.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class Track\n{\n    // The artist.\n    private String artist;\n    // The track's title.\n    private String title;\n    // Where the track is stored.\n    private String filename;\n    \n    /**\n     * Constructor for objects of class Track.\n     * @param artist The track's artist.\n     * @param title The track's title.\n     * @param filename The track file. \n     */\n    public Track(String artist, String title, String filename)\n    {\n        setDetails(artist, title, filename);\n    }\n    \n    /**\n     * Constructor for objects of class Track.\n     * It is assumed that the file name cannot be\n     * decoded to extract artist and title details.\n     * @param filename The track file. \n     */\n    public Track(String filename)\n    {\n        setDetails(\"unknown\", \"unknown\", filename);\n    }\n    \n    /**\n     * Return the artist.\n     * @return The artist.\n     */\n    public String getArtist()\n    {\n        return artist;\n    }\n    \n    /**\n     * Return the title.\n     * @return The title.\n     */\n    public String getTitle()\n    {\n        return title;\n    }\n    \n    /**\n     * Return the file name.\n     * @return The file name.\n     */\n    public String getFilename()\n    {\n        return filename;\n    }\n        \n    /**\n     * Return details of the track: artist, title and file name.\n     * @return The track's details.\n     */\n    public String getDetails()\n    {\n        return artist + \": \" + title + \"  (file: \" + filename + \")\";\n    }\n    \n    /**\n     * Set details of the track.\n     * @param artist The track's artist.\n     * @param title The track's title.\n     * @param filename The track file. \n     */\n    private void setDetails(String artist, String title, String filename)\n    {\n        this.artist = artist;\n        this.title = title;\n        this.filename = filename;\n    }\n    \n}\n","position":{"x":513.4664109657203,"y":237.685828321357}},{"name":"TrackReader","content":"import java.io.File;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\n/**\n * A helper class for our music application. This class can read files from the file system\n * from a given folder with a specified suffix. It will interpret the file name as artist/\n * track title information.\n * \n * It is expected that file names of music tracks follow a standard format of artist name\n * and track name, separated by a dash. For example: TheBeatles-HereComesTheSun.mp3\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class TrackReader\n{\n    /**\n     * Create the track reader, ready to read tracks from the music library folder.\n     */\n    public TrackReader()\n    {\n        // Nothing to do here.\n    }\n    \n    /**\n     * Read music files from the given library folder\n     * with the given suffix.\n     * @param folder The folder to look for files.\n     * @param suffix The suffix of the audio type.\n     */\n    public ArrayList<Track> readTracks(String folder, String suffix)\n    {\n        File audioFolder = new File(folder);\n        File[] audioFiles = audioFolder.listFiles((dir, name) -> \n                    name.toLowerCase().endsWith(suffix));\n        \n        // Put all the matching files into the organizer.\n        ArrayList<Track> tracks = \n            Arrays.stream(audioFiles).\n                   map(file -> decodeDetails(file)).\n                   collect(Collectors.toCollection(ArrayList::new));\n        return tracks;\n    }\n\n    /**\n     * Try to decode details of the artist and the title\n     * from the file name.\n     * It is assumed that the details are in the form:\n     *     artist-title.mp3\n     * @param file The track file.\n     * @return A Track containing the details.\n     */\n    private Track decodeDetails(File file)\n    {\n        // The information needed.\n        String artist = \"unknown\";\n        String title = \"unknown\";\n        String filename = file.getPath();\n        \n        // Look for artist and title in the name of the file.\n        String details = file.getName();\n        String[] parts = details.split(\"-\");\n        \n        if(parts.length == 2) {\n            artist = parts[0];\n            String titlePart = parts[1];\n            // Remove a file-type suffix.\n            parts = titlePart.split(\"\\\\.\");\n            if(parts.length >= 1) {\n                title = parts[0];\n            }\n            else {\n                title = titlePart;\n            }\n        }\n        return new Track(artist, title, filename);\n    }\n}\n","position":{"x":313.9820247303027,"y":348.78585247577263}},{"name":"MyAdvancedPlayer","content":"/*\n * 11/19/04\t\t1.0 moved to LGPL. \n *-----------------------------------------------------------------------\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Library General Public License as published\n *   by the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Library General Public License for more details.\n *\n *   You should have received a copy of the GNU Library General Public\n *   License along with this program; if not, write to the Free Software\n *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n *----------------------------------------------------------------------\n */\n\nimport java.io.InputStream;\n\nimport javazoom.jl.decoder.Bitstream;\nimport javazoom.jl.decoder.BitstreamException;\nimport javazoom.jl.decoder.Decoder;\nimport javazoom.jl.decoder.Header;\nimport javazoom.jl.decoder.JavaLayerException;\nimport javazoom.jl.decoder.SampleBuffer;\nimport javazoom.jl.player.AudioDevice;\nimport javazoom.jl.player.FactoryRegistry;\nimport javazoom.jl.player.advanced.*;\n\n/**\n * a hybrid of javazoom.jl.player.Player tweeked to include <code>play(startFrame, endFrame)</code>\n * hopefully this will be included in the api\n * This class is tweak to allow stopping the player while playback.\n */\npublic class MyAdvancedPlayer\n{\n\t/** The MPEG audio bitstream.*/\n\tprivate Bitstream bitstream;\n\t/** The MPEG audio decoder. */\n\tprivate Decoder decoder;\n\t/** The AudioDevice the audio samples are written to. */\n\tprivate AudioDevice audio;\n\t/** Has the player been closed? */\n\tprivate boolean closed = false;\n\t/** Has the player played back all frames from the stream? */\n\tprivate boolean complete = false;\n\tprivate int lastPosition = 0;\n\t/** Listener for the playback process */\n\tprivate PlaybackListener listener;\n\n    private volatile boolean pleaseStop = false;\n\n\t/**\n\t * Creates a new <code>Player</code> instance.\n\t */\n\tpublic MyAdvancedPlayer(InputStream stream) throws JavaLayerException\n\t{\n\t\tthis(stream, null);\n\t}\n\n\tpublic MyAdvancedPlayer(InputStream stream, AudioDevice device) throws JavaLayerException\n\t{\n\t\tbitstream = new Bitstream(stream);\n\n\t\tif (device!=null) audio = device;\n\t\telse audio = FactoryRegistry.systemRegistry().createAudioDevice();\n\t\taudio.open(decoder = new Decoder());\n\t}\n\n\tpublic void play() throws JavaLayerException\n\t{\n\t\tplay(Integer.MAX_VALUE);\n\t}\n\n\t/**\n\t * Plays a number of MPEG audio frames.\n\t *\n\t * @param frames\tThe number of frames to play.\n\t * @return\ttrue if the last frame was played, or false if there are\n\t *\t\t\tmore frames.\n\t */\n\tpublic boolean play(int frames) throws JavaLayerException\n\t{\n\t\tboolean ret = true;\n\n\t\t// report to listener\n\t\tif(listener != null) listener.playbackStarted(createEvent(PlaybackEvent.STARTED));\n\n\t\twhile (frames-- > 0 && ret && !pleaseStop)\n\t\t{\n\t\t\tret = decodeFrame();\n\t\t}\n\n//\t\tif (!ret)\n\t\t{\n\t\t\t// last frame, ensure all data flushed to the audio device.\n\t\t\tAudioDevice out = audio;\n\t\t\tif (out != null)\n\t\t\t{\n//\t\t\t\tSystem.out.println(audio.getPosition());\n\t\t\t\tout.flush();\n//\t\t\t\tSystem.out.println(audio.getPosition());\n\t\t\t\tsynchronized (this)\n\t\t\t\t{\n\t\t\t\t\tcomplete = (!closed);\n\t\t\t\t\tclose();\n\t\t\t\t}\n\n\t\t\t\t// report to listener\n\t\t\t\tif(listener != null) listener.playbackFinished(createEvent(out, PlaybackEvent.STOPPED));\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t/**\n\t * Cloases this player. Any audio currently playing is stopped\n\t * immediately.\n\t */\n\tpublic synchronized void close()\n\t{\n\t\tAudioDevice out = audio;\n\t\tif (out != null)\n\t\t{\n\t\t\tclosed = true;\n\t\t\taudio = null;\n\t\t\t// this may fail, so ensure object state is set up before\n\t\t\t// calling this method.\n\t\t\tout.close();\n\t\t\tlastPosition = out.getPosition();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tbitstream.close();\n\t\t\t}\n\t\t\tcatch (BitstreamException ex)\n\t\t\t{}\n\t\t}\n\t}\n\n\t/**\n\t * Decodes a single frame.\n\t *\n\t * @return true if there are no more frames to decode, false otherwise.\n\t */\n\tprotected boolean decodeFrame() throws JavaLayerException\n\t{\n\t\ttry\n\t\t{\n\t\t\tAudioDevice out = audio;\n\t\t\tif (out == null) return false;\n\n\t\t\tHeader h = bitstream.readFrame();\n\t\t\tif (h == null) return false;\n\n\t\t\t// sample buffer set when decoder constructed\n\t\t\tSampleBuffer output = (SampleBuffer) decoder.decodeFrame(h, bitstream);\n\n\t\t\tsynchronized (this)\n\t\t\t{\n\t\t\t\tout = audio;\n\t\t\t\tif(out != null)\n\t\t\t\t{\n\t\t\t\t\tout.write(output.getBuffer(), 0, output.getBufferLength());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbitstream.closeFrame();\n\t\t}\n\t\tcatch (RuntimeException ex)\n\t\t{\n\t\t\tthrow new JavaLayerException(\"Exception decoding audio frame\", ex);\n\t\t}\n\t\treturn true;\n\t}\n\n\t/**\n\t * skips over a single frame\n\t * @return false\tif there are no more frames to decode, true otherwise.\n\t */\n\tprotected boolean skipFrame() throws JavaLayerException\n\t{\n\t\tHeader h = bitstream.readFrame();\n\t\tif (h == null) return false;\n\t\tbitstream.closeFrame();\n\t\treturn true;\n\t}\n\n\t/**\n\t * Plays a range of MPEG audio frames\n\t * @param start\tThe first frame to play\n\t * @param end\t\tThe last frame to play\n\t * @return true if the last frame was played, or false if there are more frames.\n\t */\n\tpublic boolean play(final int start, final int end) throws JavaLayerException\n\t{\n\t\tboolean ret = true;\n\t\tint offset = start;\n\t\twhile (offset-- > 0 && ret) ret = skipFrame();\n\t\treturn play(end - start);\n\t}\n\n\t/**\n\t * Constructs a <code>PlaybackEvent</code>\n\t */\n\tprivate PlaybackEvent createEvent(int id)\n\t{\n\t\treturn createEvent(audio, id);\n\t}\n\n\t/**\n\t * Constructs a <code>PlaybackEvent</code>\n\t */\n\tprivate PlaybackEvent createEvent(AudioDevice dev, int id)\n\t{\n\t\treturn new PlaybackEvent(null, id, dev.getPosition());\n\t}\n\n\t/**\n\t * sets the <code>PlaybackListener</code>\n\t */\n\tpublic void setPlayBackListener(PlaybackListener listener)\n\t{\n\t\tthis.listener = listener;\n\t}\n\n\t/**\n\t * gets the <code>PlaybackListener</code>\n\t */\n\tpublic PlaybackListener getPlayBackListener()\n\t{\n\t\treturn listener;\n\t}\n\n\t/**\n\t * closes the player and notifies <code>PlaybackListener</code>\n\t */\n\tpublic void stop()\n\t{\n        pleaseStop = true;\n\t\tlistener.playbackFinished(createEvent(PlaybackEvent.STOPPED));\n\t\tclose();\n\t}\n}","position":{"x":579.797249508142,"y":54.78939886320032}}],"libs":"/app/tmp_assets/jl1.0.1.jar"}