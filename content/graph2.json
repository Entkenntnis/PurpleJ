{"title":"Graph Adjazenz","summary":"","description":"Erstelle ein neues Object `new Main()`.","lastUpdated":1728495672943,"output":"display","classes":[{"name":"Darstellung","content":"import java.util.ArrayList;\nimport org.graphstream.graph.*;\nimport org.graphstream.graph.implementations.*;\nimport org.graphstream.ui.view.*;\nimport org.graphstream.ui.layout.Layout;\nimport org.graphstream.ui.layout.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport javax.swing.Timer;\n\n/**\n * Die Darstellungsklasse verwendet GraphStream (https://graphstream-project.org/) \n * GraphStream wird unter folgenden Lizenzen zur Verfügung gestellt:  \n * CeCILL-C (http://www.cecill.info/licences/Licence_CeCILL-C_V1-en.html) and LGPL v3 (https://www.gnu.org/licenses/lgpl-3.0.html). \n * \n * @author Selbmann\n */\npublic class Darstellung\n{\n    ArrayList<Knoten> knoten;\n    int[][] adjazenzmatrix;\n    SingleGraph graph; \n    Knoten[] knotenArray;\n    boolean liste;\n    \n    public Darstellung(ArrayList knoten, int[][] adjazenzmatrix)\n    {\n        this.knoten = knoten;\n        this.adjazenzmatrix = adjazenzmatrix;\n        liste = true;\n        graph =  new SingleGraph(\"Graph\");\n        graph.display();\n        repeat(100);\n    }\n    \n    public Darstellung(Knoten[] knoten, int[][] adjazenzmatrix)\n    {\n        this.knotenArray = knoten;\n        this.adjazenzmatrix = adjazenzmatrix;\n        liste = false;\n        graph =  new SingleGraph(\"Graph\");\n        graph.display();\n        repeat(100);\n    }\n    //zweiter konstruktort mit Array ana+statt list\n    \n    public void repeat(int delay) {\n        ActionListener taskPerformer = new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent arg0) {\n                    if(liste)\n                    {\n                        aktualisierenListe();\n                    }\n                    else\n                    {\n                        aktualisierenFeld();\n                    }\n                }\n            };\n        Timer t = new Timer(delay, taskPerformer);\n        t.setRepeats(true);\n        t.start();\n    }\n\n    public void aktualisierenListe()\n    {\n\n        for(int i = 0; i<knoten.size(); i++)\n        {\n            if(graph.getNode(knoten.get(i).gibSchluessel())==null)\n            {\n                graph.addNode(knoten.get(i).gibSchluessel());\n            }\n            else\n            {\n                if(knoten.get(i).istBesucht())\n                {\n                    graph.getNode(knoten.get(i).gibSchluessel()).setAttribute(\"ui.style\", \"fill-color: green;\");\n                }\n            }\n        }\n\n        for(int i= 0; i<knoten.size(); i++)\n        {   \n            String bez = knoten.get(i).gibSchluessel();\n            graph.getNode(bez).setAttribute(\"ui.label\",bez); \n        }\n\n        for(int i=0; i<knoten.size(); i++)\n        {\n\n            for(int j = i; j<knoten.size(); j++)\n            {\n                if(adjazenzmatrix[i][j]>0)\n                {\n                    if(graph.getEdge(graph.getNode(i).getId()+\"/\"+graph.getNode(j).getId())==null)\n                    {\n                        Edge e = graph.addEdge(graph.getNode(i).getId()+\"/\"+graph.getNode(j).getId(), graph.getNode(i).getId(), graph.getNode(j).getId());\n                        e.setAttribute(\"ui.label\", adjazenzmatrix[i][j]+\"\");\n                    }\n                }\n\n            }\n\n        }\n\n        graph.addAttribute(\"ui.antialias\");\n        graph.addAttribute(\"ui.quality\");\n        String styleSheet =  \"node{\" +\n            \"   size: 30px, 30px;\" +\n            \"   text-size: 30;\" +\n            \"}\" +\n            \"edge{\"+\n            \" text-size: 25; }\";\n        graph.addAttribute(\"ui.stylesheet\", styleSheet);\n\n    }\n    \n    \n    public void aktualisierenFeld()\n    {\n         for(int i = 0; i<knotenArray.length; i++)\n        {\n            if(knotenArray[i] != null)\n            {\n            if(graph.getNode(knotenArray[i].gibSchluessel())==null)\n            {\n                graph.addNode(knotenArray[i].gibSchluessel());\n            }\n            else\n            {\n                if(knotenArray[i].istBesucht())\n                {\n                    graph.getNode(knotenArray[i].gibSchluessel()).setAttribute(\"ui.style\", \"fill-color: green;\");\n                }\n            }\n        }\n        }\n\n        for(int i= 0; i<knotenArray.length; i++)\n        {   \n            if(knotenArray[i] != null)\n            {\n                String bez = knotenArray[i].gibSchluessel();\n                graph.getNode(bez).setAttribute(\"ui.label\",bez); \n            }\n        }\n\n        for(int i=0; i<knotenArray.length; i++)\n        {\n\n            for(int j = i; j<knotenArray.length; j++)\n            {\n                if(adjazenzmatrix[i][j]>0)\n                {\n                    if(graph.getEdge(graph.getNode(i).getId()+\"/\"+graph.getNode(j).getId())==null)\n                    {\n                        Edge e = graph.addEdge(graph.getNode(i).getId()+\"/\"+graph.getNode(j).getId(), graph.getNode(i).getId(), graph.getNode(j).getId());\n                        e.setAttribute(\"ui.label\", adjazenzmatrix[i][j]+\"\");\n                    }\n                }\n\n            }\n\n        }\n\n        graph.addAttribute(\"ui.antialias\");\n        graph.addAttribute(\"ui.quality\");\n        String styleSheet =  \"node{\" +\n            \"   size: 30px, 30px;\" +\n            \"   text-size: 20;\" +\n            \"}\" +\n            \"edge{\"+\n            \" text-size: 18; }\";\n        graph.addAttribute(\"ui.stylesheet\", styleSheet);\n\n        \n    }\n}\n","position":{"x":196.19349634027552,"y":112.49822666731244}},{"name":"Graph","content":"import java.util.*;\n/**\n * Implementierung mit ohne Methode \"KnotenHinzuFuegen()\"\n *  \n * Verwendung der Darstellungsklasse: knotenFeld und adjazenzMatrix müssen als Parameter\n * an den Konstruktor der Darstellungsklasse übergeben werden.\n *  \n * @author Stoeckle \n * @version 24.09.24\n */\nclass Graph {\n\n    //Attribute\n    private Knoten[] knotenFeld;\n    private int[][] adjazenzMatrix;\n       \n    private Darstellung darstellung;\n    // Konstruktor\n    public Graph(Knoten[] knotenFeld) {\n        this.knotenFeld = knotenFeld;\n        adjazenzMatrix = new int[knotenFeld.length][knotenFeld.length];\n        \n        darstellung = new Darstellung(knotenFeld,adjazenzMatrix);\n    }\n\n\n    /** \n     * Eine Kante hinzufuegen \n     * Fügt dem UNGERICHTETEN Graphen eine Kante hinzu (Adjazenzmatrix symmetrisch)\n     */\n    public void kanteHinzufuegen(String startSchluessel, String zielSchluessel, int bewertung) {\n        // Position im Feld wird gesucht\n        int startIndex = this.gibIndex(startSchluessel);\n        int zielIndex = this.gibIndex(zielSchluessel);\n        //hinzufuegen SYMMETRISCH\n        if (startIndex >-1 && zielIndex >-1) {\n            adjazenzMatrix[startIndex][zielIndex] = bewertung;\n            adjazenzMatrix[zielIndex][startIndex] = bewertung;\n        } else {\n            System.out.println(\"Keine Kante erzeugt, da Start- oder Zielknoten nicht existieren.\");\n        }\n    }\n\n    /** \n     * Hilfsmethode\n     * Gibt den Index zu einem Knoten mit einem bestimmten Schlüssel im knotenFeld\n     */\n    private int gibIndex(String knotenSchluessel) {\n        for (int i = 0; i< knotenFeld.length; i++) {\n            if (knotenFeld[i].gibSchluessel().equals(knotenSchluessel)) {\n                return i;\n            }\n        }\n        return -1; //Wenn nicht gefunden\n    }\n}","position":{"x":21.588007442610042,"y":259.6549330407318}},{"name":"Knoten","content":"/**\n * ACHTUNG: Die Bezeichner in dieser Klasse dürfen nicht verändert werden, \n * damit die Darstellungsklasse darauf zugreifen kann.\n * \n * @author Stöckle \n */\npublic class Knoten \n{\n    private String schluessel;\n    private boolean besucht;\n    public Knoten(String schluessel)\n    {\n        this.schluessel = schluessel;\n    }\n    \n    public String gibSchluessel()\n    {\n        return schluessel;\n    }\n    \n    public boolean istBesucht(){\n        return besucht;   \n    }\n\n    public void setzeBesucht(boolean wert){\n        besucht = wert;\n    }\n}\n","position":{"x":396.66582279837445,"y":168.4911084712778}},{"name":"Main","content":"/**\n * Implementierung mit ohne Methode \"KnotenHinzuFuegen()\" \n * @author Stoeckle \n * @version 24.09.24\n */\npublic class Main\n{\n    public Main() {\n        Knoten[] knotenFeld = {new Knoten(\"A\"), new Knoten(\"B\"), new Knoten(\"C\"), new Knoten(\"D\"), new Knoten(\"E\")};\n\n        Graph graph = new Graph(knotenFeld);   \n\n        // Hier die Befehle eingeben, um Kanten zu erzeugen!\n        graph.kanteHinzufuegen( \"B\",\"A\",2 );\n        graph.kanteHinzufuegen( \"C\",\"A\",10 );\n        graph.kanteHinzufuegen( \"C\",\"B\",7 );\n        graph.kanteHinzufuegen( \"E\",\"B\",3 );\n        graph.kanteHinzufuegen( \"D\",\"B\",10 );\n        graph.kanteHinzufuegen( \"D\",\"E\",4 );\n        graph.kanteHinzufuegen( \"E\",\"C\",6 );\n        graph.kanteHinzufuegen( \"D\",\"C\",4 );\n    }\n}","position":{"x":-102.35126043219236,"y":70.61248063801338}}],"libs":"/app/tmp_assets/gs-core-1.3.jar"}