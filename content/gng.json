{"title":"Graphics'n Games","summary":"API des Cornelsen-Verlag","description":"http://gng4java.informatikschulbuch.de/package-summary.html\n\nStarte den interaktiven Modus und erzeuge neue Objekte.","lastUpdated":1728149433631,"output":"display","classes":[{"name":"Zeichenfenster","content":"\nimport java.awt.*;\nimport java.awt.geom.*;\nimport java.awt.event.*;\nimport java.awt.image.*;\nimport javax.swing.*;\nimport javax.swing.event.*;\nimport java.util.*;\n/**\n * Die Klasse stellt ein Fenster mit einer Malfläche zur Verfügung,\n * auf der Objekte der Klassen Rechteck, Kreis und Dreieck sowie Turtle dargestellt\n * werden können.\n * Die Zeichenfläche wird beim ersten Anlegen eines Zeichenobjekts automatisch\n * nach dem Muster Singleton angelegt.\n * \n * @author Albert Wiedemann \n * @version 1.0\n */\nclass Zeichenfenster\n{\n    /** Interface für die Aktionsausführung. */\n    interface AktionsEmpfaenger\n    {\n        /** Methode wird vom Taktgeber aufgerufen. */\n        void Ausführen();\n        void Taste (char taste);\n        void SonderTaste (int taste);\n        void Geklickt (int x, int y, int anzahl);\n    }\n    \n    /** Aufzählung der erzeugbaren Objektarten. */\n    static enum SymbolArt {kreis, dreieck, rechteck, turtle, figur, text;};\n    \n    /** Einziges Objekt der Zeichenfläche. */\n    private static Zeichenfenster zeichenfläche = null;\n    \n    /** Fenster für die Zeichenfläche. */\n    private JFrame fenster;\n    /** Die eigentliche Darstellungskomponente. */\n    private JComponent malfläche;\n    /** Stop-Knopf für den Taktgeber. */\n    private JButton stop;\n    /** Start-Knopf für den Taktgeber. */\n    private JButton start;\n    /** Einsteller für die Taktrate*/\n    private JSlider slider;\n    /** Feld aller zu zeichnenden Objekte. */\n    private ArrayList<GrafikSymbol> alleSymbole;\n    /** Feld aller zu zeichnenden Objekte. */\n    private ArrayList<AktionsEmpfaenger> aktionsEmpfänger;\n    /** Timerobjekt für die zentrale Zeitverwaltung */\n    private javax.swing.Timer timer;\n\n    /**\n     * Legt das Fenster und die Malfläche an\n     */\n    private Zeichenfenster ()\n    {\n        alleSymbole = new ArrayList<GrafikSymbol>();\n        aktionsEmpfänger = new ArrayList<AktionsEmpfaenger>();\n        fenster = new JFrame(\"Zeichenfenster\");\n        fenster.setLocation(50, 50);\n        fenster.setSize(800, 600);\n        fenster.setDefaultCloseOperation(WindowConstants.DO_NOTHING_ON_CLOSE); //Close-Button kann nicht versteckt oder abgestellt werden.\n        \n        malfläche = new JComponent()\n        {\n            public void paint (Graphics g)\n            {\n                g.setColor(new Color (230, 230, 230));\n                g.fillRect(0, 0, getWidth() - 1, getHeight() - 1);\n                synchronized (malfläche)\n                {\n                    for (GrafikSymbol s: alleSymbole)\n                    {\n                        if (s.sichtbar)\n                        {\n                            s.Zeichnen(g);\n                        }\n                    }\n                }\n            }\n        };\n        malfläche.setOpaque(true);\n        malfläche.addMouseListener(new MouseAdapter ()\n        {\n            /**\n             * Gibt den Ort eines Mouseclicks an die eigentliche Aktionsmethode weiter.\n             * @param e das zugrestellte Ereignis\n             */\n            public void mousePressed(MouseEvent e)\n            {\n                malfläche.requestFocus();\n                ArrayList<AktionsEmpfaenger> empfänger = new ArrayList<AktionsEmpfaenger>(aktionsEmpfänger);\n                for (AktionsEmpfaenger em: empfänger)\n                {\n                    em.Geklickt(e.getX(), e.getY(), e.getClickCount());\n                }\n            }\n        }\n        );\n        malfläche.addKeyListener(new KeyAdapter ()\n        {\n            /**\n             * Gibt die Taste an die eigentliche Aktionsmethode weiter.\n             * @param e das zugestellte Ereignis\n             */\n            public void keyPressed(KeyEvent e)\n            {\n                ArrayList<AktionsEmpfaenger> empfänger = new ArrayList<AktionsEmpfaenger>(aktionsEmpfänger);\n                if ((int) e.getKeyChar() == KeyEvent.CHAR_UNDEFINED)\n                {\n                    switch (e.getKeyCode())\n                    {\n                        case KeyEvent.VK_ENTER:\n                            for (AktionsEmpfaenger em: empfänger)\n                            {\n                                em.Taste((char) KeyEvent.VK_ENTER);\n                            }\n                            break;\n                        default:\n                            for (AktionsEmpfaenger em: empfänger)\n                            {\n                                em.SonderTaste(e.getKeyCode());\n                            }\n                    }\n                }\n                else\n                {\n                    for (AktionsEmpfaenger em: empfänger)\n                    {\n                        em.Taste(e.getKeyChar());\n                    }\n                }\n            }\n        }\n        );\n        malfläche.addComponentListener(new ComponentAdapter()\n        {\n            /**\n             * Setzt die Hintegrundbilder aller Turtle auf die neue Größe.\n             */\n            public void componentResized​(ComponentEvent e)\n            {\n                synchronized (malfläche)\n                {\n                    for (GrafikSymbol s: alleSymbole)\n                    {\n                        if (s instanceof TurtleIntern)\n                        {\n                            ((TurtleIntern) s).NeueGrößeSetzen();\n                        }\n                    }\n                }\n            }\n        }\n        );\n        fenster.add(malfläche, BorderLayout.CENTER);\n        JPanel panel = new JPanel();\n        panel.setMinimumSize(new Dimension(200, 60));\n        panel.setSize(200,60);\n        panel.setVisible(true);\n        panel.setLayout(new GridLayout(1, 2));\n        JPanel panel2 = new JPanel();\n        panel2.setMinimumSize(new Dimension(100, 60));\n        panel2.setSize(100,60);\n        panel2.setVisible(true);\n        panel2.setLayout(new GridLayout(1, 1));\n        stop = new JButton();\n        start = new JButton();\n        start.setLocation(10, 10);\n        start.setSize(80, 30);\n        start.setText(\"Start\");\n        start.setVisible(true);\n        start.addActionListener(new ActionListener ()\n        {\n            public void actionPerformed (ActionEvent evt)\n            {\n                TaktgeberStartenIntern();\n                malfläche.requestFocus();\n            }\n        }\n        );\n        panel2.add(start);\n        stop.setLocation(100, 10);\n        stop.setSize(80, 30);\n        stop.setText(\"Stop\");\n        stop.setVisible(true);\n        stop.setEnabled(false);\n        stop.addActionListener(new ActionListener ()\n        {\n            public void actionPerformed (ActionEvent evt)\n            {\n                TaktgeberStoppenIntern();\n                malfläche.requestFocus();\n            }\n        }\n        );\n        panel2.add(stop);\n        panel.add(panel2);\n        slider = new JSlider(0, 1000, 100);\n        slider.setLocation(190, 10);\n        slider.setSize(160, 40);\n        slider.setMinimumSize(new Dimension(160, 40));\n        slider.setPreferredSize(new Dimension(160, 40));\n        slider.setMajorTickSpacing(100);\n        slider.setPaintTicks(true);\n        slider.setPaintLabels(true);\n        slider.setValue(1000);\n        slider.addChangeListener(new ChangeListener()\n        {\n            public void stateChanged​(ChangeEvent e)\n            {\n                timer.setDelay(slider.getValue());\n                malfläche.requestFocus();\n            }\n        }\n        );\n        panel.add(slider);\n        \n        fenster.add(panel, BorderLayout.SOUTH);\n        fenster.setVisible(true);\n        malfläche.requestFocus();\n\n        timer = new javax.swing.Timer (1000, new ActionListener ()\n        {\n            /**\n             * Vom Timer aufgerufen.\n             * Erzeugt den nächsten Taktimpuls\n             * @param evt der Timerevent\n             */\n            public void actionPerformed (ActionEvent evt)\n            {\n                ArrayList<AktionsEmpfaenger> empfänger = new ArrayList<AktionsEmpfaenger>(aktionsEmpfänger);\n                for (AktionsEmpfaenger e: empfänger)\n                {\n                    e.Ausführen();\n                }\n            }\n        }\n        );\n    }\n    \n    /**\n     * Meldet die aktuelle Breite der Malfläche.\n     * @returns Breite der Malfläche\n     */\n    static int MalflächenBreiteGeben()\n    {\n        if (zeichenfläche == null)\n        {\n            zeichenfläche = new Zeichenfenster();\n        }\n        return zeichenfläche.malfläche.getWidth();\n    }\n    \n    /**\n     * Meldet die aktuelle Höhe der Malfläche.\n     * @returns Höhe der Malfläche\n     */\n    static int MalflächenHöheGeben()\n    {\n        if (zeichenfläche == null)\n        {\n            zeichenfläche = new Zeichenfenster();\n        }\n        return zeichenfläche.malfläche.getHeight();\n    }\n    \n    /**\n     * Trägt einen neuen Aktionsempfänger ein.\n     * @param neu der neue Aktionsempfänger\n     */\n    static void AktionsEmpfängerEintragen(AktionsEmpfaenger neu)\n    {\n        if (zeichenfläche == null)\n        {\n            zeichenfläche = new Zeichenfenster();\n        }\n        zeichenfläche.aktionsEmpfänger.add(neu);\n    }\n    \n    /**\n     * Löscht einen Aktionsempfänger aus der Liste.\n     * @param alt der zu löschende Aktionsempfänger\n     */\n    static void AktionsEmpfängerEntfernen(AktionsEmpfaenger alt)\n    {\n        if (zeichenfläche == null)\n        {\n            zeichenfläche = new Zeichenfenster();\n        }\n        zeichenfläche.aktionsEmpfänger.remove(alt);\n    }\n    \n    /**\n     * Erzeugt ein neues darzustelledes Symbol.\n     * Die möglichen Symbole sind im Aufzählungstyp SymbolArt beschrieben.\n     * @param art Art des zu erzeugenden Symbols.\n     * @return Referenz auf das Delegate-Objekt.\n     */\n    static GrafikSymbol SymbolErzeugen (SymbolArt art)\n    {\n        if (zeichenfläche == null)\n        {\n            zeichenfläche = new Zeichenfenster();\n        }\n        return zeichenfläche.SymbolAnlegen(art);\n    }\n    \n    /**\n     * Startet den Taktgeber.\n     */\n    static void TaktgeberStarten ()\n    {\n        if (zeichenfläche == null)\n        {\n            zeichenfläche = new Zeichenfenster();\n        }\n        zeichenfläche.TaktgeberStartenIntern();\n    }\n    \n    /**\n     * Stoppt den Taktgeber.\n     */\n    static void TaktgeberStoppen ()\n    {\n        if (zeichenfläche == null)\n        {\n            zeichenfläche = new Zeichenfenster();\n        }\n        zeichenfläche.TaktgeberStoppenIntern();\n    }\n    \n    /**\n     * Ablaufgeschwindigkeit des Zeitgebers einstellen.\n     * \n     * @param dauer: Angabe in Millisekunden\n     */\n    static void TaktdauerSetzen (int dauer)\n    {\n        if (zeichenfläche == null)\n        {\n            zeichenfläche = new Zeichenfenster();\n        }\n        zeichenfläche.slider.setValue(dauer < 0 ? 0 : (dauer > 1000 ? 1000: dauer));\n    }\n    \n    /**\n     * Erzeugt das neue Symbol tatsächlich.\n     * @param art Art des zu erzeugenden Symbols.\n     * @return Referenz auf das Delegate-Objekt.\n     */\n    private GrafikSymbol SymbolAnlegen (SymbolArt art)\n    {\n        GrafikSymbol neu = null;\n        switch (art)\n        {\n            case rechteck:\n                neu = new RechteckIntern();\n                break;\n            case kreis:\n                neu = new EllipseIntern();\n                break;\n            case dreieck:\n                neu = new DreieckIntern();\n                break;\n            case turtle:\n                neu = new TurtleIntern();\n                break;\n            case figur:\n                neu = new FigurIntern();\n                break;\n            case text:\n                neu = new TextIntern();\n                break;\n        }\n        synchronized (zeichenfläche.malfläche)\n        {\n            zeichenfläche.alleSymbole.add(neu);\n        }\n        malfläche.repaint();\n        return neu;\n    }\n    \n    /**\n     * Startet den Taktgeber.\n     */\n    private void TaktgeberStartenIntern()\n    {\n        start.setEnabled(false);\n        stop.setEnabled(true);\n        timer.start();\n    }\n    \n    /**\n     * Stoppt den Taktgeber.\n     */\n    private void TaktgeberStoppenIntern()\n    {\n        start.setEnabled(true);\n        stop.setEnabled(false);\n        timer.stop();\n    }\n    \n    /**\n     * Oberklasse für alle verfügbaren Grafiksymbole.\n     * Alle Grafiksymbole werden über ihr umgebendes Rechteck beschrieben.\n     */\n    abstract class GrafikSymbol\n    {\n        /** x-Position der linken oberen Ecke. */\n        protected int x;\n        /** y-Position der linken oberen Ecke. */\n        protected int y;\n        /** Breite des umgebenden Rechtecks. */\n        protected int b;\n        /** Höhe des umgebenden Rechtecks. */\n        protected int h;\n        /** Farbe des Symbols. */\n        protected Color c;\n        /** Sichtbarkeit des Symbols. */\n        protected boolean sichtbar;\n        /** Drehwinkel (mathematisch positiver Drehsinn) des Symbols. */\n        protected int winkel;\n        /** Die Form des Grafiksymbols. */\n        protected Area form;\n        /** Farbe Hellgelb. */\n        protected final Color hellgelb = new Color(255,255,128);\n        /** Farbe Hellgrün. */\n        protected final Color hellgrün = new Color(128,255,128);\n        /** Farbe Orange. */\n        protected final Color orange = new Color(255,128,0);\n        /** Farbe Braun. */\n        protected final Color braun = new Color(128,64,0);\n        \n        /**\n         * Der Konstruktor erzeugt ein rotes Symbol in der linken oberen Ecke des Fensters.\n         */\n        GrafikSymbol()\n        {\n            x = 10;\n            y = 10;\n            b = 100;\n            h = 100;\n            c = Color.RED;\n            sichtbar = true;\n            winkel = 0;\n            FormErzeugen();\n        }\n        \n        /**\n         * Normiert den Winkel auf Werte im Bereich [0; 360[\n         * @param winkel der Eingabewinkel\n         * @return der normierte Winkel\n         */\n        int WinkelNormieren(int winkel)\n        {\n            while (winkel < 0)\n            {\n                winkel += 360;\n            }\n            return winkel % 360;\n        }\n        \n        /**\n         * Setzt die Position (der linken oberen Ecke) des Objekts.\n         * @param x x-Position der linken oberen Ecke\n         * @param y y-Position der linken oberen Ecke\n         */\n        void PositionSetzen (int x, int y)\n        {\n            this.x = x;\n            this.y = y;\n            FormErzeugen();\n            zeichenfläche.malfläche.repaint();\n        }\n        \n        /**\n         * Setzt die Größe des Objekts.\n         * @param breite (neue) Breite des Objekts\n         * @param höhe (neue) Höhe des Objekts\n         */\n        void GrößeSetzen (int breite, int höhe)\n        {\n            b = breite;\n            h = höhe;\n            FormErzeugen();\n            zeichenfläche.malfläche.repaint();\n        }\n    \n        /**\n         * Bestimmt die RGB-Farbe für den gegeben String.\n         * @param farbe die Farbe als String\n         * @return die Farbe als RGB-Farbe\n         */\n        Color FarbeCodieren (String farbe)\n        {\n            farbe = farbe.toLowerCase();\n            switch (farbe)\n            {\n                case \"weiß\":\n                case \"weiss\":\n                    return Color.WHITE;\n                case \"rot\":\n                    return Color.RED;\n                case \"grün\":\n                case \"gruen\":\n                    return Color.GREEN;\n                case \"blau\":\n                    return Color.BLUE;\n                case \"gelb\":\n                    return Color.YELLOW;\n                case \"magenta\":\n                    return Color.MAGENTA;\n                case \"cyan\":\n                    return Color.CYAN;\n                case \"hellgelb\":\n                    return hellgelb;\n                case \"hellgrün\":\n                case \"hellgruen\":\n                    return hellgrün;\n                case \"orange\":\n                    return orange;\n                case \"braun\":\n                    return braun;\n                case \"grau\":\n                    return Color.GRAY;\n                case \"schwarz\":\n                    return Color.BLACK;\n                default:\n                    return Color.BLACK;\n            }\n        }\n\n        /**\n         * Setzt die Farbe des Objekts.\n         * @param farbe (neue) Farbe des Objekts\n         */\n        void FarbeSetzen (String farbe)\n        {\n            FarbeSetzen(FarbeCodieren(farbe));\n        }\n        \n        /**\n         * Setzt die Farbe des Objekts.\n         * @param c (neue) Farbe des Objekts\n         */\n        void FarbeSetzen (Color c)\n        {\n            this.c = c;\n            zeichenfläche.malfläche.repaint();\n        }\n        \n        /**\n         * Setzt die Sichtbarkeit des Objekts.\n         * @param sichtbar (neue) Sichtbarkeit des Objekts\n         */\n        void SichtbarkeitSetzen (boolean sichtbar)\n        {\n            this.sichtbar = sichtbar;\n            zeichenfläche.malfläche.repaint();\n        }\n        \n        /**\n         * Setzt den Drehwinkel des Objekts.\n         * @param winkel der (neue) Drehwinkel des Objekts\n         */\n        void WinkelSetzen (int winkel)\n        {\n            this.winkel = WinkelNormieren(winkel);\n            FormErzeugen();\n            zeichenfläche.malfläche.repaint();\n        }\n        \n        /**\n         * Entfernt das Objekt aus dem Zeichenfenster.\n         */\n        void Entfernen ()\n        {\n            synchronized (zeichenfläche.malfläche)\n            {\n                zeichenfläche.alleSymbole.remove(this);\n                zeichenfläche.malfläche.repaint();\n            }\n        }\n        \n        /**\n         * Bringt das Objekt eine Ebene nach vorn.\n         */\n        void NachVornBringen ()\n        {\n            synchronized (zeichenfläche.malfläche)\n            {\n                int index = zeichenfläche.alleSymbole.indexOf(this);\n                if (index < zeichenfläche.alleSymbole.size() - 1)\n                {\n                    zeichenfläche.alleSymbole.set(index, zeichenfläche.alleSymbole.get(index + 1));\n                    zeichenfläche.alleSymbole.set(index + 1, this);\n                    zeichenfläche.malfläche.repaint();\n                }\n            }\n        }\n        \n        /**\n         * Bringt das Objekt in die vorderste Ebene.\n         */\n        void GanzNachVornBringen ()\n        {\n            synchronized (zeichenfläche.malfläche)\n            {\n                int index = zeichenfläche.alleSymbole.indexOf(this);\n                if (index < zeichenfläche.alleSymbole.size() - 1)\n                {\n                    zeichenfläche.alleSymbole.remove(index);\n                    zeichenfläche.alleSymbole.add(this);\n                    zeichenfläche.malfläche.repaint();\n                }\n            }\n        }\n        \n        /**\n         * Bringt das Objekt eine Ebene nach hinten.\n         */\n        void NachHintenBringen ()\n        {\n            synchronized (zeichenfläche.malfläche)\n            {\n                int index = zeichenfläche.alleSymbole.indexOf(this);\n                if (index > 0)\n                {\n                    zeichenfläche.alleSymbole.set(index, zeichenfläche.alleSymbole.get(index - 1));\n                    zeichenfläche.alleSymbole.set(index - 1, this);\n                    zeichenfläche.malfläche.repaint();\n                }\n            }\n        }\n        \n        /**\n         * Bringt das Objekt in die hinterste Ebene.\n         */\n        void GanzNachHintenBringen ()\n        {\n            synchronized (zeichenfläche.malfläche)\n            {\n                int index = zeichenfläche.alleSymbole.indexOf(this);\n                if (index > 0)\n                {\n                    zeichenfläche.alleSymbole.remove(index);\n                    zeichenfläche.alleSymbole.add(0, this);\n                    zeichenfläche.malfläche.repaint();\n                }\n            }\n        }\n        \n        /**\n         * Testet, ob der angegebene Punkt innerhalb der Figur ist.\n         * @param x x-Koordinate des zu testenden Punktes\n         * @param y y-Koordinate des zu testenden Punktes\n         * @return wahr, wenn der Punkt innerhalb der Figur ist\n         */\n        boolean IstInnerhalb (int x, int y)\n        {\n            return form.contains(x, y);\n        }\n        \n        /**\n         * Testet, ob die beiden Figuren überlappen.\n         * @param wen die andere Form\n         * @return wahr, wenn die beiden Formen überlappen.\n         */\n        boolean Schneidet (Area wen)\n        {\n            Area area = new Area(form);\n            area.intersect (wen);\n            return !area.isEmpty();\n        }\n        \n        /**\n         * Zeichnet das Objekt\n         * @param g das Grafikobjekt zum Zeichnen\n         */\n        void Zeichnen(Graphics g)\n        {\n            g.setColor(c);\n            ((Graphics2D) g).fill(form);\n        }\n        \n        /**\n         * Berechnet den Drehwinkel gemäß den Konventionen des Graphik-Frameworks.\n         * Für Java: Winkel in Radians, positive Drehrichtng im Uhrzeiger.\n         * @param winkel: Der Winkel in Grad, mathematischer Drehsinn\n         * @return Winkel für Graphik-Framework\n         */\n        double DrehwinkelGeben (int winkel)\n        {\n            return - Math.PI * (winkel > 180 ? winkel - 360 : winkel)  / 180.0;\n        }\n        \n        /**\n         * Erstellt die Form des Objekts.\n         */\n        abstract void FormErzeugen();\n    }\n    \n    /**\n     * Objekte dieser Klasse verwalten ein Rechteck.\n     */\n    private class RechteckIntern extends GrafikSymbol\n    {        \n        /**\n         * Erstellt die Form des Rechtecks.\n         */\n        @Override void FormErzeugen()\n        {\n            AffineTransform a = new AffineTransform();\n            a.rotate(DrehwinkelGeben (winkel), this.x + b / 2, this.y + h / 2);\n            form = new Area(new Path2D.Double (new Rectangle2D.Double(this.x, this.y, b, h), a));\n        }\n    }\n    \n    /**\n     * Objekte dieser Klasse verwalten eine Ellipse.\n     */\n    private class EllipseIntern extends GrafikSymbol\n    {\n        /**\n         * Erstellt die Form der Ellipse.\n         */\n        @Override void FormErzeugen()\n        {\n            AffineTransform a = new AffineTransform();\n            a.rotate(DrehwinkelGeben (winkel), this.x + b / 2, this.y + h / 2);\n            form = new Area(new Path2D.Double (new Ellipse2D.Double(this.x, this.y, b, h), a));\n        }\n    }\n    \n    /**\n     * Objekte dieser Klasse verwalten ein Dreieck.\n     */\n    private class DreieckIntern extends GrafikSymbol\n    {\n        /**\n         * Erstellt die Form des Dreiecks.\n         */\n        @Override void FormErzeugen()\n        {\n            Polygon rand = new Polygon (new int [] {x + b / 2, x + b, x, x + b / 2},\n                                        new int [] {y, y + h, y + h, y}, 4);\n            AffineTransform a = new AffineTransform();\n            a.rotate(DrehwinkelGeben (winkel), this.x + b / 2, this.y + h / 2);\n            form = new Area(new Path2D.Double (rand, a));\n        }\n    }\n    \n    /**\n     * Objekte dieser Klasse verwalten einen Text.\n     */\n    class TextIntern extends GrafikSymbol\n    {\n        /** Der aktuelle Text. */\n        private String text;\n        /** Die aktuelle Textgröße. */\n        float size;\n\n        /**\n         * Belegt text und size mit Defaultwerten.\n         */\n        TextIntern ()\n        {\n            super();\n            text = \"Text\";\n            size = 12;\n            c = Color.black;\n        }\n        \n        /**\n         * Erstellt die Form des Textes.\n         * Dummy, legt ein leeres Area an.\n         */\n        @Override void FormErzeugen()\n        {\n            form = new Area();\n        }\n        \n        /**\n         * Testet, ob der angegebene Punkt innerhalb der Figur ist.\n         * @param x x-Koordinate des zu testenden Punktes\n         * @param y y-Koordinate des zu testenden Punktes\n         * @return falsch\n         */\n        @Override boolean IstInnerhalb (int x, int y)\n        {\n            return false;\n        }\n        \n        /**\n         * Setzt den aktuellen Text.\n         * @param t der neue Text\n         */\n        void TextSetzen (String t)\n        {\n            text = t;\n            zeichenfläche.malfläche.repaint();\n        }\n        \n        /**\n         * Setzt die Größe des Textes.\n         */\n        void TextGrößeSetzen (int größe)\n        {\n            size = größe;\n            zeichenfläche.malfläche.repaint();\n        }\n        \n        /**\n         * Vergrößert den Text.\n         */\n        void TextVergrößern()\n        {\n            if (size <= 10)\n            {\n                size += 1;\n            }\n            else if (size <= 40)\n            {\n                size += 2;\n            }\n            else\n            {\n                size += 4;\n            }\n            zeichenfläche.malfläche.repaint();\n        }\n        \n        /**\n         * Verkleinert den Text.\n         */\n        void TextVerkleinern()\n        {\n            if (size <= 10)\n            {\n                size -= 1;\n            }\n            else if (size <= 40)\n            {\n                size -= 2;\n            }\n            else\n            {\n                size -= 4;\n            }\n            if (size < 1)\n            {\n                size = 1;\n            }\n            zeichenfläche.malfläche.repaint();\n        }\n        \n        /**\n         * Zeichnet das Objekt als Dreieck in der gegebenen Farbe.\n         * @param g das Grafikobjekt zum Zeichnen\n         */\n        @Override void Zeichnen(Graphics g)\n        {\n            g.setColor(c);\n            Font f = g.getFont();\n            Font f2 = f.deriveFont(size);\n            g.setFont(f2);\n            \n            if (winkel == 0)\n            {\n                g.drawString(text, x, y);\n            }\n            else\n            {\n                Graphics2D g2 = (Graphics2D) g;\n                AffineTransform alt = g2.getTransform();\n                //g2.rotate(DrehwinkelGeben (winkel), x + b / 2, y + h / 2);\n                //g2.rotate(DrehwinkelGeben (winkel), x + text.length() * size / 4, y + size / 2);\n                Rectangle2D bounds = f2.getStringBounds(text, g2.getFontRenderContext());\n                g2.rotate(DrehwinkelGeben (winkel), x + bounds.getWidth() / 2, y - bounds.getHeight() / 2);\n                g.drawString(text, x, y);\n                g2.setTransform(alt);\n            }\n            g.setFont(f);\n        }\n    }\n    \n    /**\n     * Oberklasse für alle Elemente einer Figur (Figur, Turtle).\n     */\n    private abstract class FigurenElement\n    {\n        double xe;\n        double ye;\n        double breite;\n        double höhe;\n        Color c;\n        /**\n         * Zeichnet das Figurenelement.\n         * @param g das Grafikobjekt\n         * @param größe die aktuelle Größe der Figur\n         * @param x die x-Koordinate des Aufhängepunkts der Figur\n         * @param y die y-Koordinate des Aufhängepunkts der Figur\n         */\n        abstract void ElementZeichnen(Graphics2D g, double größe, int x, int y);\n        \n        /**\n         * Fügt den Pfadteil deiser Komponente zum umgebenden Pfad hinzu.\n         * @param p der Gesamtpfad\n         * @param größe die aktuelle Größe der Figur\n         * @param x die x-Koordinate des Aufhängepunkts der Figur\n         * @param y die y-Koordinate des Aufhängepunkts der Figur\n         */\n        abstract void ElementZuForm (Path2D.Double p, double größe, int x, int y);\n    }\n    \n    /**\n     * Ein rechteckiges Figurenelement.\n     */\n    private class FigurenElementRechteck extends FigurenElement\n    {\n        /**\n         * Der Konstruktor speichert die Rahmendaten.\n         * @param x x-Koordinate der linken oberen Ecke des Rechtecks relativ zum Aufhängepunkt.\n         * @param y y-Koordinate der linken oberen Ecke des Rechtecks relativ zum Aufhängepunkt.\n         * @param breite Breite des Rechtecks\n         * @param höhe Höhe des Rechtecks\n         * @param c Farbe des Rechtecks\n         */\n        FigurenElementRechteck (double x, double y, double breite, double höhe, Color c)\n        {\n            this.xe = x;\n            this.ye = y;\n            this.breite = breite;\n            this.höhe = höhe;\n            this.c = c;\n        }\n        \n        /**\n         * Zeichnet das Figurenelement.\n         * @param g das Grafikobjekt\n         * @param größe die aktuelle Größe der Figur\n         * @param x die x-Koordinate des Aufhängepunkts der Figur\n         * @param y die y-Koordinate des Aufhängepunkts der Figur\n         */\n        @Override void ElementZeichnen(Graphics2D g, double größe, int x, int y)\n        {\n            g.setColor(c);\n            g.fill(new Rectangle2D.Double (x+größe*xe/100.0, y+größe*ye/100.0, größe*breite/100.0, größe*höhe/100.0));\n        }\n        \n        /**\n         * Fügt den Pfadteil dieser Komponente zum umgebenden Pfad hinzu.\n         * @param p der Gesamtpfad\n         * @param größe die aktuelle Größe der Figur\n         * @param x die x-Koordinate des Aufhängepunkts der Figur\n         * @param y die y-Koordinate des Aufhängepunkts der Figur\n         */\n        @Override void ElementZuForm (Path2D.Double p, double größe, int x, int y)\n        {\n            p.append(new Rectangle2D.Double (x+größe*xe/100.0, y+größe*ye/100.0, größe*breite/100.0, größe*höhe/100.0), false);\n        }\n    }\n    \n    /**\n     * Ein elliptisches Figurenelement.\n     */\n    private class FigurenElementEllipse extends FigurenElement\n    {\n        /**\n         * Der Konstruktor speichert die Rahmendaten.\n         * @param x x-Koordinate der linken oberen Ecke des umgebenden Rechtecks relativ zum Aufhängepunkt.\n         * @param y y-Koordinate der linken oberen Ecke des umgebenden Rechtecks relativ zum Aufhängepunkt.\n         * @param breite Breite der Ellipse\n         * @param höhe Höhe der Ellipse\n         * @param c Farbe der Ellipse\n         */\n        FigurenElementEllipse (double x, double y, double breite, double höhe, Color c)\n        {\n            this.xe = x;\n            this.ye = y;\n            this.breite = breite;\n            this.höhe = höhe;\n            this.c = c;\n        }\n        \n        /**\n         * Zeichnet das Figurenelement.\n         * @param g das Grafikobjekt\n         * @param größe die aktuelle Größe der Figur\n         * @param x die x-Koordinate des Aufhängepunkts der Figur\n         * @param y die y-Koordinate des Aufhängepunkts der Figur\n         */\n        @Override void ElementZeichnen(Graphics2D g, double größe, int x, int y)\n        {\n            g.setColor(c);\n            g.fill(new Ellipse2D.Double (x+größe*xe/100.0, y+größe*ye/100.0, größe*breite/100.0, größe*höhe/100.0));\n        }\n        \n        /**\n         * Fügt den Pfadteil dieser Komponente zum umgebenden Pfad hinzu.\n         * @param p der Gesamtpfad\n         * @param größe die aktuelle Größe der Figur\n         * @param x die x-Koordinate des Aufhängepunkts der Figur\n         * @param y die y-Koordinate des Aufhängepunkts der Figur\n         */\n        @Override void ElementZuForm (Path2D.Double p, double größe, int x, int y)\n        {\n            p.append(new Ellipse2D.Double (x+größe*xe/100.0, y+größe*ye/100.0, größe*breite/100.0, größe*höhe/100.0), false);\n        }\n    }\n    \n    /**\n     * Ein Figurenelement begrenzt durch das angegebene Polygon.\n     */\n    private class FigurenElementPolygon extends FigurenElement\n    {\n        /** Das Polygonobjekt */\n        private Polygon poly;\n        \n        /**\n         * Der Konstruktor speichert die Rahmendaten.\n         * @param x x-Koordinaten der Stützpunkte des Polygons relativ zum Aufhängepunkt.\n         * @param y y-Koordinaten der Stützpunkte des Polygons relativ zum Aufhängepunkt.\n         * @param c Farbe der Polygonfläche\n         */\n        FigurenElementPolygon (int [] x, int[] y, Color c)\n        {\n            int anz = x.length <= y.length ? x.length : y.length;\n            poly = new Polygon (x, y, anz);\n            Rectangle2D bounds = poly.getBounds2D();\n            xe = bounds.getX();\n            ye = bounds.getY();\n            breite = bounds.getWidth();\n            höhe = bounds.getHeight();\n            this.c = c;\n        }\n        \n        /**\n         * Zeichnet das Figurenelement.\n         * @param g das Grafikobjekt\n         * @param größe die aktuelle Größe der Figur\n         * @param x die x-Koordinate des Aufhängepunkts der Figur\n         * @param y die y-Koordinate des Aufhängepunkts der Figur\n         */\n        @Override void ElementZeichnen(Graphics2D g, double größe, int x, int y)\n        {\n            g.setColor(c);\n            AffineTransform at = new AffineTransform(größe/100.0, 0, 0, größe/100.0, x, y);\n            g.fill(new Path2D.Double (poly, at));\n        }\n        \n        /**\n         * Fügt den Pfadteil dieser Komponente zum umgebenden Pfad hinzu.\n         * @param p der Gesamtpfad\n         * @param größe die aktuelle Größe der Figur\n         * @param x die x-Koordinate des Aufhängepunkts der Figur\n         * @param y die y-Koordinate des Aufhängepunkts der Figur\n         */\n        @Override void ElementZuForm (Path2D.Double p, double größe, int x, int y)\n        {\n            AffineTransform at = new AffineTransform(größe/100.0, 0, 0, größe/100.0, x, y);\n            Path2D.Double p2 = new Path2D.Double (poly, at);\n            p2.closePath();\n            p2.setWindingRule(Path2D.WIND_EVEN_ODD);\n            p.append(p2, false);\n        }\n    }\n    \n    /**\n     * Das Objekt dieser Klasse zeichnet den Weg der Turtle.\n     */\n    class TurtleIntern extends GrafikSymbol\n    {\n        private class LinienElement\n        {\n            /** x-Koordinate des Startpunktes. */\n            private double xStart;\n            /** y-Koordinate des Startpunktes. */\n            private double yStart;\n            /** x-Koordinate des Endpunktes. */\n            private double xEnde;\n            /** y-Koordinate des Endpunktes. */\n            private double yEnde;\n            /** Farbe des LinienElements. */\n            private Color c;\n            \n            LinienElement (double xStart, double yStart, double xEnde, double yEnde, Color c)\n            {\n                this.xStart = xStart;\n                this.yStart = yStart;\n                this.xEnde = xEnde;\n                this.yEnde = yEnde;\n                this.c = c;\n            }\n            \n            void Zeichnen (Graphics2D g)\n            {\n                g.setColor(c);\n                g.draw(new Line2D.Double (xStart, yStart, xEnde, yEnde));\n            }\n        }\n        \n        /**\n         * Verwaltet das Hintergrundfenster für die Turtlezeichnung.\n         */\n        private class HintergrundBild\n        {\n            /** Das aktuelle Hintergrundbild. */\n            private BufferedImage bild;\n            /** Das zugehörige Zeichenobjekt. */\n            private Graphics2D g;\n            \n            /**\n             * Der Konstruktor legt das Bild in der Größe der Zeichenfläche an.\n             */\n            HintergrundBild()\n            {\n                bild = new BufferedImage(Zeichenfenster.MalflächenBreiteGeben(), Zeichenfenster.MalflächenBreiteGeben(), BufferedImage.TYPE_INT_ARGB);\n                g = bild.createGraphics();\n                g.setColor(new Color (0, 0, 0, 0));\n                g.fillRect(0, 0, bild.getWidth(), bild.getHeight());\n            }\n            \n            /**\n             * Zeichent die angegebe Linie in das Bild.\n             * @param linie das zu zeichnende Linienelement.\n             */\n            void LinieZeichnen(LinienElement linie)\n            {\n                linie.Zeichnen(g);\n            }\n            \n            /**\n             * Zeichnet das Bild in das angegebene Zeichenobjekt.\n             * @param wohin Zeichenobjekt\n             */\n            void BildZeichnen (Graphics2D wohin)\n            {\n                wohin.drawImage(bild, null, 0, 0);\n            }\n        }\n        \n        /** Genaue x-Koordinate der Turtle. */\n        double xD;\n        /** Genaue y-Koordinate der Turtle. */\n        double yD;\n        /** Startkoordinate der Turtle. */\n        private int homeX;\n        /** Startkoordinate der Turtle. */\n        private int homeY;\n        /** Startwinkel der Turtle. */\n        private int homeWinkel; \n        /** Stiftposition. */\n        boolean stiftUnten;\n        /** Die Sichtbarkeit des Turtle-Symbols. */\n        private boolean symbolSichtbar;\n        /** Linienelemente. */\n        private ArrayList<LinienElement> linien;\n        /** Standardfigur für Turtle. */\n        private LinkedList<FigurenElement> standardFigur;\n        /** Das Hintergrundbild für die Linien. */\n        private HintergrundBild hintergrund;\n\n        /**\n         * Legt die Turtle mit Startpunkt (100|200) in Richtung 0˚ an.\n         */\n        TurtleIntern ()\n        {\n            super ();\n            x = 100;\n            y = 200;\n            xD = x;\n            yD = y;\n            h = 40;\n            b = 40;\n            homeX=x;\n            homeY=y;\n            homeWinkel=winkel;\n            c = Color.black;\n            stiftUnten = true;\n            symbolSichtbar = true;\n            linien = new ArrayList<LinienElement>();\n            hintergrund = new HintergrundBild();\n            standardFigur = new LinkedList<FigurenElement>();\n            StandardfigurErzeugen();\n            FormErzeugen();\n        }\n        \n        /**\n         * Baut die Standardfigur aus den Elementen auf.\n         */\n        private void StandardfigurErzeugen()\n        {\n            //Kopf\n            standardFigur.add(new FigurenElementEllipse(50, -12.5, 25, 25, Color.GREEN));\n            //Beine\n            standardFigur.add(new FigurenElementEllipse(22.5, -32.5, 12.5, 17.5, Color.GREEN));\n            standardFigur.add(new FigurenElementEllipse(40.0, -32.5, 12.5, 17.5, Color.GREEN));\n            standardFigur.add(new FigurenElementEllipse(22.5, 15.0, 12.5, 17.5, Color.GREEN));\n            standardFigur.add(new FigurenElementEllipse(40.0, 15.0, 12.5, 17.5, Color.GREEN));\n            //Augen\n            standardFigur.add(new FigurenElementRechteck(67.5, -10.0, 5.0, 7.5, c));\n            standardFigur.add(new FigurenElementRechteck(67.5, 2.5, 5.0, 7.5, c));\n            //Schwanz\n            standardFigur.add(new FigurenElementEllipse(0, -3.75, 25, 7.5, c));\n            //Rumpf\n            standardFigur.add(new FigurenElementEllipse(7.5, -23.75, 57.5, 47.5, braun));\n        }\n        \n        /**\n         * Passt das Hintergrundbild an eine neue Größe der Zeichenfläche an.\n         */\n        void NeueGrößeSetzen()\n        {\n            hintergrund = new HintergrundBild();\n            for (LinienElement l: linien)\n            {\n                hintergrund.LinieZeichnen(l);\n            }\n        }\n                \n        /**\n         * Erstellt die Form der Turtle.\n         */\n        @Override void FormErzeugen()\n        {\n            Area area = new Area();\n            AffineTransform a = new AffineTransform();\n            a.rotate(DrehwinkelGeben (winkel), this.x, this.y);\n            double größe = h > b ? b : h;\n            if (standardFigur != null)\n            {\n                synchronized (standardFigur)\n                {\n                    for (FigurenElement e: standardFigur)\n                    {\n                        Path2D.Double p = new Path2D.Double();\n                        e.ElementZuForm(p, größe, x, y);\n                        area.add( new Area(new Path2D.Double (p, a)));\n                    }\n                }\n               \n            }\n            form = area;\n        }\n        \n        /**\n         * Setzt die Position (der linken oberen Ecke) des Objekts.\n         * @param x x-Position der linken oberen Ecke\n         * @param y y-Position der linken oberen Ecke\n         */\n        @Override void PositionSetzen (int x, int y)\n        {\n            super.PositionSetzen (x, y);\n            xD = x;\n            yD = y;\n        }\n\n        /**\n         * Setzt die Turtle wieder an ihre Ausgangsposition.\n         */\n        void ZumStartpunktGehen()\n        {\n            x = homeX;\n            y = homeY;\n            xD = x;\n            yD = y;\n            winkel = homeWinkel;\n            FormErzeugen();\n            zeichenfläche.malfläche.repaint();\n        }\n    \n        /**\n         * Bewegt die Turtle nach vorne.\n         * @param länge Anzahl der Längeneinheiten\n         */\n        void Gehen(double länge)\n        {   \n            double neuX = xD + Math.cos(DrehwinkelGeben (winkel)) * länge;\n            double neuY = yD + Math.sin(DrehwinkelGeben (winkel)) * länge;            \n            if (stiftUnten)\n            {\n                synchronized (this)\n                {\n                    LinienElement l = new LinienElement(xD, yD, neuX, neuY, c);\n                    linien.add (l);\n                    hintergrund.LinieZeichnen (l);\n                }\n            }    \n            xD = neuX;\n            yD = neuY;\n            x =(int) Math.round(xD);\n            y =(int) Math.round(yD);\n            FormErzeugen();\n            zeichenfläche.malfläche.repaint();\n        }\n    \n        /**\n         * Dreht die Turtle\n         * @param grad Drehwinkel im Gradmass\n         */\n        void Drehen(int grad)\n        {\n            winkel = WinkelNormieren(winkel + grad);\n            FormErzeugen();\n            zeichenfläche.malfläche.repaint();\n        }\n\n        /**\n         * Versetzt Zeichenfläche und Turtle in den Ausgangszustand\n         */\n        void Löschen()\n        {\n            linien.clear();\n            hintergrund = new HintergrundBild();\n            ZumStartpunktGehen();\n        }\n\n        /**\n         * Turtle wechselt in den Modus \"nicht zeichnen\"\n         */\n        void StiftHeben()\n        {\n            stiftUnten = false;\n        }\n    \n        /**\n         * Turtle wechselt in den Modus \"zeichnen\"\n         */\n        void StiftSenken()\n        {\n            stiftUnten = true;\n        }\n    \n        /**\n         * Schaltet die Sichtbarkeit des Turtlesymbols ein oder aus.\n         * Erlaubte Parameterwerte: true, false\n         * @param sichtbar (neue) Sichtbarkeit des Turtlesymbols\n         */\n        void SichtbarkeitFürSymbolSetzen (boolean sichtbar)\n        {\n            symbolSichtbar = sichtbar;\n            zeichenfläche.malfläche.repaint();\n        }\n        \n        /**\n         * Testet, ob der angegebene Punkt innerhalb der Figur ist.\n         * @param x x-Koordinate des zu testenden Punktes\n         * @param y y-Koordinate des zu testenden Punktes\n         * @return wahr, wenn der Punkt innerhalb der Figur ist\n         */\n        \n        /**\n         * Testet, ob die Turtle eine (sichtbare) Figur berührt.\n         * @return true, wenn die Turtlekoordinaten innerhalb einer Grafikfigur sind\n         */\n        boolean Berührt ()\n        {\n            for (GrafikSymbol g: zeichenfläche.alleSymbole)\n            {\n                if ((g != this) && g.IstInnerhalb(x, y) && g.sichtbar && (!(g instanceof TurtleIntern) || ((TurtleIntern) g).symbolSichtbar))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n        \n        /**\n         * Testet, ob die Turtle eine (sichtbare) Figur in der angegebenen Farbe berührt.\n         * Bei Überlappungen \n         * @param farbe die Farbe, die die berührte Figur haben muss.\n         * @return true, wenn die Turtlekoordinaten innerhalb einer Grafikfigur in der angegebenen Farbe sind\n         */\n        boolean Berührt (String farbe)\n        {\n            Color c2 = FarbeCodieren(farbe);\n            boolean ok = false;\n            for (GrafikSymbol g: zeichenfläche.alleSymbole)\n            {\n                if ((g != this) && g.IstInnerhalb(x, y) && g.sichtbar)\n                {\n                    if (g instanceof TurtleIntern)\n                    {\n                        TurtleIntern t = (TurtleIntern) g;\n                        if (t.symbolSichtbar)\n                        {\n                            for (FigurenElement e: t.standardFigur)\n                            {\n                                Path2D.Double p = new Path2D.Double();\n                                double größe = t.h > t.b ? t.b : t.h;\n                                e.ElementZuForm(p, größe, t.x, t.y);  \n                                AffineTransform a = new AffineTransform();\n                                a.rotate(DrehwinkelGeben (t.winkel), t.x, t.y);\n                                p = new Path2D.Double (p, a);\n                                if (p.contains(x, y))\n                                {\n                                    ok = c2.equals(e.c);\n                                }\n                            }\n                        }\n                    }\n                    else if (g instanceof FigurIntern)\n                    {\n                        FigurIntern t = (FigurIntern) g;\n                        LinkedList<FigurenElement> figur = ((t.eigeneFigur == null) || (t.eigeneFigur.size() == 0)) ? t.standardFigur : t.eigeneFigur;\n                        for (FigurenElement e: figur)\n                        {\n                            Path2D.Double p = new Path2D.Double();\n                            double größe = t.h > t.b ? t.b : t.h;\n                            e.ElementZuForm(p, größe, t.x, t.y);  \n                            AffineTransform a = new AffineTransform();\n                            a.rotate(DrehwinkelGeben (t.winkel), t.x, t.y);\n                            p = new Path2D.Double (p, a);\n                            if (p.contains(x, y))\n                            {\n                                ok = c2.equals(e.c);\n                            }\n                        }\n                    }\n                    else\n                    {\n                        ok = ok || c2.equals(g.c);\n                    }\n                }\n            }\n            return ok;\n        }\n        \n        /**\n         * Testet, ob die Turtle die (sichtbare, ) angegebene Figur berührt.\n         * @param object das Objekt, das getestet werden soll.\n         * @return true, wenn die Turtlekoordinaten innerhalb einer Grafikfigur in der angegebenen Farbe sind\n         */\n        boolean Berührt (Object object)\n        {\n            GrafikSymbol s = null;\n            if (object instanceof Rechteck)\n            {\n                s = ((Rechteck) object).symbol;\n            }\n            else if (object instanceof Dreieck)\n            {\n                s = ((Dreieck) object).symbol;\n            }\n            else if (object instanceof Kreis)\n            {\n                s = ((Kreis) object).symbol;\n            }\n            else if (object instanceof Turtle)\n            {\n                s = ((Turtle) object).symbol;\n            }\n            else if (object instanceof Figur)\n            {\n                s = ((Figur) object).symbol;\n            }\n            return (s != null) && (s != this) && s.IstInnerhalb(x, y) && s.sichtbar && (!(s instanceof TurtleIntern) || ((TurtleIntern) s).symbolSichtbar);\n        }\n\n        /**\n         * Zeichnet das Objekt als Dreieck in der gegebenen Farbe.\n         * @param g das Grafikobjekt zum Zeichnen\n         */\n        @Override void Zeichnen(Graphics g)\n        {\n            Graphics2D g2 = (Graphics2D) g;\n            synchronized (this)\n            {\n                hintergrund.BildZeichnen(g2);\n            }\n            \n            if (symbolSichtbar)\n            {\n                g.setColor(Color.black);\n                double größe = h > b ? b : h;\n                AffineTransform alt = g2.getTransform();\n                g2.rotate(DrehwinkelGeben (winkel), x, y);\n                if (standardFigur != null)\n                {\n                    synchronized (standardFigur)\n                    {\n                        for (FigurenElement e: standardFigur)\n                        {\n                            e.ElementZeichnen(g2, größe, x, y);\n                        }\n                    }\n                }\n                g2.setTransform(alt);\n            }\n        }\n    }\n    \n    /**\n     * Das Objekt dieser Klasse ist ein in der Gestalt definierbarer Akteur.\n     */\n    class FigurIntern extends GrafikSymbol\n    {\n        \n        /** Genaue x-Koordinate der Figur. */\n        double xD;\n        /** Genaue y-Koordinate der Figur. */\n        double yD;\n        /** Startkoordinate der Figur. */\n        private int homeX;\n        /** Startkoordinate der Figur. */\n        private int homeY;\n        /** Startwinkel der Figur. */\n        private int homeWinkel; \n        /** Eigene Figur für Figur. */\n        private LinkedList<FigurenElement> eigeneFigur;\n        /** Standardfigur für Figur. */\n        private LinkedList<FigurenElement> standardFigur;\n\n        /**\n         * Legt die Figur mit Startpunkt (100|200) in Richtung 0˚ an.\n         */\n        FigurIntern ()\n        {\n            super ();\n            x = 100;\n            y = 200;\n            xD = x;\n            yD = y;\n            h = 40;\n            b = 40;\n            homeX=x;\n            homeY=y;\n            homeWinkel=winkel;\n            c = Color.black;\n            eigeneFigur = new LinkedList<FigurenElement>();\n            standardFigur = new LinkedList<FigurenElement>();\n            StandardfigurErzeugen();\n            FormErzeugen();\n        }\n        \n        /**\n         * Baut die Standardfigur aus den Elementen auf.\n         */\n        private void StandardfigurErzeugen()\n        {            \n            int[] x = new int [] {-50, 50, -50};\n            int[] y = new int [] {-50, 0, 50};\n            standardFigur.add (new FigurenElementPolygon (x, y, Color.yellow));\n            standardFigur.add(new FigurenElementEllipse(-10, -10, 20, 20, Color.blue));\n        }\n                \n        /**\n         * Erstellt die Form der Figur.\n         */\n        @Override void FormErzeugen()\n        {\n            Area area = new Area();\n            AffineTransform a = new AffineTransform();\n            a.rotate(DrehwinkelGeben (winkel), this.x, this.y);\n            double größe = h > b ? b : h;\n            if (standardFigur != null)\n            {\n                LinkedList<FigurenElement> figur = ((eigeneFigur == null) || (eigeneFigur.size() == 0)) ? standardFigur : eigeneFigur;\n                synchronized (figur)\n                {\n                    for (FigurenElement e: figur)\n                    {\n                        Path2D.Double p = new Path2D.Double();\n                        e.ElementZuForm(p, größe, x, y);\n                        area.add(new Area(new Path2D.Double (p, a)));\n                    }\n                }\n               \n            }\n            form = area;\n        }\n        \n        /**\n         * Setzt die Position (der Mitte) des Objekts.\n         * @param x x-Position der Mitte\n         * @param y y-Position der Mitte\n         */\n        @Override void PositionSetzen (int x, int y)\n        {\n            super.PositionSetzen (x, y);\n            xD = x;\n            yD = y;\n        }\n\n        /**\n         * Setzt die Figur wieder an ihre Ausgangsposition.\n         */\n        void ZumStartpunktGehen()\n        {\n            x = homeX;\n            y = homeY;\n            xD = x;\n            yD = y;\n            winkel = homeWinkel;\n            FormErzeugen();\n            zeichenfläche.malfläche.repaint();\n        }\n    \n        /**\n         * Bewegt die Figur nach vorne.\n         * @param länge Anzahl der Längeneinheiten\n         */\n        void Gehen(double länge)\n        {   \n            double neuX = xD + Math.cos(DrehwinkelGeben (winkel)) * länge;\n            double neuY = yD + Math.sin(DrehwinkelGeben (winkel)) * länge;            \n            xD = neuX;\n            yD = neuY;\n            x =(int) Math.round(xD);\n            y =(int) Math.round(yD);\n            FormErzeugen();\n            zeichenfläche.malfläche.repaint();\n        }\n    \n        /**\n         * Dreht die Figur\n         * @param grad Drehwinkel im Gradmass\n         */\n        void Drehen(int grad)\n        {\n            winkel = WinkelNormieren(winkel + grad);\n            FormErzeugen();\n            zeichenfläche.malfläche.repaint();\n        }\n        \n        /**\n         * Testet, ob die Figur eine (sichtbare) Grafik-Figur berührt.\n         * @return true, wenn die Figurkoordinaten innerhalb einer Grafikfigur sind\n         */\n        boolean Berührt ()\n        {\n            for (GrafikSymbol g: zeichenfläche.alleSymbole)\n            {\n                if ((g != this) && g.Schneidet(form) && g.sichtbar && (!(g instanceof TurtleIntern) || ((TurtleIntern) g).symbolSichtbar))\n                {\n                    return true;\n                }\n            }\n            return false;\n        }\n        \n        /**\n         * Testet, ob die Figur eine (sichtbare) Grafik-Figur in der angegebenen Farbe berührt.\n         * Bei Überlappungen \n         * @param farbe die Farbe, die die berührte Figur haben muss.\n         * @return true, wenn die Figurkoordinaten innerhalb einer Grafikfigur in der angegebenen Farbe sind\n         */\n        boolean Berührt (String farbe)\n        {\n            Color c2 = FarbeCodieren(farbe);\n            boolean ok = false;\n            for (GrafikSymbol g: zeichenfläche.alleSymbole)\n            {\n                if ((g != this) && g.Schneidet(form) && g.sichtbar)\n                {\n                    if (g instanceof TurtleIntern)\n                    {\n                        TurtleIntern t = (TurtleIntern) g;\n                        if (t.symbolSichtbar)\n                        {\n                            Area[] areas = new Area [t.standardFigur.size()];\n                            Color[] colors = new Color [t.standardFigur.size()];\n                            AffineTransform a = new AffineTransform();\n                            a.rotate(DrehwinkelGeben (t.winkel), t.x, t.y);\n                            int pos = 0;\n                            for (FigurenElement e: t.standardFigur)\n                            {\n                                Path2D.Double p = new Path2D.Double();\n                                double größe = t.h > t.b ? t.b : t.h;\n                                e.ElementZuForm(p, größe, t.x, t.y);  \n                                p = new Path2D.Double (p, a);\n                                areas [pos] = new Area(p);\n                                colors[pos] = e.c;\n                                for (int i = pos - 1; i >= 0;i--)\n                                {\n                                    areas[i].subtract(areas[pos]);\n                                }\n                                pos += 1;\n                            }\n                            for (int i = 0; i < areas.length; i++)\n                            {\n                                if (Schneidet(areas[i]) && (c2.equals(colors[i])))\n                                {\n                                    ok = true;\n                                }\n                            }\n                        }\n                    }\n                    else if (g instanceof FigurIntern)\n                    {\n                        FigurIntern t = (FigurIntern) g;\n                        LinkedList<FigurenElement> figur = ((t.eigeneFigur == null) || (t.eigeneFigur.size() == 0)) ? t.standardFigur : t.eigeneFigur;\n                        Area[] areas = new Area [figur.size()];\n                        Color[] colors = new Color [figur.size()];\n                        AffineTransform a = new AffineTransform();\n                        a.rotate(DrehwinkelGeben (t.winkel), t.x, t.y);\n                        int pos = 0;\n                        for (FigurenElement e: figur)\n                        {\n                            Path2D.Double p = new Path2D.Double();\n                            double größe = t.h > t.b ? t.b : t.h;\n                            e.ElementZuForm(p, größe, t.x, t.y);  \n                            p = new Path2D.Double (p, a);\n                            areas [pos] = new Area(p);\n                            colors[pos] = e.c;\n                            for (int i = pos - 1; i >= 0;i--)\n                            {\n                                areas[i].subtract(areas[pos]);\n                            }\n                            pos += 1;\n                        }\n                        for (int i = 0; i < areas.length; i++)\n                        {\n                            if (Schneidet(areas[i]) && (c2.equals(colors[i])))\n                            {\n                                ok = true;\n                            }\n                        }\n                    }\n                    else\n                    {\n                        ok = ok || c2.equals(g.c);\n                    }\n                }\n            }\n            return ok;\n        }\n        \n        /**\n         * Testet, ob die Figur die (sichtbare, ) angegebene Grafik-Figur berührt.\n         * @param object das Objekt, das getestet werden soll.\n         * @return true, wenn die Turtlekoordinaten innerhalb einer Grafikfigur in der angegebenen Farbe sind\n         */\n        boolean Berührt (Object object)\n        {\n            GrafikSymbol s = null;\n            if (object instanceof Rechteck)\n            {\n                s = ((Rechteck) object).symbol;\n            }\n            else if (object instanceof Dreieck)\n            {\n                s = ((Dreieck) object).symbol;\n            }\n            else if (object instanceof Kreis)\n            {\n                s = ((Kreis) object).symbol;\n            }\n            else if (object instanceof Turtle)\n            {\n                s = ((Turtle) object).symbol;\n            }\n            else if (object instanceof Figur)\n            {\n                s = ((Figur) object).symbol;\n            }\n            return (s != null) && (s != this) && s.Schneidet(form) && s.sichtbar && (!(s instanceof TurtleIntern) || ((TurtleIntern) s).symbolSichtbar);\n        }\n\n        /**\n         * Erzeugt ein neues, rechteckiges Element einer eigenen Darstellung der Figur.\n         * Alle Werte beziehen sich auf eine Figur der Größe 100 und den Koordinaten (0|0) in der Mitte des Quadrats\n         * @param x x-Wert der linken oberen Ecke des Rechtecks\n         * @param y y-Wert der linken oberen Ecke des Rechtecks\n         * @param breite Breite des Rechtecks\n         * @param höhe Höhe des Rechtecks\n         * @param farbe (Füll)Farbe des Rechtecks\n         */\n        void FigurteilFestlegenRechteck (int x, int y, int breite, int höhe, String farbe)\n        {\n            synchronized (eigeneFigur)\n            {\n                eigeneFigur.add(new FigurenElementRechteck(x, y, breite, höhe, FarbeCodieren(farbe)));\n            }\n            FormErzeugen();\n            zeichenfläche.malfläche.repaint();\n        }\n\n        /**\n         * Erzeugt ein neues, elliptisches Element einer eigenen Darstellung der Figur.\n         * Alle Werte beziehen sich auf eine Figur der Größe 100 und den Koordinaten (0|0) in der Mitte des Quadrats\n         * @param x x-Wert der linken oberen Ecke des umgebenden Rechtecks der Ellipse\n         * @param y y-Wert der linken oberen Ecke des umgebenden Rechtecks der Ellipse\n         * @param breite Breite des umgebenden Rechtecks der Ellipse\n         * @param höhe Höhe des umgebenden Rechtecks der Ellipse\n         * @param farbe (Füll)Farbe der Ellipse\n         */\n        void FigurteilFestlegenEllipse (int x, int y, int breite, int höhe, String farbe)\n        {\n            synchronized (eigeneFigur)\n            {\n                eigeneFigur.add(new FigurenElementEllipse(x, y, breite, höhe, FarbeCodieren(farbe)));\n            }\n            FormErzeugen();\n            zeichenfläche.malfläche.repaint();\n        }\n\n        /**\n         * Erzeugt ein neues, dreieckiges Element einer eigenen Darstellung der Figur.\n         * Alle Werte beziehen sich auf eine Figur der Größe 100 und den Koordinaten (0|0) in der Mitte des Quadrats\n         * @param x1 x-Wert des ersten Punkts des Dreiecks\n         * @param y1 y-Wert des ersten Punkts des Dreiecks\n         * @param x2 x-Wert des zweiten Punkts des Dreiecks\n         * @param y2 y-Wert des zweiten Punkts des Dreiecks\n         * @param x3 x-Wert des dritten Punkts des Dreiecks\n         * @param y3 y-Wert des dritten Punkts des Dreiecks\n         * @param farbe (Füll)Farbe der Ellipse\n         */\n        void FigurteilFestlegenDreieck (int x1, int y1, int x2, int y2, int x3, int y3, String farbe)\n        {\n            synchronized (eigeneFigur)\n            {\n                int[] x = new int [] {x1, x2, x3};\n                int[] y = new int [] {y1, y2, y3};\n                eigeneFigur.add(new FigurenElementPolygon(x, y, FarbeCodieren(farbe)));\n            }\n            FormErzeugen();\n            zeichenfläche.malfläche.repaint();\n        }\n        \n        /**\n         * Löscht die Vereinbarung für die eigene Darstellung Figur.\n         * Die Figur wird wieder durch die Originalfigur dargestellt.\n         */\n        void EigeneFigurLöschen()\n        {\n            eigeneFigur.clear();\n            FormErzeugen();\n            zeichenfläche.malfläche.repaint();\n        }\n\n        /**\n         * Zeichnet das Objekt als Dreieck in der gegebenen Farbe.\n         * @param g das Grafikobjekt zum Zeichnen\n         */\n        @Override void Zeichnen(Graphics g)\n        {\n            Graphics2D g2 = (Graphics2D) g;\n            // Outline\n            g.setColor(Color.black);\n            Stroke stAlt = g2.getStroke();\n            g2.setStroke(new BasicStroke(3.0f));\n            g2.draw(form);\n            g2.setStroke(stAlt);\n            // Füllung\n            double größe = h > b ? b : h;\n            AffineTransform alt = g2.getTransform();\n            g2.rotate(DrehwinkelGeben (winkel), x, y);\n            if (standardFigur != null)\n            {\n                LinkedList<FigurenElement> figur = ((eigeneFigur == null) || (eigeneFigur.size() == 0)) ? standardFigur : eigeneFigur;\n                synchronized (figur)\n                {\n                    for (FigurenElement e: figur)\n                    {\n                        e.ElementZeichnen(g2, größe, x, y);\n                    }\n                }\n            }\n            g2.setTransform(alt);\n        }\n    }\n}\n","position":{"x":-54.88688015973881,"y":140.53895746736566}},{"name":"Dreieck","content":"\n/**\n * Wrapperklasse für ein Dreieck auf der Zeichenfläche.\n * \n * @author Albert Wiedemann \n * @version 1.0\n */\npublic class Dreieck\n{\n    /** x-Position der Spitze. */\n    protected int x;\n    /** y-Position der Spitze. */\n    protected int y;\n    /** Breite des umgebenden Rechtecks. */\n    protected int breite;\n    /** Höhe des umgebenden Rechtecks. */\n    protected int höhe;\n    /** Farbe des Dreiecks. */\n    protected String farbe;\n    /** Sichtbarkeit des Dreiecks. */\n    protected boolean sichtbar;\n    /** Drehwinkel (mathematisch positiver Drehsinn) des Dreiecks in Grad. */\n    protected int winkel;\n    /** Referenz auf das Delegate-Objekt. */\n    Zeichenfenster.GrafikSymbol symbol;\n\n    /**\n     * Der Konstruktor erzeugt das Delegate-Objekt\n     */\n    Dreieck ()\n    {\n        x = 60;\n        y = 10;\n        breite = 100;\n        höhe = 100;\n        farbe = \"rot\";\n        sichtbar = true;\n        winkel = 0;\n        symbol = Zeichenfenster.SymbolErzeugen(Zeichenfenster.SymbolArt.dreieck);\n        symbol.PositionSetzen(x - breite / 2, y);\n        symbol.GrößeSetzen(breite, höhe);\n        symbol.FarbeSetzen(farbe);\n        symbol.SichtbarkeitSetzen(sichtbar);\n        symbol.WinkelSetzen(winkel);\n    }\n    \n    /**\n     * Setzt die Position (der Spitze) des Dreiecks.\n     * @param x x-Position der Spitze\n     * @param y y-Position der Spitze\n     */\n    void PositionSetzen(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n        symbol.PositionSetzen(x - breite / 2, y);\n    }\n    \n    /**\n     * Verschiebt das Dreieck um die angegebenen Werte.\n     * @param deltaX Verschiebung in x-Richtung\n     * @param deltaY Verschiebung in y-Richtung\n     */\n    void Verschieben(int deltaX, int deltaY)\n    {\n        x += deltaX;\n        y += deltaY;\n        symbol.PositionSetzen(x - breite / 2, y);\n    }\n    \n    /**\n     * Dreht das Dreieck\n     * @param grad Drehwinkel (mathematisch positiver Drehsinn) im Gradmass\n     */\n    void Drehen(int grad)\n    {\n        winkel += grad;\n        symbol.WinkelSetzen(winkel);\n    }\n        \n    /**\n     * Setzt die Größe des Dreiecks.\n     * @param breite (neue) Breite\n     * @param höhe (neue) Höhe\n     */\n    void GrößeSetzen (int breite, int höhe)\n    {\n        this.breite = breite;\n        this.höhe = höhe;\n        symbol.GrößeSetzen(breite, höhe);\n        symbol.PositionSetzen(x - breite / 2, y);\n    }\n    \n    /**\n     * Setzt die Farbe des Dreiecks.\n     * Erlaubte Farben sind:\n     * \"weiß\", \"weiss\", \"rot\", \"grün\", \"gruen\", \"blau\", \"gelb\",\n     * \"magenta\", \"cyan\", \"hellgelb\", \"hellgrün\", \"hellgruen\",\n     * \"orange\", \"braun\", \"grau\", \"schwarz\"\n     * Alle anderen Eingaben werden auf die Farbe schwarz abgebildet.\n     * @param farbe (neue) Farbe\n     */\n    void FarbeSetzen (String farbe)\n    {\n        this.farbe = farbe;\n        symbol.FarbeSetzen(farbe);\n    }\n        \n    /**\n     * Setzt den Drehwinkel des Dreiecks.\n     * Die Winkelangabe ist in Grad,positive Werte drehen gegen den Uhrzeigersinn,\n     * negative Werte drehen im Uhrzeigersinn (mathematisch positiver Drehsinn).\n     * @param winkel der (neue) Drehwinkel des Dreiecks\n     */\n    void WinkelSetzen (int winkel)\n    {\n        this.winkel = winkel;\n        symbol.WinkelSetzen(winkel);\n    }\n    \n    /**\n     * Schaltet die Sichtbarkeit des Dreiecks ein oder aus.\n     * Erlaubte Parameterwerte: true, false\n     * @param sichtbar (neue) Sichtbarkeit des Dreiecks\n     */\n    void SichtbarkeitSetzen (boolean sichtbar)\n    {\n        this.sichtbar = sichtbar;\n        symbol.SichtbarkeitSetzen(sichtbar);\n    }\n        \n    /**\n     * Entfernt das Dreieck aus dem Zeichenfenster.\n     */\n    void Entfernen ()\n    {\n        symbol.Entfernen();\n    }\n    \n    /**\n     * Bringt das Dreieck eine Ebene nach vorn.\n     */\n    void NachVornBringen ()\n    {\n        symbol.NachVornBringen();\n    }\n    \n    /**\n     * Bringt das Dreieck in die vorderste Ebene.\n     */\n    void GanzNachVornBringen ()\n    {\n        symbol.GanzNachVornBringen();\n    }\n    \n    /**\n     * Bringt das Dreieck eine Ebene nach hinten.\n     */\n    void NachHintenBringen ()\n    {\n        symbol.NachHintenBringen();\n    }\n    \n    /**\n     * Bringt das Dreieck in die hinterste Ebene.\n     */\n    void GanzNachHintenBringen ()\n    {\n        symbol.GanzNachHintenBringen();\n    }\n}\n","position":{"x":232.2757018745864,"y":67.7874035573206}},{"name":"Ereignisbehandlung","content":"import java.awt.*;\nimport javax.swing.*;\nimport java.awt.event.*;\n\n/**\n * Zugriff auf die Ereignisse einschließlich Taktgeber.\n * \n * @author Albert Wiedemann\n * @version 1.0\n */\npublic class Ereignisbehandlung\n{\n    /**\n     * Der Konstruktor meldet den Taktgeber\n     * und die Eventlistener bei der Zeichenfläche an.\n     */\n    Ereignisbehandlung ()\n    {\n        Zeichenfenster.AktionsEmpfängerEintragen(new Zeichenfenster.AktionsEmpfaenger()\n        {\n            public void Ausführen ()\n            {\n                TaktImpulsAusführen();\n            }\n            \n            public void Taste (char taste)\n            {\n                TasteGedrückt(taste);\n            }\n            \n            public void SonderTaste (int taste)\n            {\n                SonderTasteGedrückt(taste);\n            }\n            \n            public void Geklickt (int x, int y, int anzahl)\n            {\n                MausGeklickt(x, y, anzahl);\n            }\n        });\n    }\n    \n    /**\n     * Die eigentliche Aktionsmethode des Zeitgebers.\n     * <br>Muss bei Bedarf von einer Unterklasse überschrieben werden. \n     */\n    void TaktImpulsAusführen ()\n    {\n        System.out.println (\"Tick\");\n    }\n\n    /**\n     * Zeitgeber starten.\n     */\n    void Starten ()\n    {\n        Zeichenfenster.TaktgeberStarten();\n    }\n\n    /**\n     * Zeitgeber anhalten.\n     */\n    void Anhalten ()\n    {\n        Zeichenfenster.TaktgeberStoppen();\n    }\n    \n    /**\n     * Ablaufgeschwindigkeit des Zeitgebers einstellen.\n     * \n     * @param dauer: Angabe in Millisekunden\n     */\n    void TaktdauerSetzen (int dauer)\n    {\n        Zeichenfenster.TaktdauerSetzen(dauer);\n    }\n    \n    /**\n     * Die eigentliche Aktionsmethode für gedrückte Tasten.\n     * <br>Muss bei Bedarf von einer Unterklasse überschrieben werden. \n     * @param taste die gedrückte Taste\n     */\n    void TasteGedrückt (char taste)\n    {\n        System. out. println (\"Taste: \" + taste);\n    }\n    \n    /**\n     * Die eigentliche Aktionsmethode für gedrückte Sondertasten.\n     * <br>Muss bei Bedarf von einer Unterklasse überschrieben werden. \n     * @param taste KeyCode der gedrückten Taste\n     */\n    void SonderTasteGedrückt (int taste)\n    {\n        System. out. println (\"Sondertaste: \" + taste);\n    }\n    \n    /**\n     * Die eigentliche Aktionsmethode für einen Mausklick.\n     * <br>Muss bei Bedarf von einer Unterklasse überschrieben werden. \n     * @param x x-Position des Mausklicks\n     * @param y y-Position des Mausklicks\n     * @param anzahl Anzahl der aufeinanderfolgenden Mausklicks\n     */\n    void MausGeklickt (int x, int y, int anzahl)\n    {\n        System. out. println (\"Maus: (\" + x + \"|\" + y + \"), \" + anzahl + \" mal\");\n    }\n}\n","position":{"x":82.21134070485175,"y":198.59059628295375}},{"name":"Figur","content":"\n/**\n * Wrapperklasse für die Turtle auf der Zeichenfläche.\n * \n * @author Albert Wiedemann \n * @version 1.0\n */\npublic class Figur\n{\n    /** x-Position der Figur. */\n    private int x;\n    /** y-Position der Figur. */\n    private int y;\n    /** Größe der Figur. */\n    private int größe;\n    /** Farbe der Figur. */\n    private String farbe;\n    /** Sichtbarkeit der Figur. */\n    private boolean sichtbar;\n    /** Drehwinkel (mathemtisch positiver Drehsinn) der Turtle in Grad. */\n    private int winkel;\n    /** Referenz auf das echte Figursymbol. */\n    Zeichenfenster.FigurIntern symbol;\n    /** Referenz auf das Aktionsempfängerobjekt. */\n    Zeichenfenster.AktionsEmpfaenger aktionsEmpfänger;\n    \n    /**\n     * Konstruktor der Figur\n     * Erzeugt eine Figur und versetzt sie in einen gültigen Startzustand.\n     */\n    Figur ()\n    {\n        symbol = (Zeichenfenster.FigurIntern) Zeichenfenster.SymbolErzeugen(Zeichenfenster.SymbolArt.figur);\n        symbol.SichtbarkeitSetzen(true);\n        x = symbol.x;\n        y = symbol.y;\n        winkel = symbol.winkel;\n        größe = symbol.b;\n        sichtbar = symbol.sichtbar;\n        aktionsEmpfänger = new Zeichenfenster.AktionsEmpfaenger()\n        {\n            public void Ausführen ()\n            {\n                AktionAusführen();\n            }\n            \n            public void Taste (char taste)\n            {\n                TasteGedrückt(taste);\n            }\n            \n            public void SonderTaste (int taste)\n            {\n                SonderTasteGedrückt(taste);\n            }\n            \n            public void Geklickt (int x, int y, int anzahl)\n            {\n                MausGeklickt(x, y, anzahl);\n            }\n        };\n        Zeichenfenster.AktionsEmpfängerEintragen(aktionsEmpfänger);\n    }\n    \n    /**\n     * Methode wird aufgerufen, wenn die Figur handeln soll.\n     * Die vordefinierte Methode tut nichts.\n     */\n    void AktionAusführen()\n    {\n    }\n    \n    /**\n     * Die eigentliche Aktionsmethode für gedrückte Tasten.\n     * <br>Muss bei Bedarf von einer Unterklasse überschrieben werden. \n     * @param taste die gedrückte Taste\n     */\n    void TasteGedrückt (char taste)\n    {\n        //System. out. println (\"Taste: \" + taste);\n    }\n    \n    /**\n     * Die eigentliche Aktionsmethode für gedrückte Sondertasten.\n     * <br>Muss bei Bedarf von einer Unterklasse überschrieben werden. \n     * @param taste KeyCode der gedrückten Taste\n     */\n    void SonderTasteGedrückt (int taste)\n    {\n        //System. out. println (\"Sondertaste: \" + taste);\n    }\n    \n    /**\n     * Die eigentliche Aktionsmethode für einen Mausklick.\n     * <br>Muss bei Bedarf von einer Unterklasse überschrieben werden. \n     * @param x x-Position des Mausklicks\n     * @param y y-Position des Mausklicks\n     * @param anzahl Anzahl der aufeinanderfolgenden Mausklicks\n     */\n    void MausGeklickt (int x, int y, int anzahl)\n    {\n        //System. out. println (\"Maus: (\" + x + \"|\" + y + \"), \" + anzahl + \" mal\");\n    }\n    \n    /**\n     * Setzt die Position der Figur.\n     * @param x x-Position der Figur\n     * @param y y-Position der Figur\n     */\n    void PositionSetzen(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n        symbol.PositionSetzen(x, y);\n    }\n        \n    /**\n     * Setzt die Größe des Figurensymbols.\n     * @param größe (neue) Größe\n     */\n    void GrößeSetzen (int größe)\n    {\n        this.größe = größe;\n        symbol.GrößeSetzen(größe, größe);\n    }\n        \n    /**\n     * Setzt den Drehwinkel der Figur.\n     * Die Winkelangabe ist in Grad, positive Werte drehen gegen den Uhrzeigersinn,\n     * negative Werte drehen im Uhrzeigersinn (mathematisch positiver Drehsinn), d. h.\n     * 0˚: Figur schaut nach rechts,\n     * 90˚: Figur schaut nach oben,\n     * 180˚: Figur schaut nach links,\n     * 270˚bzw. -90˚: Figur schaut nach unten\n     * @param winkel der (neue) Drehwinkel der Figur\n     */\n    void WinkelSetzen (int winkel)\n    {\n        this.winkel = winkel;\n        symbol.WinkelSetzen(winkel);\n    }\n    \n    /**\n     * Schaltet die Sichtbarkeit der Figur ein oder aus.\n     * Erlaubte Parameterwerte: true, false\n     * @param sichtbar (neue) Sichtbarkeit der Figur\n     */\n    void SichtbarkeitSetzen (boolean sichtbar)\n    {\n        this.sichtbar = sichtbar;\n        symbol.SichtbarkeitSetzen(sichtbar);\n    }\n        \n    /**\n     * Entfernt die Figur aus dem Zeichenfenster.\n     */\n    void Entfernen ()\n    {\n        Zeichenfenster.AktionsEmpfängerEntfernen(aktionsEmpfänger);\n        symbol.Entfernen();\n    }\n    \n    /**\n     * Bringt die Figur eine Ebene nach vorn.\n     */\n    void NachVornBringen ()\n    {\n        symbol.NachVornBringen();\n    }\n    \n    /**\n     * Bringt die Figur in die vorderste Ebene.\n     */\n    void GanzNachVornBringen ()\n    {\n        symbol.GanzNachVornBringen();\n    }\n    \n    /**\n     * Bringt die Figur eine Ebene nach hinten.\n     */\n    void NachHintenBringen ()\n    {\n        symbol.NachHintenBringen();\n    }\n    \n    /**\n     * Bringt die Figur in die hinterste Ebene.\n     */\n    void GanzNachHintenBringen ()\n    {\n        symbol.GanzNachHintenBringen();\n    }\n\n    /**\n     * Setzt die Figur wieder an ihre Ausgangsposition.\n     */\n    void ZumStartpunktGehen()\n    {\n        symbol.ZumStartpunktGehen();\n        x = symbol.x;\n        y = symbol.y;\n        winkel = symbol.winkel;\n    }\n\n    /**\n     * Bewegt die Figur nach vorne.\n     * @param länge Anzahl der Längeneinheiten\n     */\n    void Gehen(double länge)\n    {\n        symbol.Gehen(länge);\n        x = symbol.x;\n        y = symbol.y;\n    }\n    \n    /**\n     * Dreht die Figur\n     * @param grad Drehwinkel (mathematisch positiver Drehsinn) im Gradmaß\n     */\n    void Drehen(int grad)\n    {\n        symbol.Drehen(grad);\n        winkel = symbol.winkel;\n    }\n\n    /**\n     * Gibt den aktuellen Winkel der Figur zurück.\n     * Die Winkelangabe ist in Grad, positive Werte drehen gegen den Uhrzeigersinn,\n     * negative Werte drehen im Uhrzeigersinn (mathematisch positiver Drehsinn), d. h.\n     * 0˚: Figur schaut nach rechts,\n     * 90˚: Figur schaut nach oben,\n     * 180˚: Figur schaut nach links,\n     * 270˚bzw. -90˚: Figur schaut nach unten\n     * @return Winkel im Gradmaß\n     */\n    int WinkelGeben()\n    {\n        return winkel;\n    }\n\n    /**\n     * Gibt die x-Koordinate der Figur zurück.\n     * @return x-Koordinate\n     */\n    int XPositionGeben()\n    {\n        return x;\n    }\n    \n    /**\n     * Gibt die y-Koordinate der Figur zurück.\n     * @return y-Koordinate\n     */ \n    int YPositionGeben()\n    {\n        return y;\n    }\n    \n    /**\n     * Testet, ob die Figur eine Grafik-Figur berührt.\n     * @return true, wenn die Figur und eine Grafikfigur überlappen\n     */\n    boolean Berührt ()\n    {\n        return symbol.Berührt();\n    }\n    \n    /**\n     * Testet, ob die Figur eine Grafik-Figur in der angegebenen Farbe berührt.\n     * @param farbe die Farbe, die die berührte Figur haben muss\n     * @return true, wenn die Figur und eine Grafikfigur in der angegebenen Farbe überlappen\n     */\n    boolean Berührt (String farbe)\n    {\n        return symbol.Berührt(farbe);\n    }\n\n    /**\n     * Testet, ob die Figur die angegebene Figur berührt.\n     * @param objekt das Objekt, das getestet werden soll\n     * @return true, wenn die Figur die angegebene Grafikfigur überlappen\n     */\n    boolean Berührt (Object objekt)\n    {\n        return symbol.Berührt(objekt);\n    }\n\n    /**\n     * Erzeugt ein neues, rechteckiges Element einer eigenen Darstellung der Figur.\n     * Alle Werte beziehen sich auf eine Figur der Größe 100x100 und den Koordinaten (0|0) in der Mitte des Quadrats\n     * @param x x-Wert der linken oberen Ecke des Rechtecks\n     * @param y y-Wert der linken oberen Ecke des Rechtecks\n     * @param breite Breite des Rechtecks\n     * @param höhe Höhe des Rechtecks\n     * @param farbe (Füll-)Farbe des Rechtecks\n     */\n    void FigurteilFestlegenRechteck (int x, int y, int breite, int höhe, String farbe)\n    {\n        symbol.FigurteilFestlegenRechteck(x, y, breite, höhe, farbe);\n    }\n\n    /**\n     * Erzeugt ein neues, elliptisches Element einer eigenen Darstellung der Figur.\n     * Alle Werte beziehen sich auf eine Figur der Größe 100x100 und den Koordinaten (0|0) in der Mitte des Quadrats\n     * @param x x-Wert der linken oberen Ecke des umgebenden Rechtecks der Ellipse\n     * @param y y-Wert der linken oberen Ecke des umgebenden Rechtecks der Ellipse\n     * @param breite Breite des umgebenden Rechtecks der Ellipse\n     * @param höhe Höhe des umgebenden Rechtecks der Ellipse\n     * @param farbe (Füll-)Farbe der Ellipse\n     */\n    void FigurteilFestlegenEllipse (int x, int y, int breite, int höhe, String farbe)\n    {\n        symbol.FigurteilFestlegenEllipse(x, y, breite, höhe, farbe);\n    }\n\n    /**\n     * Erzeugt ein neues, dreieckiges Element einer eigenen Darstellung der Figur.\n     * Alle Werte beziehen sich auf eine Figur der Größe 100x100 und den Koordinaten (0|0) in der Mitte des Quadrats\n     * @param x1 x-Wert des ersten Punkts des Dreiecks\n     * @param y1 y-Wert des ersten Punkts des Dreiecks\n     * @param x2 x-Wert des zweiten Punkts des Dreiecks\n     * @param y2 y-Wert des zweiten Punkts des Dreiecks\n     * @param x3 x-Wert des dritten Punkts des Dreiecks\n     * @param y3 y-Wert des dritten Punkts des Dreiecks\n     * @param farbe (Füll)Farbe des Dreiecks\n     */\n    void FigurteilFestlegenDreieck (int x1, int y1, int x2, int y2, int x3, int y3, String farbe)\n    {\n        symbol.FigurteilFestlegenDreieck(x1, y1, x2, y2, x3, y3, farbe);\n    }\n        \n    /**\n     * Löscht die Vereinbarung für die eigene Darstellung der Figur.\n     * Die Figur wird wieder durch die Originalfigur dargestellt.\n     */\n    void EigeneFigurLöschen()\n    {\n        symbol.EigeneFigurLöschen();\n    }\n}\n","position":{"x":372.2109123192114,"y":199.04442994854628}},{"name":"Kreis","content":"\n/**\n * Wrapperklasse für einen Kreis auf der Zeichenfläche.\n * \n * @author Albert Wiedemann \n * @version 1.0\n */\npublic class Kreis\n{\n    /** x-Position des Kreismittelpunktes. */\n    protected int x;\n    /** y-Position des Kreismittelpunktes. */\n    protected int y;\n    /** Radius des Kreises. */\n    protected int radius;\n    /** Farbe des Kreises. */\n    protected String farbe;\n    /** Sichtbarkeit des Kreises. */\n    protected boolean sichtbar;\n    /** Drehwinkel (mathematisch positiver Drehsinn) des Kreises in Grad. */\n    protected int winkel;\n    /** Referenz auf das Delegate-Objekt. */\n    Zeichenfenster.GrafikSymbol symbol;\n\n    /**\n     * Der Konstruktor erzeugt das Delegate-Objekt\n     */\n    Kreis ()\n    {\n        x = 60;\n        y = 60;\n        radius = 50;\n        farbe = \"rot\";\n        sichtbar = true;\n        winkel = 0;\n        symbol = Zeichenfenster.SymbolErzeugen(Zeichenfenster.SymbolArt.kreis);\n        symbol.PositionSetzen(x - radius, y - radius);\n        symbol.GrößeSetzen(radius * 2, radius * 2);\n        symbol.FarbeSetzen(farbe);\n        symbol.SichtbarkeitSetzen(sichtbar);\n        symbol.WinkelSetzen(winkel);\n    }\n    \n    /**\n     * Setzt die Position (des Mittelpunkts) des Kreises.\n     * @param x x-Position des Mittelpunkts\n     * @param y y-Position des Mittelpunkts\n     */\n    void PositionSetzen(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n        symbol.PositionSetzen(x - radius, y - radius);\n    }\n    \n    /**\n     * Verschiebt den Kreis um die angegebenen Werte.\n     * @param deltaX Verschiebung in x-Richtung\n     * @param deltaY Verschiebung in y-Richtung\n     */\n    void Verschieben(int deltaX, int deltaY)\n    {\n        x += deltaX;\n        y += deltaY;\n        symbol.PositionSetzen(x - radius, y - radius);\n    }\n    \n    /**\n     * Dreht den Kreis\n     * @param grad Drehwinkel (mathematisch positiver Drehsinn) im Gradmass\n     */\n    void Drehen(int grad)\n    {\n        winkel += grad;\n        symbol.WinkelSetzen(winkel);\n    }\n        \n    /**\n     * Setzt den Radius des Kreises.\n     * @param radius (neuer) Radius\n     */\n    void RadiusSetzen (int radius)\n    {\n        this.radius = radius;\n        symbol.GrößeSetzen(radius * 2, radius * 2);\n        symbol.PositionSetzen(x - radius, y - radius);\n    }\n    \n    /**\n     * Setzt die Farbe des Kreises.\n     * Erlaubte Farben sind:\n     * \"weiß\", \"weiss\", \"rot\", \"grün\", \"gruen\", \"blau\", \"gelb\",\n     * \"magenta\", \"cyan\", \"hellgelb\", \"hellgrün\", \"hellgruen\",\n     * \"orange\", \"braun\", \"grau\", \"schwarz\"\n     * Alle anderen Eingaben werden auf die Farbe schwarz abgebildet.\n     * @param farbe (neue) Farbe\n     */\n    void FarbeSetzen (String farbe)\n    {\n        this.farbe = farbe;\n        symbol.FarbeSetzen(farbe);\n    }\n        \n    /**\n     * Setzt den Drehwinkel des Kreises.\n     * Die Winkelangabe ist in Grad,positive Werte drehen gegen den Uhrzeigersinn,\n     * negative Werte drehen im Uhrzeigersinn (mathematisch positiver Drehsinn).\n     * @param winkel der (neue) Drehwinkel des Kreises\n     */\n    void WinkelSetzen (int winkel)\n    {\n        this.winkel = winkel;\n        symbol.WinkelSetzen(winkel);\n    }\n    \n    /**\n     * Schaltet die Sichtbarkeit des Kreises ein oder aus.\n     * Erlaubte Parameterwerte: true, false\n     * @param sichtbar (neue) Sichtbarkeit des Kreises\n     */\n    void SichtbarkeitSetzen (boolean sichtbar)\n    {\n        this.sichtbar = sichtbar;\n        symbol.SichtbarkeitSetzen(sichtbar);\n    }\n        \n    /**\n     * Entfernt den Kreis aus dem Zeichenfenster.\n     */\n    void Entfernen ()\n    {\n        symbol.Entfernen();\n    }\n    \n    /**\n     * Bringt den Kreis eine Ebene nach vorn.\n     */\n    void NachVornBringen ()\n    {\n        symbol.NachVornBringen();\n    }\n    \n    /**\n     * Bringt den Kreis in die vorderste Ebene.\n     */\n    void GanzNachVornBringen ()\n    {\n        symbol.GanzNachVornBringen();\n    }\n    \n    /**\n     * Bringt den Kreis eine Ebene nach hinten.\n     */\n    void NachHintenBringen ()\n    {\n        symbol.NachHintenBringen();\n    }\n    \n    /**\n     * Bringt den Kreis in die hinterste Ebene.\n     */\n    void GanzNachHintenBringen ()\n    {\n        symbol.GanzNachHintenBringen();\n    }\n}\n","position":{"x":372.13876851598445,"y":67.01173358900644}},{"name":"Rechteck","content":"\n/**\n * Wrapperklasse für ein Rechteck auf der Zeichenfläche.\n * \n * @author Albert Wiedemann \n * @version 1.0\n */\npublic class Rechteck\n{\n    /** x-Position der linken oberen Ecke. */\n    protected int x;\n    /** y-Position der linken oberen Ecke. */\n    protected int y;\n    /** Breite des Rechtecks. */\n    protected int breite;\n    /** Höhe des Rechtecks. */\n    protected int höhe;\n    /** Farbe des Rechtecks. */\n    protected String farbe;\n    /** Sichtbarkeit des Rechtecks. */\n    protected boolean sichtbar;\n    /** Drehwinkel (mathematisch positiver Drehsinn) des Rechtecks in Grad. */\n    protected int winkel;\n    /** Referenz auf das Delegate-Objekt. */\n    Zeichenfenster.GrafikSymbol symbol;\n\n    /**\n     * Der Konstruktor erzeugt das Delegate-Objekt\n     */\n    Rechteck ()\n    {\n        x = 10;\n        y = 10;\n        breite = 100;\n        höhe = 100;\n        farbe = \"rot\";\n        sichtbar = true;\n        winkel = 0;\n        symbol = Zeichenfenster.SymbolErzeugen(Zeichenfenster.SymbolArt.rechteck);\n        symbol.PositionSetzen(x, y);\n        symbol.GrößeSetzen(breite, höhe);\n        symbol.FarbeSetzen(farbe);\n        symbol.SichtbarkeitSetzen(sichtbar);\n        symbol.WinkelSetzen(winkel);\n    }\n    \n    /**\n     * Setzt die Position (der linken oberen Ecke) des Rechtecks.\n     * @param x x-Position der linken oberen Ecke\n     * @param y y-Position der linken oberen Ecke\n     */\n    void PositionSetzen(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n        symbol.PositionSetzen(x, y);\n    }\n    \n    /**\n     * Verschiebt das Rechteck um die angegebenen Werte.\n     * @param deltaX Verschiebung in x-Richtung\n     * @param deltaY Verschiebung in y-Richtung\n     */\n    void Verschieben(int deltaX, int deltaY)\n    {\n        x += deltaX;\n        y += deltaY;\n        symbol.PositionSetzen(x, y);\n    }\n    \n    /**\n     * Dreht das Rechteck\n     * @param grad Drehwinkel (mathematisch positiver Drehsinn) im Gradmass\n     */\n    void Drehen(int grad)\n    {\n        winkel += grad;\n        symbol.WinkelSetzen(winkel);\n    }\n        \n    /**\n     * Setzt die Größe des Rechtecks.\n     * @param breite (neue) Breite\n     * @param höhe (neue) Höhe\n     */\n    void GrößeSetzen (int breite, int höhe)\n    {\n        this.breite = breite;\n        this.höhe = höhe;\n        symbol.GrößeSetzen(breite, höhe);\n    }\n    \n    /**\n     * Setzt die Farbe des Rechtecks.\n     * Erlaubte Farben sind:\n     * \"weiß\", \"weiss\", \"rot\", \"grün\", \"gruen\", \"blau\", \"gelb\",\n     * \"magenta\", \"cyan\", \"hellgelb\", \"hellgrün\", \"hellgruen\",\n     * \"orange\", \"braun\", \"grau\", \"schwarz\"\n     * Alle anderen Eingaben werden auf die Farbe schwarz abgebildet.\n     * @param farbe (neue) Farbe\n     */\n    void FarbeSetzen (String farbe)\n    {\n        this.farbe = farbe;\n        symbol.FarbeSetzen(farbe);\n    }\n        \n    /**\n     * Setzt den Drehwinkel des Rechtecks.\n     * Die Winkelangabe ist in Grad,positive Werte drehen gegen den Uhrzeigersinn,\n     * negative Werte drehen im Uhrzeigersinn (mathematisch positiver Drehsinn).\n     * @param winkel der (neue) Drehwinkel des Rechtecks\n     */\n    void WinkelSetzen (int winkel)\n    {\n        this.winkel = winkel;\n        symbol.WinkelSetzen(winkel);\n    }\n    \n    /**\n     * Schaltet die Sichtbarkeit des Rechtecks ein oder aus.\n     * Erlaubte Parameterwerte: true, false\n     * @param sichtbar (neue) Sichtbarkeit des Rechtecks\n     */\n    void SichtbarkeitSetzen (boolean sichtbar)\n    {\n        this.sichtbar = sichtbar;\n        symbol.SichtbarkeitSetzen(sichtbar);\n    }\n        \n    /**\n     * Entfernt das Rechteck aus dem Zeichenfenster.\n     */\n    void Entfernen ()\n    {\n        symbol.Entfernen();\n    }\n    \n    /**\n     * Bringt das Rechteck eine Ebene nach vorn.\n     */\n    void NachVornBringen ()\n    {\n        symbol.NachVornBringen();\n    }\n    \n    /**\n     * Bringt das Rechteck in die vorderste Ebene.\n     */\n    void GanzNachVornBringen ()\n    {\n        symbol.GanzNachVornBringen();\n    }\n    \n    /**\n     * Bringt das Rechteck eine Ebene nach hinten.\n     */\n    void NachHintenBringen ()\n    {\n        symbol.NachHintenBringen();\n    }\n    \n    /**\n     * Bringt das Rechteck in die hinterste Ebene.\n     */\n    void GanzNachHintenBringen ()\n    {\n        symbol.GanzNachHintenBringen();\n    }\n}\n","position":{"x":90.75638832832544,"y":67.66020289850712}},{"name":"Text","content":"\n/**\n * Wrapperklasse für einen Text auf der Zeichenfläche.\n * \n * @author Albert Wiedemann \n * @version 1.0\n */\npublic class Text\n{\n    /** x-Position der linken Seite der Grundlinie. */\n    private int x;\n    /** y-Position der Grundlinie. */\n    private int y;\n    /** Farbe des Textes. */\n    private String farbe;\n    /** Sichtbarkeit des Textes. */\n    private boolean sichtbar;\n    /** Drehwinkel (mathematisch positiver Drehsinn) des Textes in Grad. */\n    private int winkel;\n    /** Größe des Textes in Punkten. */\n    private int textgröße;\n    \n    /** Referenz auf das Delegate-Objekt. */\n    private Zeichenfenster.TextIntern symbol;\n\n    /**\n     * Der Konstruktor erzeugt das Delegate-Objekt\n     */\n    Text ()\n    {\n        x = 10;\n        y = 10;\n        farbe = \"schwarz\";\n        sichtbar = true;\n        winkel = 0;\n        textgröße = 12;\n        symbol = (Zeichenfenster.TextIntern) Zeichenfenster.SymbolErzeugen(Zeichenfenster.SymbolArt.text);\n        symbol.PositionSetzen(x, y);\n        symbol.FarbeSetzen(farbe);\n        symbol.SichtbarkeitSetzen(sichtbar);\n        symbol.WinkelSetzen(winkel);\n        symbol.TextGrößeSetzen(textgröße);\n    }\n    \n    /**\n     * Setzt die Position (der Grundline) des Textes.\n     * @param x x-Position der linken Seite der Grundlinie\n     * @param y y-Position der Grundlinie\n     */\n    void PositionSetzen(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n        symbol.PositionSetzen(x, y);\n    }\n        \n    /**\n     * Setzt den aktuellen Text.\n     * @param text der neue Text\n     */\n    void TextSetzen (String text)\n    {\n        symbol.TextSetzen(text);\n    }\n    \n    /**\n     * Setzt die Größe des Textes.\n     * @param größe die (neue) Textgröße\n     */\n    void TextGrößeSetzen (int größe)\n    {\n        textgröße = größe;\n        symbol.TextGrößeSetzen(größe);\n    }\n    \n    /**\n     * Vergrößert den Text.\n     */\n    void TextVergrößern()\n    {\n        symbol.TextVergrößern();\n        textgröße = (int) symbol.size;\n    }\n    \n    /**\n     * Verkleinert den Text.\n     */\n    void TextVerkleinern()\n    {\n        symbol.TextVerkleinern();\n        textgröße = (int) symbol.size;\n    }\n    \n    /**\n     * Verschiebt den Text um die angegebenen Werte.\n     * @param deltaX Verschiebung in x-Richtung\n     * @param deltaY Verschiebung in y-Richtung\n     */\n    void Verschieben(int deltaX, int deltaY)\n    {\n        x += deltaX;\n        y += deltaY;\n        symbol.PositionSetzen(x, y);\n    }\n    \n    /**\n     * Dreht den Text\n     * @param grad Drehwinkel (mathematisch positiver Drehsinn) im Gradmass\n     */\n    void Drehen(int grad)\n    {\n        winkel += grad;\n        symbol.WinkelSetzen(winkel);\n    }\n    \n    /**\n     * Setzt die Farbe des Textes.\n     * Erlaubte Farben sind:\n     * \"weiß\", \"weiss\", \"rot\", \"grün\", \"gruen\", \"blau\", \"gelb\",\n     * \"magenta\", \"cyan\", \"hellgelb\", \"hellgrün\", \"hellgruen\",\n     * \"orange\", \"braun\", \"grau\", \"schwarz\"\n     * Alle anderen Eingaben werden auf die Farbe schwarz abgebildet.\n     * @param farbe (neue) Farbe\n     */\n    void FarbeSetzen (String farbe)\n    {\n        this.farbe = farbe;\n        symbol.FarbeSetzen(farbe);\n    }\n        \n    /**\n     * Setzt den Drehwinkel des Textes.\n     * Die Winkelangabe ist in Grad,positive Werte drehen gegen den Uhrzeigersinn,\n     * negative Werte drehen im Uhrzeigersinn (mathematisch positiver Drehsinn).\n     * @param winkel der (neue) Drehwinkel des Textes\n     */\n    void WinkelSetzen (int winkel)\n    {\n        this.winkel = winkel;\n        symbol.WinkelSetzen(winkel);\n    }\n    \n    /**\n     * Schaltet die Sichtbarkeit des Textes ein oder aus.\n     * Erlaubte Parameterwerte: true, false\n     * @param sichtbar (neue) Sichtbarkeit des Textes\n     */\n    void SichtbarkeitSetzen (boolean sichtbar)\n    {\n        this.sichtbar = sichtbar;\n        symbol.SichtbarkeitSetzen(sichtbar);\n    }\n        \n    /**\n     * Entfernt den Text aus dem Zeichenfenster.\n     */\n    void Entfernen ()\n    {\n        symbol.Entfernen();\n    }\n    \n    /**\n     * Bringt den Text eine Ebene nach vorn.\n     */\n    void NachVornBringen ()\n    {\n        symbol.NachVornBringen();\n    }\n    \n    /**\n     * Bringt den Text in die vorderste Ebene.\n     */\n    void GanzNachVornBringen ()\n    {\n        symbol.GanzNachVornBringen();\n    }\n    \n    /**\n     * Bringt den Text eine Ebene nach hinten.\n     */\n    void NachHintenBringen ()\n    {\n        symbol.NachHintenBringen();\n    }\n    \n    /**\n     * Bringt den Text in die hinterste Ebene.\n     */\n    void GanzNachHintenBringen ()\n    {\n        symbol.GanzNachHintenBringen();\n    }\n}\n","position":{"x":514.4465583892674,"y":67.79949843710477}},{"name":"Turtle","content":"\n/**\n * Wrapperklasse für die Turtle auf der Zeichenfläche.\n * \n * @author Albert Wiedemann \n * @version 1.0\n */\npublic class Turtle\n{\n    /** x-Position der Turtle. */\n    private int x;\n    /** y-Position der Turtle. */\n    private int y;\n    /** Größe der Turtle. */\n    private int größe;\n    /** Farbe der Turtle. */\n    private String farbe;\n    /** Sichtbarkeit der Turtles. */\n    private boolean sichtbar;\n    /** Drehwinkel (mathemtisch positiver Drehsinn) der Turtle in Grad. */\n    private int winkel;\n    /**Stiftposition*/\n    private boolean stiftUnten;\n    /** Referenz auf das echte Turtlesybol. */\n    Zeichenfenster.TurtleIntern symbol;\n    /** Referenz auf das Aktionsempfängerobjekt. */\n    Zeichenfenster.AktionsEmpfaenger aktionsEmpfänger;\n    \n    /**\n     * Konstruktor der Turtle\n     * Erzeugt eine Turtle und versetzt sie in einen gültigen Startzustand.\n     */\n    Turtle ()\n    {\n        symbol = (Zeichenfenster.TurtleIntern) Zeichenfenster.SymbolErzeugen(Zeichenfenster.SymbolArt.turtle);\n        symbol.SichtbarkeitSetzen(true);\n        x = symbol.x;\n        y = symbol.y;\n        winkel = symbol.winkel;\n        größe = symbol.b;\n        stiftUnten = symbol.stiftUnten;\n        sichtbar = symbol.sichtbar;\n        aktionsEmpfänger = new Zeichenfenster.AktionsEmpfaenger()\n        {\n            public void Ausführen ()\n            {\n                AktionAusführen();\n            }\n            \n            public void Taste (char taste)\n            {\n                TasteGedrückt(taste);\n            }\n            \n            public void SonderTaste (int taste)\n            {\n                SonderTasteGedrückt(taste);\n            }\n            \n            public void Geklickt (int x, int y, int anzahl)\n            {\n                MausGeklickt(x, y, anzahl);\n            }\n        };\n        Zeichenfenster.AktionsEmpfängerEintragen(aktionsEmpfänger);\n    }\n    \n    /**\n     * Methode wird aufgerufen, wenn die Turtle handeln soll.\n     * Die vordefinierte Methode tut nichts.\n     */\n    void AktionAusführen()\n    {\n    }\n    \n    /**\n     * Die eigentliche Aktionsmethode für gedrückte Tasten.\n     * <br>Muss bei Bedarf von einer Unterklasse überschrieben werden. \n     * @param taste die gedrückte Taste\n     */\n    void TasteGedrückt (char taste)\n    {\n        //System. out. println (\"Taste: \" + taste);\n    }\n    \n    /**\n     * Die eigentliche Aktionsmethode für gedrückte Sondertasten.\n     * <br>Muss bei Bedarf von einer Unterklasse überschrieben werden. \n     * @param taste KeyCode der gedrückten Taste\n     */\n    void SonderTasteGedrückt (int taste)\n    {\n        //System. out. println (\"Sondertaste: \" + taste);\n    }\n    \n    /**\n     * Die eigentliche Aktionsmethode für einen Mausklick.\n     * <br>Muss bei Bedarf von einer Unterklasse überschrieben werden. \n     * @param x x-Position des Mausklicks\n     * @param y y-Position des Mausklicks\n     * @param anzahl Anzahl der aufeinanderfolgenden Mausklicks\n     */\n    void MausGeklickt (int x, int y, int anzahl)\n    {\n        System. out. println (\"Maus: (\" + x + \"|\" + y + \"), \" + anzahl + \" mal\");\n    }\n    \n    /**\n     * Setzt die Position der Turtle.\n     * @param x x-Position der Turtle\n     * @param y y-Position der Turtle\n     */\n    void PositionSetzen(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n        symbol.PositionSetzen(x, y);\n    }\n        \n    /**\n     * Setzt die Größe des Turtlesymbols.\n     * @param größe (neue) Größe\n     */\n    void GrößeSetzen (int größe)\n    {\n        this.größe = größe;\n        symbol.GrößeSetzen(größe, größe);\n    }\n    \n    /**\n     * Setzt die Farbe der Linie.\n     * Erlaubte Farben sind:\n     * \"weiß\", \"weiss\", \"rot\", \"grün\", \"gruen\", \"blau\", \"gelb\",\n     * \"magenta\", \"cyan\", \"hellgelb\", \"hellgrün\", \"hellgruen\",\n     * \"orange\", \"braun\", \"grau\", \"schwarz\"\n     * Alle anderen Eingaben werden auf die Farbe schwarz abgebildet.\n     * @param farbe (neue) Farbe\n     */\n    void FarbeSetzen (String farbe)\n    {\n        this.farbe = farbe;\n        symbol.FarbeSetzen(farbe);\n    }\n        \n    /**\n     * Setzt den Drehwinkel der Turtle.\n     * Die Winkelangabe ist in Grad, positive Werte drehen gegen den Uhrzeigersinn,\n     * negative Werte drehen im Uhrzeigersinn (mathematisch positiver Drehsinn), d. h.\n     * 0˚: Turtle schaut nach rechts,\n     * 90˚: Turtle schaut nach oben,\n     * 180˚: Turtle schaut nach links,\n     * 270˚bzw. -90˚: Turtle schaut nach unten\n     * @param winkel der (neue) Drehwinkel der Turtle\n     */\n    void WinkelSetzen (int winkel)\n    {\n        this.winkel = winkel;\n        symbol.WinkelSetzen(winkel);\n    }\n    \n    /**\n     * Schaltet die Sichtbarkeit der Turtle ein oder aus.\n     * Erlaubte Parameterwerte: true, false\n     * @param sichtbar (neue) Sichtbarkeit der Turtle\n     */\n    void SichtbarkeitSetzen (boolean sichtbar)\n    {\n        this.sichtbar = sichtbar;\n        symbol.SichtbarkeitSetzen(sichtbar);\n    }\n        \n    /**\n     * Entfernt die Turtle aus dem Zeichenfenster.\n     */\n    void Entfernen ()\n    {\n        Zeichenfenster.AktionsEmpfängerEntfernen(aktionsEmpfänger);\n        symbol.Entfernen();\n    }\n    \n    /**\n     * Bringt die Turtle eine Ebene nach vorn.\n     */\n    void NachVornBringen ()\n    {\n        symbol.NachVornBringen();\n    }\n    \n    /**\n     * Bringt die Turtle in die vorderste Ebene.\n     */\n    void GanzNachVornBringen ()\n    {\n        symbol.GanzNachVornBringen();\n    }\n    \n    /**\n     * Bringt die Turtle eine Ebene nach hinten.\n     */\n    void NachHintenBringen ()\n    {\n        symbol.NachHintenBringen();\n    }\n    \n    /**\n     * Bringt die Turtle in die hinterste Ebene.\n     */\n    void GanzNachHintenBringen ()\n    {\n        symbol.GanzNachHintenBringen();\n    }\n\n    /**\n     * Setzt die Turtle wieder an ihre Ausgangsposition.\n     */\n    void ZumStartpunktGehen()\n    {\n        symbol.ZumStartpunktGehen();\n        x = symbol.x;\n        y = symbol.y;\n        winkel = symbol.winkel;\n    }\n\n    /**\n     * Bewegt die Turtle nach vorne.\n     * @param länge Anzahl der Längeneinheiten\n     */\n    void Gehen(double länge)\n    {\n        symbol.Gehen(länge);\n        x = symbol.x;\n        y = symbol.y;\n    }\n    \n    /**\n     * Dreht die Turtle\n     * @param grad Drehwinkel (mathematisch positiver Drehsinn) im Gradmaß\n     */\n    void Drehen(int grad)\n    {\n        symbol.Drehen(grad);\n        winkel = symbol.winkel;\n    }\n\n    /**\n     * Versetzt Zeichenfläche und Turtle in den Ausgangszustand\n     */\n    void Löschen()\n    {\n        symbol.Löschen();\n    }\n\n    /**\n     * Turtle wechselt in den Modus \"nicht zeichnen\"\n     */\n    void StiftHeben()\n    {\n        symbol.StiftHeben();\n        stiftUnten = false;\n    }\n\n    /**\n     * Turtle wechselt in den Modus \"zeichnen\"\n     */\n    void StiftSenken()\n    {\n        symbol.StiftSenken();\n        stiftUnten = true;\n    }\n\n    /**\n     * Gibt den aktuellen Winkel der Turtle zurück.\n     * Die Winkelangabe ist in Grad, positive Werte drehen gegen den Uhrzeigersinn,\n     * negative Werte drehen im Uhrzeigersinn (mathematisch positiver Drehsinn), d. h.\n     * 0˚: Turtle schaut nach rechts,\n     * 90˚: Turtle schaut nach oben,\n     * 180˚: Turtle schaut nach links,\n     * 270˚bzw. -90˚: Turtle schaut nach unten\n     * @return Winkel im Gradmass\n     */\n    int WinkelGeben()\n    {\n        return winkel;\n    }\n\n    /**\n     * Gibt die x-Koordinate der Turtle zurück\n     * @return x-Koordinate\n     */\n    int XPositionGeben()\n    {\n        return x;\n    }\n    \n    /**\n     * Gibt die y-Koordinate der Turtle zurück\n     * @return y-Koordinate\n     */ \n    int YPositionGeben()\n    {\n        return y;\n    }\n    \n    /**\n     * Schaltet die Sichtbarkeit des Turtlesymbols ein oder aus.\n     * Erlaubte Parameterwerte: true, false\n     * @param sichtbar (neue) Sichtbarkeit des Turtlesymbols\n     */\n    void SichtbarkeitFürSymbolSetzen (boolean sichtbar)\n    {\n        symbol.SichtbarkeitFürSymbolSetzen(sichtbar);\n    }\n    \n    /**\n     * Testet, ob die Turtle eine Figur  berührt.\n     * @return true, wenn die Turtlekoordinaten innerhalb einer Grafikfigur sind\n     */\n    boolean Berührt ()\n    {\n        return symbol.Berührt();\n    }\n    \n    /**\n     * Testet, ob die Turtle eine Figur in der angegebenen Farbe berührt.\n     * @param farbe die Farbe, die die berührte Figur haben muss.\n     * @return true, wenn die Turtlekoordinaten innerhalb einer Grafikfigur in der angegebenen Farbe sind\n     */\n    boolean Berührt (String farbe)\n    {\n        return symbol.Berührt(farbe);\n    }\n\n    /**\n     * Testet, ob die Turtle die angegebene Figur berührt.\n     * @param objekt das Objekt, das getestet werden soll.\n     * @return true, wenn die Turtlekoordinaten innerhalb der angegebenen Grafikfigur sind\n     */\n    boolean Berührt (Object objekt)\n    {\n        return symbol.Berührt(objekt);\n    }\n}\n","position":{"x":231.09838992005717,"y":198.24321860417223}}]}