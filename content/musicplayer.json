{"title":"Musicplayer","summary":"BlueJ Chapter 13","description":"`new MusicPlayerGUI()`","lastUpdated":1728769206029,"output":"display","classes":[{"name":"MusicFilePlayer","content":"/**\n * 11/19/04     1.0 moved to LGPL. \n *-----------------------------------------------------------------------\n *   This program is free software; you can redistribute it and/or modify\n *   it under the terms of the GNU Library General Public License as published\n *   by the Free Software Foundation; either version 2 of the License, or\n *   (at your option) any later version.\n *\n *   This program is distributed in the hope that it will be useful,\n *   but WITHOUT ANY WARRANTY; without even the implied warranty of\n *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *   GNU Library General Public License for more details.\n *\n *   You should have received a copy of the GNU Library General Public\n *   License along with this program; if not, write to the Free Software\n *   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n *----------------------------------------------------------------------\n */\n\nimport java.io.BufferedInputStream;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\n\nimport javazoom.jl.decoder.Bitstream;\nimport javazoom.jl.decoder.BitstreamException;\nimport javazoom.jl.decoder.Decoder;\nimport javazoom.jl.decoder.Header;\nimport javazoom.jl.decoder.JavaLayerException;\nimport javazoom.jl.decoder.SampleBuffer;\nimport javazoom.jl.player.AudioDevice;\nimport javazoom.jl.player.FactoryRegistry;\n\n/**\n * Play music files.\n * This class is a modified version of javazoom.jl.player.advanced.AdvancedPlayer,\n * which is part of the javazoom JLayer library.\n * The main modifications consist of:\n *     + Restriction to playing files rather than streams.\n *     + Pre-reading of the audio file to determine its length in frames.\n * These modifications permit arbitrary seek operations.\n * \n * Modifications by David J. Barnes and Michael Kölling.\n * @version 2016.02.29\n * This class is not suitable for playing streams as a file is read\n * completely before playing.\n */\npublic class MusicFilePlayer\n{\n    // The MPEG audio bitstream.\n    private Bitstream bitstream;\n    // The MPEG audio decoder.\n    private Decoder decoder;\n    // The AudioDevice the audio samples are written to.\n    private AudioDevice audio;\n    // Whether currently playing.\n    private volatile boolean playing = false;\n    // The file being played.\n    private String filename;\n    \n    // The number of frames.\n    private int frameCount;\n    // The current frame number.\n    private int frameNumber;\n    // The position to resume, if any.\n    private int resumePosition;\n\n    /**\n     * Creates a new MusicFilePlayer instance.\n     * @param filename The file to be played.\n     */\n    public MusicFilePlayer(String filename) throws JavaLayerException\n    {\n        this.filename = filename;\n                \n        openAudio();\n \n        frameCount = getFrameCount(filename);\n        \n        // Open a fresh bitstream following the frame count.\n        openBitstream(filename);\n        \n        frameNumber = 0;\n        resumePosition = -1;  \n\n    }\n\n    /**\n     * Play the whole file.\n     */\n    public void play() throws JavaLayerException\n    {\n        playFrames(0, frameCount);\n    }\n\n    /**\n     * Plays a number of MPEG audio frames.\n     *\n     * @param frames    The number of frames to play.\n     * @return  true if the last frame was played, or false if there are\n     *          more frames.\n     */\n    public boolean play(int frames) throws JavaLayerException\n    {\n        return playFrames(frameNumber, frameNumber + frames);\n\n    }\n\n    /**\n     * Plays a range of MPEG audio frames\n     * @param start The first frame to play\n     * @param end       The last frame to play\n     * @return true if the last frame was played, or false if there are more frames.\n     */\n    public boolean play(int start, int end) throws JavaLayerException\n    {\n        return playFrames(start, start + end);\n    }\n    \n    /**\n     * Play from the given position to the end.\n     * @param start The first frame to play.\n     * @return true if the last frame was played, or false if there are more frames.\n     */\n    public boolean playFrom(int start) throws JavaLayerException\n    {\n        return playFrames(start, frameCount);\n    }\n    \n    /**\n     * Get the length of the file (in frames).\n     * @return The file length, in frames.\n     */\n    public int getLength()\n    {\n        return frameCount;\n    }\n    \n    /**\n     * Get the current playing position (in frames).\n     * @return The current frame number.\n     */\n    public int getPosition()\n    {\n        return frameNumber;\n    }\n    \n    /**\n     * Set the playing position (in frames).\n     * Playing does not start until resume() is called.\n     * @param position The playing position.\n     */\n    public void setPosition(int position) throws JavaLayerException\n    {\n        pause();\n        resumePosition = position;\n    }\n    \n    \n    /**\n     * Pause the playing.\n     */\n    public void pause() throws JavaLayerException\n    {\n        System.out.println(\"attempt to pause\");\n        //synchronized(this) {\n            System.out.println(\"setting playing to false\");\n            playing = false;\n            resumePosition = frameNumber;\n        //}\n    }\n    \n    /**\n     * Resume the playing.\n     */\n    public void resume() throws JavaLayerException\n    {\n        if(!playing) {\n            int start;\n            if(resumePosition >= 0) {\n                start = resumePosition;\n            }\n            else {\n                start = frameNumber;\n            }\n            resumePosition = -1;\n            playFrames(start, frameCount);\n        }\n    }\n    \n    /**\n     * Return the current frame number.\n     * @return The number of the last frame played, or -1 if nothing played yet.\n     */\n    public int getFrameNumber()\n    {\n        return frameNumber;\n    }\n    \n    /**\n     * Play the number of frames left.\n     * @return true If finished for any reason, false if paused.\n     */\n    private boolean playFrames(int start, int end) throws JavaLayerException\n    {\n        // Clear any resumption position.\n        resumePosition = -1;\n        \n        if(end > frameCount) {\n            end = frameCount;\n        }\n        \n        // Make sure the player is in the correct position in the input.\n        synchronized(this) {\n            moveTo(start);\n            playing = true;\n        }\n\n        // Play until finished, paused, or a problem.\n        boolean ok = true;\n        while (frameNumber < end && playing && ok) {\n            System.out.println(\"playing frame \" + frameNumber + \", is playing:\" + playing);\n            ok = decodeFrame();\n            if(ok) {\n                frameNumber++;\n            }                    \n        }\n\n        // Stopped for some reason.\n        synchronized(this) {\n            playing = false;\n            // last frame, ensure all data flushed to the audio device.\n            AudioDevice out = audio;\n            if (out != null) {\n                out.flush();\n            }\n        }\n        return ok;\n    }\n    \n    /**\n     * Set the playing position.\n     * @param position (in frames)\n     */\n    private void moveTo(int position) throws JavaLayerException\n    {\n        if(position < frameNumber) {\n            synchronized(this) {\n                // Already played too far.\n                if(bitstream != null) {\n                    try {\n                        bitstream.close();\n                    }\n                    catch (BitstreamException ex) {\n                    }\n                }\n                if(audio != null) {\n                    audio.close();\n                }\n                openAudio();\n                openBitstream(filename);\n                frameNumber = 0;\n            }\n        }\n        \n        while(frameNumber < position) {\n            skipFrame();\n            frameNumber++;\n        }            \n    }\n\n    /**\n     * Cloases this player. Any audio currently playing is stopped\n     * immediately.\n     */\n    public void close()\n    {\n        synchronized(this) {\n            if (audio != null) {\n                AudioDevice out = audio;\n                audio = null;\n                // this may fail, so ensure object state is set up before\n                // calling this method.\n                out.close();\n                try {\n                    bitstream.close();\n                }\n                catch (BitstreamException ex) {\n                }\n                bitstream = null;\n                decoder = null;\n            }\n        }\n    }\n\n    /**\n     * Decodes a single frame.\n     *\n     * @return true if there are no more frames to decode, false otherwise.\n     */\n    protected boolean decodeFrame() throws JavaLayerException\n    {\n        try\n        {\n            synchronized (this) {\n                if (audio == null) {\n                    return false;\n                }\n    \n                Header h = readFrame();\n                if (h == null) {\n                    return false;\n                }\n    \n                // sample buffer set when decoder constructed\n                SampleBuffer output = (SampleBuffer) decoder.decodeFrame(h, bitstream);\n\n                if(audio != null) {\n                    audio.write(output.getBuffer(), 0, output.getBufferLength());\n                }\n            }\n\n            bitstream.closeFrame();\n        }\n        catch (RuntimeException ex) {\n            ex.printStackTrace();\n            throw new JavaLayerException(\"Exception decoding audio frame\", ex);\n        }\n        return true;\n    }\n\n\n    /**\n     * skips over a single frame\n     * @return false    if there are no more frames to decode, true otherwise.\n     */\n    protected boolean skipFrame() throws JavaLayerException\n    {\n        Header h = readFrame();\n        if (h == null) {\n            return false;\n        }\n        frameNumber++;\n        bitstream.closeFrame();\n        return true;\n    }\n\n    /**\n     * closes the player and notifies <code>PlaybackListener</code>\n     */\n    public void stop()\n    {\n        close();\n    }\n    \n    /**\n     * Count the number of frames in the file.\n     * This can be used for positioning.\n     * @param filename The file to be measured.\n     * @return The number of frames.\n     */\n    protected int getFrameCount(String filename) throws JavaLayerException\n    {\n        openBitstream(filename);\n        int count = 0;\n        while(skipFrame()) {\n            count++;\n        }\n        bitstream.close();\n        return count;        \n    }\n    \n    /**\n     * Read a frame.\n     * @return The frame read.\n     */\n    protected Header readFrame() throws JavaLayerException\n    {\n        if(audio != null) {\n            return bitstream.readFrame();\n        }\n        else {\n            return null;\n        }\n    }\n    \n    /**\n     * Open an audio device.\n     */\n    protected void openAudio() throws JavaLayerException\n    {\n        audio = FactoryRegistry.systemRegistry().createAudioDevice();\n        decoder = new Decoder();\n        audio.open(decoder);\n    }\n    \n    /**\n     * Open a BitStream for the given file.\n     * @param filename The file to be opened.\n     * @throws IOException If the file cannot be opened.\n     */\n    protected void openBitstream(String filename)\n        throws JavaLayerException\n    {\n        try {\n            bitstream = new Bitstream(new BufferedInputStream(\n                        new FileInputStream(filename)));\n        }\n        catch(java.io.IOException ex) {\n            throw new JavaLayerException(ex.getMessage(), ex);\n        }\n                    \n    }\n}\n\n\n\n","position":{"x":362.04033053364844,"y":-25.14087667569453}},{"name":"MusicOrganizer","content":"import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\n/**\n * A class to hold details of audio tracks.\n * Individual tracks may be played.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class MusicOrganizer\n{\n    // An ArrayList for storing music tracks.\n    private ArrayList<Track> tracks;\n    // A reader that can read music files and load them as tracks.\n    private TrackReader reader;\n\n    /**\n     * Create a MusicOrganizer.\n     * @param folderName The folder of audio files.\n     */\n    public MusicOrganizer(String folderName)\n    {\n        tracks = new ArrayList<>();\n        reader = new TrackReader();\n        readLibrary(folderName);\n    }\n    \n    /**\n     * Add a track file to the collection.\n     * @param filename The file name of the track to be added.\n     */\n    public void addFile(String filename)\n    {\n        tracks.add(new Track(filename));\n    }\n    \n    /**\n     * Add a track to the collection.\n     * @param track The track to be added.\n     */\n    public void addTrack(Track track)\n    {\n        tracks.add(track);\n    }\n    \n    /**\n     * Get a track from the collection.\n     * @param index The index of the track.\n     * @return The selected track, or null if it does not exist.\n     */\n    public Track getTrack(int index)\n    {\n        if(indexValid(index)) {\n            return tracks.get(index);\n        }\n        else {\n            return null;\n        }\n    }\n    \n    /**\n     * Return the number of tracks in the collection.\n     * @return The number of tracks in the collection.\n     */\n    public int getNumberOfTracks()\n    {\n        return tracks.size();\n    }\n    \n    /**\n     * Return a copy of all the tracks in the collection.\n     * @return All the tracks in the collection.\n     */\n    public List<Track> getAllTracks()\n    {\n        return new ArrayList<>(tracks);\n    }\n    \n    /**\n     * Return a list of the tracks, sorted by artist.\n     * @return The tracks, sorted by artist.\n     */\n    public List<Track> sortByArtist()\n    {\n        return sortByField(\"Artist\");\n    }\n    \n    /**\n     * Return a list of the tracks, sorted by title.\n     * @return The tracks, sorted by title.\n     */\n    public List<Track> sortByTitle()\n    {\n       return sortByField(\"Field\");\n    }\n    \n    /**\n     * Return a sorted copy of the track list.\n     * @param comparator The comparator for the sort.\n     * @return A sorted copy of the list.\n     */\n    private List<Track> sortBy(Comparator<Track> comparator)\n    {\n        List<Track> copy = getAllTracks();\n        Collections.sort(copy, comparator);\n        return copy;\n    }\n    \n    /**\n     * Return a list of the tracks, sorted by the given field name.\n     * @param field The field to sort by; e.g., Artist, Title, etc.\n     *              @see Track.FIELDS\n     * @return The tracks, sorted by the field.\n     */\n    public List<Track> sortByField(final String field)\n    {\n        return sortBy(new Comparator<Track>() {\n            public int compare(Track t1, Track t2)\n            {\n                return t1.getField(field).compareTo(t2.getField(field));\n            }\n        });\n    }\n    \n    /**\n     * Remove a track from the collection.\n     * @param index The index of the track to be removed.\n     */\n    public void removeTrack(int index)\n    {\n        if(indexValid(index)) {\n            tracks.remove(index);\n        }\n    }\n    \n    /**\n     * Determine whether the given index is valid for the collection.\n     * Print an error message if it is not.\n     * @param index The index to be checked.\n     * @return true if the index is valid, false otherwise.\n     */\n    private boolean indexValid(int index)\n    {\n        // The return value.\n        // Set according to whether the index is valid or not.\n        boolean valid;\n        \n        if(index < 0) {\n            System.out.println(\"Index cannot be negative: \" + index);\n            valid = false;\n        }\n        else if(index >= tracks.size()) {\n            System.out.println(\"Index is too large: \" + index);\n            valid = false;\n        }\n        else {\n            valid = true;\n        }\n        return valid;\n    }\n    \n    public void readLibrary(String folderName)\n    {\n        ArrayList<Track> tempTracks = reader.readTracks(folderName, \".mp3\");\n\n        // Put all thetracks into the organizer.\n        for(Track track : tempTracks) {\n            addTrack(track);\n        }\n    }\n}\n","position":{"x":267.69901611620804,"y":230.8671254113029}},{"name":"MusicPlayer","content":"import java.io.BufferedInputStream;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.IOException;\nimport javazoom.jl.decoder.JavaLayerException;\nimport javazoom.jl.player.AudioDevice;\nimport javazoom.jl.player.FactoryRegistry;\n\n/**\n * Provide basic playing of MP3 files via the javazoom library.\n * See http://www.javazoom.net/\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class MusicPlayer\n{\n    // The current player. It might be null.\n    private MusicFilePlayer player;\n    // The current file being played.\n    private String filename;\n    \n    /**\n     * Constructor for objects of class MusicPlayer\n     */\n    public MusicPlayer()\n    {\n        player = null;\n        filename = \"\";\n    }\n    \n    /**\n     * Start playing the given audio file.\n     * The method returns once the playing has been started.\n     * @param filename The file to be played.\n     */\n    public void startPlaying(final String filename)\n    {\n        try {\n            setupPlayer(filename);\n            playFrom(0);\n        }\n        catch (JavaLayerException ex) {\n            reportProblem();\n        }\n    }\n    \n    /**\n     * Stop playing the current file.\n     */\n    public void stop()\n    {\n        killPlayer();\n    }\n    \n    /**\n     * Pause the current file.\n     */\n    public void pause()\n    {\n        if(player != null) {\n            try {\n                player.pause();\n            }\n            catch(JavaLayerException e) {\n                reportProblem();\n                killPlayer();\n            }\n        }\n    }\n    \n    /**\n     * Resume playing following a pause.\n     */\n    public void resume()\n    {\n        if(player != null) {\n            Thread playerThread = new Thread() {\n                public void run()\n                {\n                    try {\n                        player.resume();\n                    }\n                    catch(JavaLayerException e) {\n                        reportProblem();\n                        killPlayer();\n                    }\n                }\n            };\n            playerThread.setPriority(Thread.MIN_PRIORITY);\n            playerThread.start();\n        }\n    }\n    \n    /**\n     * Seek to the given position in the current file.\n     * The track will be paused as a result of this operation.\n     * \n     * @param position What position in the file to move to.\n     */\n    public void seekTo(int position)\n    {\n        if(player != null && position >= 0 && position < player.getLength()) {\n            // Set the player's position.\n        }\n            \n    }\n    \n    /**\n     * Return the length of the current music file, if any.\n     * The length is in 'frames' rather than seconds, for instance.\n     * \n     * @return The file length in frames.\n     */\n    public int getLength()\n    {\n        if(player != null) {\n            return player.getLength();\n        }\n        else {\n            return 0;\n        }\n    }\n    \n    /**\n     * Set up the player ready to play the given file.\n     * @param filename The name of the file to play.\n     */\n    private void setupPlayer(String filename)\n    {\n        try {\n            if(player != null) {\n                killPlayer();\n            }\n            this.filename = filename;\n            player = new MusicFilePlayer(filename);\n        }\n        catch(JavaLayerException e) {\n            System.out.println(\"Problem setting up player\");\n            e.printStackTrace();\n            reportProblem();\n            killPlayer();\n        }\n    }\n    \n    /**\n     * Play from the given position.\n     * @param start The starting position for playing.\n     *              Must be within the current file's length.\n     */\n    private void playFrom(final int start) throws JavaLayerException\n    {\n        Thread playerThread = new Thread() {\n            public void run()\n            {\n                try {\n                    player.playFrom(start);\n                }\n                catch(JavaLayerException e) {\n                    reportProblem();\n                    killPlayer();\n                }\n            }\n        };\n        playerThread.setPriority(Thread.MIN_PRIORITY);\n        playerThread.start();\n    }\n\n    /**\n     * Terminate the player, if there is one.\n     */\n    private void killPlayer()\n    {\n        System.out.println(\"attempt to kill player\");\n        synchronized(this) {\n            System.out.println(\"within synchronized\");\n            if(player != null) {\n                System.out.println(\"calling player.stop\");\n                player.stop();\n                player = null;\n                filename = \"\";\n            }\n        }\n    }\n    \n    /**\n     * Report a problem playing the current file.\n     */\n    private void reportProblem()\n    {\n        System.out.println(\"There was a problem playing: \" + filename);\n    }\n\n}\n","position":{"x":177.27781721064622,"y":52.07152459678247}},{"name":"MusicPlayerGUI","content":"import java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\nimport javax.swing.event.*;\nimport javax.swing.border.*;\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\nimport java.io.*;\n\n/**\n * A simple sound player. To start, create an instance of this class.\n * \n * The sound player provides an interface to the MusicOrganizer class\n * from chapter 4.\n * \n * @author Michael Kölling and David J. Barnes\n * @version 1.0\n */\npublic class MusicPlayerGUI extends JFrame\n{\n    private static final String VERSION = \"Version 1.0\";\n    private static final String AUDIO_DIR = \"../audio\";\n    \n    private JList<String> fileList;\n    private JSlider slider;\n    private JLabel infoLabel;\n    private MusicOrganizer organizer;\n    // A player for the music tracks.\n    private MusicPlayer player;\n    // The current track list.\n    private List<Track> trackList;\n\n    /**\n     * Main method for starting the player from a command line.\n     */\n    public static void main(String[] args)\n    {\n        MusicPlayerGUI gui = new MusicPlayerGUI();\n    }\n    \n    /**\n     * Create a SoundPlayer and display its GUI on screen.\n     */\n    public MusicPlayerGUI()\n    {\n        super(\"Music Player\");\n        organizer = new MusicOrganizer(AUDIO_DIR);\n        player = new MusicPlayer();\n        \n        makeFrame();\n    }\n    \n    /**\n     * Play the sound file currently selected in the file list. If there is no\n     * selection in the list, or if the selected file is not a sound file, \n     * do nothing.\n     */\n    private void play()\n    {\n        int index = fileList.getSelectedIndex();\n        if(index >= 0 && index < trackList.size()) {\n            slider.setValue(0);\n            player.startPlaying(trackList.get(index).getFilename());\n        }\n    }\n\n    /**\n     * Stop the currently playing sound file (if there is one playing).\n     */\n    private void stop()\n    {\n        player.stop();\n    }\n\n    /**\n     * Stop the currently playing sound file (if there is one playing).\n     */\n    private void pause()\n    {\n        player.pause();\n    }\n\n    /**\n     * Resume a previously suspended sound file.\n     */\n    private void resume()\n    {\n        player.resume();\n    }\n\n    /**\n     * Display information about a selected sound file (name and clip length).\n     * @param message The message to display.\n     */\n    private void showInfo(String message)\n    {\n        infoLabel.setText(message);\n    }\n    \n    /**\n     * Quit function: quit the application.\n     */\n    private void quit()\n    {\n        System.exit(0);\n    }\n    \n    \n    /**\n     * About function: show the 'about' box.\n     */\n    private void showAbout()\n    {\n        JOptionPane.showMessageDialog(this, \n                    \"Music Player\\n\" + VERSION,\n                    \"About Music Player\", \n                    JOptionPane.INFORMATION_MESSAGE);\n    }\n    \n    /**\n     * Set the ordering of the track list.\n     * @param ordering The ordering to use.\n     */\n    private void setListOrdering(String ordering)\n    {\n        trackList = organizer.sortByField(ordering);\n        String[] tracks = getTracksDisplayList(trackList);\n        fileList.setListData(tracks);\n    }\n\n    /**\n     * Get a display version of the track list.\n     * @param trackList The list of tracks to be displayed.\n     * @return The tracks in display format.\n     */\n    private String[] getTracksDisplayList(List<Track> trackList)\n    {\n        int numTracks = trackList.size();\n        String[] tracks = new String[numTracks];\n        for(int i = 0; i < numTracks; i++) {\n            String[] fields = trackList.get(i).getFields();\n            StringBuilder listing = new StringBuilder();\n            for(String field : fields) {\n                listing.append(field);\n                listing.append(\" \");\n            }\n            tracks[i] = listing.toString().trim();\n        }\n        return tracks;\n    }\n\n    // ---- Swing stuff to build the frame and all its components and menus ----\n    \n    /**\n     * Create the complete application GUI.\n     */\n    private void makeFrame()\n    {\n        // the following makes sure that our application exits when\n        // the user closes its window\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n        \n        JPanel contentPane = (JPanel) getContentPane();\n        contentPane.setBorder(new EmptyBorder(6, 10, 10, 10));\n\n        makeMenuBar();\n        \n        // Specify the layout manager with nice spacing\n        contentPane.setLayout(new BorderLayout(8, 8));\n\n        // Create the left side with combobox and scroll list\n        JPanel leftPane = new JPanel();\n        {\n            leftPane.setLayout(new BorderLayout(8, 8));\n\n            // Set up components for ordering the list of tracks.\n            JPanel orderingPanel = new JPanel();\n            orderingPanel.setLayout(new BorderLayout());\n            orderingPanel.add(new JLabel(\"Order by:\"), BorderLayout.NORTH);\n            \n            // Get the list of field names, used for ordering.\n            String[] ordering = Track.FIELDS;\n            \n            // Create the combo box.\n            JComboBox<String> formatList = new JComboBox<>(ordering);\n            formatList.addActionListener(e -> {\n                int index = formatList.getSelectedIndex();\n                if(index >= 0) {\n                    String selectedOrder = formatList.getItemAt(index);\n                    setListOrdering(selectedOrder);\n                }\n            });\n            orderingPanel.add(formatList, BorderLayout.CENTER);\n            \n            leftPane.add(orderingPanel, BorderLayout.NORTH);\n    \n            // Create the scrolled list for track listing.\n            fileList = new JList<>();\n            fileList.setForeground(new Color(140,171,226));\n            fileList.setBackground(new Color(0,0,0));\n            fileList.setSelectionBackground(new Color(87,49,134));\n            fileList.setSelectionForeground(new Color(140,171,226));\n            JScrollPane scrollPane = new JScrollPane(fileList);\n            scrollPane.setColumnHeaderView(new JLabel(\"Audio files\"));\n            leftPane.add(scrollPane, BorderLayout.CENTER);\n            \n            // Set up the initial listing.\n            setListOrdering(ordering[0]);\n        }\n        contentPane.add(leftPane, BorderLayout.CENTER);\n\n        // Create the center with image, text label, and slider\n       JPanel centerPane = new JPanel();\n        {\n            centerPane.setLayout(new BorderLayout(8, 8));\n    \n            JLabel image = new JLabel(new ImageIcon(\"/app/tmp_assets/title.jpg\"));\n            centerPane.add(image, BorderLayout.NORTH);\n            centerPane.setBackground(Color.BLACK);\n\n            infoLabel = new JLabel(\"  \");\n            infoLabel.setHorizontalAlignment(SwingConstants.CENTER);\n            infoLabel.setForeground(new Color(140,171,226));\n            centerPane.add(infoLabel, BorderLayout.CENTER);\n\n            slider = new JSlider(0, 100, 0);\n            TitledBorder border = new TitledBorder(\"Seek\");\n            border.setTitleColor(Color.white);\n            slider.setBorder(new CompoundBorder(new EmptyBorder(6, 10, 10, 10), border));\n            // Provide a body for the change-listener lambda to react to changes\n            // of the slider.\n            slider.addChangeListener(e -> { });\n            slider.setBackground(Color.BLACK);\n            slider.setMajorTickSpacing(25);\n            slider.setPaintTicks(true);\n            centerPane.add(slider, BorderLayout.SOUTH);\n        }\n        contentPane.add(centerPane, BorderLayout.EAST);\n\n        // Create the toolbar with the buttons\n        JPanel toolbar = new JPanel();\n        {\n            toolbar.setLayout(new GridLayout(1, 0));\n  \n            JButton button = new JButton(\"Play\");\n            button.addActionListener(e -> play());\n            toolbar.add(button);\n            \n            button = new JButton(\"Stop\");\n            button.addActionListener(e -> stop());\n            toolbar.add(button);\n    \n            button = new JButton(\"Pause\");\n            button.addActionListener(e -> pause());\n            toolbar.add(button);\n            \n            button = new JButton(\"Resume\");\n            button.addActionListener(e -> resume());\n            toolbar.add(button);\n\n        }\n        \n        contentPane.add(toolbar, BorderLayout.NORTH);\n\n        // building is done - arrange the components      \n        pack();\n        \n        // place this frame at the center of the screen and show\n        Dimension d = Toolkit.getDefaultToolkit().getScreenSize();\n        setLocation(d.width/2 - getWidth()/2, d.height/2 - getHeight()/2);\n        setVisible(true);\n    }\n    \n    /**\n     * Create the main frame's menu bar.\n     */\n    private void makeMenuBar()\n    {\n        final int SHORTCUT_MASK =\n            Toolkit.getDefaultToolkit().getMenuShortcutKeyMask();\n\n        JMenuBar menubar = new JMenuBar();\n        setJMenuBar(menubar);\n        \n        JMenu menu;\n        JMenuItem item;\n        \n        // create the File menu\n        menu = new JMenu(\"File\");\n        menubar.add(menu);\n        \n        item = new JMenuItem(\"Quit\");\n            item.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Q, SHORTCUT_MASK));\n            item.addActionListener(e -> quit());\n        menu.add(item);\n\n        // create the Help menu\n        menu = new JMenu(\"Help\");\n        menubar.add(menu);\n        \n        item = new JMenuItem(\"About Music Player...\");\n            item.addActionListener(e -> showAbout());\n        menu.add(item);\n    }\n}\n","position":{"x":-124.67487088973095,"y":128.21895445802303}},{"name":"Track","content":"/**\n * Store the details of a music track,\n * such as the artist, title, and file name.\n * Use the FIELDS class variable for the names of\n * the available attributes.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class Track\n{\n    // The artist.\n    private String artist;\n    // The track's title.\n    private String title;\n    // Where the track is stored.\n    private String filename;\n    \n    // Names for the available fields.\n    public static final String[] FIELDS = {\n        \"Artist\",\n        \"Title\",\n        \"Filename\",\n    };\n    \n    /**\n     * Constructor for objects of class Track.\n     * @param artist The track's artist.\n     * @param title The track's title.\n     * @param filename The track file. \n     */\n    public Track(String artist, String title, String filename)\n    {\n        setDetails(artist, title, filename);\n    }\n    \n    /**\n     * Constructor for objects of class Track.\n     * It is assumed that the file name cannot be\n     * decoded to extract artist and title details.\n     * @param filename The track file. \n     */\n    public Track(String filename)\n    {\n        setDetails(\"unknown\", \"unknown\", filename);\n    }\n    \n    /**\n     * Return the artist.\n     * @return The artist.\n     */\n    public String getArtist()\n    {\n        return artist;\n    }\n    \n    /**\n     * Return the title.\n     * @return The title.\n     */\n    public String getTitle()\n    {\n        return title;\n    }\n    \n    /**\n     * Return the file name.\n     * @return The file name.\n     */\n    public String getFilename()\n    {\n        return filename;\n    }\n    \n    /**\n     * Return the value of the named field.\n     * The field should be an element of Track.FIELDS\n     * @param field Which field to return.\n     */\n    public String getField(String field) \n    {\n        if (field.equals(\"Artist\")) {\n            return artist;\n        }\n        else if (field.equals(\"Title\")) {\n            return title;\n        }\n        else if (field.equals(\"Filename\")) {\n            return filename;\n        }\n        else {\n            throw new IllegalArgumentException(\"Unknown field name: \" + field);\n        }\n    }\n    \n    /**\n     * Return the values of the fields.\n     * @return The fields.\n     */\n    public String[] getFields()\n    {\n        String[] fields = new String[FIELDS.length];\n        for(int i = 0; i < FIELDS.length; i++) {\n            fields[i] = getField(FIELDS[i]);\n        }\n        return fields;\n    }\n            \n        \n    /**\n     * Return details of the track: artist, title and file name.\n     * @return The track's details.\n     */\n    public String getDetails()\n    {\n        return artist + \": \" + title + \"  (file: \" + filename + \")\";\n    }\n    \n    /**\n     * Set details of the track.\n     * @param artist The track's artist.\n     * @param title The track's title.\n     * @param filename The track file. \n     */\n    private void setDetails(String artist, String title, String filename)\n    {\n        this.artist = artist;\n        this.title = title;\n        this.filename = filename;\n    }\n    \n}\n","position":{"x":553.2349045709984,"y":-129.71647421243654}},{"name":"TrackReader","content":"import java.io.File;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.util.ArrayList;\n\n/**\n * A helper class for our music application. This class can read files from the file system\n * from a given folder with a specified suffix. It will interpret the file name as artist/\n * track title information.\n * \n * It is expected that file names of music tracks follow a standard format of artist name\n * and track name, separated by a dash. For example: TheBeatles-HereComesTheSun.mp3\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class TrackReader\n{\n    /**\n     * Create the track reader, ready to read tracks from the music library folder.\n     */\n    public TrackReader()\n    {\n        // Nothing to do here.\n    }\n    \n    /**\n     * Read music files from the given library folder\n     * with the given suffix.\n     * @param folder The folder to look for files.\n     * @param suffix The suffix of the audio type.\n     */\n    public ArrayList<Track> readTracks(String folder, final String suffix)\n    {\n        //File audioFolder = new File(folder);\n        ArrayList<Track> tracks = new ArrayList<>();\n        /*File[] audioFiles = audioFolder.listFiles(new FilenameFilter() {\n            /**\n             * Accept files with matching suffix.\n             * @param dir The directory containing the file.\n             * @param name The name of the file.\n             * @return true if the name ends with the suffix.\n             \n            public boolean accept(File dir, String name)\n            {\n                return name.toLowerCase().endsWith(suffix);\n            }\n        });\n        \n        // Put all the matching files into the organizer.\n        for(File file : audioFiles) {\n            Track trackDetails = decodeDetails(file);\n            tracks.add(trackDetails);\n        }*/\n        tracks.add(new Track(\"Demo\", \"Music\", \"/app/tmp_assets/music.mp3\"));\n        return tracks;\n    }\n\n    /**\n     * Try to decode details of the artist and the title\n     * from the file name.\n     * It is assumed that the details are in the form:\n     *     artist-title.mp3\n     * @param file The track file.\n     * @return A Track containing the details.\n     */\n    private Track decodeDetails(File file)\n    {\n        // The information needed.\n        String artist = \"unknown\";\n        String title = \"unknown\";\n        String filename = file.getPath();\n        \n        // Look for artist and title in the name of the file.\n        String details = file.getName();\n        String[] parts = details.split(\"-\");\n        \n        if(parts.length == 2) {\n            artist = parts[0];\n            String titlePart = parts[1];\n            // Remove a file-type suffix.\n            parts = titlePart.split(\"\\\\.\");\n            if(parts.length >= 1) {\n                title = parts[0];\n            }\n            else {\n                title = titlePart;\n            }\n        }\n        return new Track(artist, title, filename);\n    }\n}\n","position":{"x":497.28328498217115,"y":120.12987771111432}}],"libs":"/app/tmp_assets/jl1.0.1.jar"}