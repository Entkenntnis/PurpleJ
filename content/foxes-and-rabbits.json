{"title":"Foxes and Rabbits","summary":"BlueJ Chapter 12","description":"","lastUpdated":1728740342602,"output":"display","classes":[{"name":"Animal","content":"import java.util.List;\n\n/**\n * A class representing shared characteristics of animals.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.03.18\n */\npublic abstract class Animal\n{\n    // Whether the animal is alive or not.\n    private boolean alive;\n    // The animal's field.\n    private Field field;\n    // The animal's position in the field.\n    private Location location;\n    \n    /**\n     * Create a new animal at location in field.\n     * \n     * @param field The field currently occupied.\n     * @param location The location within the field.\n     */\n    public Animal(Field field, Location location)\n    {\n        alive = true;\n        this.field = field;\n        setLocation(location);\n    }\n    \n    /**\n     * Make this animal act - that is: make it do\n     * whatever it wants/needs to do.\n     * @param newAnimals A list to receive newly born animals.\n     */\n    abstract public void act(List<Animal> newAnimals);\n\n    /**\n     * Check whether the animal is alive or not.\n     * @return true if the animal is still alive.\n     */\n    protected boolean isAlive()\n    {\n        return alive;\n    }\n\n    /**\n     * Indicate that the animal is no longer alive.\n     * It is removed from the field.\n     */\n    protected void setDead()\n    {\n        alive = false;\n        if(location != null) {\n            field.clear(location);\n            location = null;\n            field = null;\n        }\n    }\n\n    /**\n     * Return the animal's location.\n     * @return The animal's location.\n     */\n    protected Location getLocation()\n    {\n        return location;\n    }\n    \n    /**\n     * Place the animal at the new location in the given field.\n     * @param newLocation The animal's new location.\n     */\n    protected void setLocation(Location newLocation)\n    {\n        if(location != null) {\n            field.clear(location);\n        }\n        location = newLocation;\n        field.place(this, newLocation);\n    }\n    \n    /**\n     * Return the animal's field.\n     * @return The animal's field.\n     */\n    protected Field getField()\n    {\n        return field;\n    }\n}\n","position":{"x":441.83540653148685,"y":-303.2185589521736}},{"name":"Counter","content":"import java.awt.Color;\n\n/**\n * Provide a counter for a participant in the simulation.\n * This includes an identifying string and a count of how\n * many participants of this type currently exist within \n * the simulation.\n * \n * @author Michael Kölling and David J. Barnes\n * @version 2016.02.29\n */\npublic class Counter\n{\n    // A name for this type of simulation participant\n    private String name;\n    // How many of this type exist in the simulation.\n    private int count;\n\n    /**\n     * Provide a name for one of the simulation types.\n     * @param name  A name, e.g. \"Fox\".\n     */\n    public Counter(String name)\n    {\n        this.name = name;\n        count = 0;\n    }\n    \n    /**\n     * @return The short description of this type.\n     */\n    public String getName()\n    {\n        return name;\n    }\n\n    /**\n     * @return The current count for this type.\n     */\n    public int getCount()\n    {\n        return count;\n    }\n\n    /**\n     * Increment the current count by one.\n     */\n    public void increment()\n    {\n        count++;\n    }\n    \n    /**\n     * Reset the current count to zero.\n     */\n    public void reset()\n    {\n        count = 0;\n    }\n}\n","position":{"x":587.5000351368362,"y":28.39570193526839}},{"name":"Field","content":"import java.util.Collections;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Random;\n\n/**\n * Represent a rectangular grid of field positions.\n * Each position is able to store a single animal.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class Field\n{\n    // A random number generator for providing random locations.\n    private static final Random rand = Randomizer.getRandom();\n    \n    // The depth and width of the field.\n    private int depth, width;\n    // Storage for the animals.\n    private Object[][] field;\n\n    /**\n     * Represent a field of the given dimensions.\n     * @param depth The depth of the field.\n     * @param width The width of the field.\n     */\n    public Field(int depth, int width)\n    {\n        this.depth = depth;\n        this.width = width;\n        field = new Object[depth][width];\n    }\n    \n    /**\n     * Empty the field.\n     */\n    public void clear()\n    {\n        for(int row = 0; row < depth; row++) {\n            for(int col = 0; col < width; col++) {\n                field[row][col] = null;\n            }\n        }\n    }\n    \n    /**\n     * Clear the given location.\n     * @param location The location to clear.\n     */\n    public void clear(Location location)\n    {\n        field[location.getRow()][location.getCol()] = null;\n    }\n    \n    /**\n     * Place an animal at the given location.\n     * If there is already an animal at the location it will\n     * be lost.\n     * @param animal The animal to be placed.\n     * @param row Row coordinate of the location.\n     * @param col Column coordinate of the location.\n     */\n    public void place(Object animal, int row, int col)\n    {\n        place(animal, new Location(row, col));\n    }\n    \n    /**\n     * Place an animal at the given location.\n     * If there is already an animal at the location it will\n     * be lost.\n     * @param animal The animal to be placed.\n     * @param location Where to place the animal.\n     */\n    public void place(Object animal, Location location)\n    {\n        field[location.getRow()][location.getCol()] = animal;\n    }\n    \n    /**\n     * Return the animal at the given location, if any.\n     * @param location Where in the field.\n     * @return The animal at the given location, or null if there is none.\n     */\n    public Object getObjectAt(Location location)\n    {\n        return getObjectAt(location.getRow(), location.getCol());\n    }\n    \n    /**\n     * Return the animal at the given location, if any.\n     * @param row The desired row.\n     * @param col The desired column.\n     * @return The animal at the given location, or null if there is none.\n     */\n    public Object getObjectAt(int row, int col)\n    {\n        return field[row][col];\n    }\n    \n    /**\n     * Generate a random location that is adjacent to the\n     * given location, or is the same location.\n     * The returned location will be within the valid bounds\n     * of the field.\n     * @param location The location from which to generate an adjacency.\n     * @return A valid location within the grid area.\n     */\n    public Location randomAdjacentLocation(Location location)\n    {\n        List<Location> adjacent = adjacentLocations(location);\n        return adjacent.get(0);\n    }\n    \n    /**\n     * Get a shuffled list of the free adjacent locations.\n     * @param location Get locations adjacent to this.\n     * @return A list of free adjacent locations.\n     */\n    public List<Location> getFreeAdjacentLocations(Location location)\n    {\n        List<Location> free = new LinkedList<>();\n        List<Location> adjacent = adjacentLocations(location);\n        for(Location next : adjacent) {\n            if(getObjectAt(next) == null) {\n                free.add(next);\n            }\n        }\n        return free;\n    }\n    \n    /**\n     * Try to find a free location that is adjacent to the\n     * given location. If there is none, return null.\n     * The returned location will be within the valid bounds\n     * of the field.\n     * @param location The location from which to generate an adjacency.\n     * @return A valid location within the grid area.\n     */\n    public Location freeAdjacentLocation(Location location)\n    {\n        // The available free ones.\n        List<Location> free = getFreeAdjacentLocations(location);\n        if(free.size() > 0) {\n            return free.get(0);\n        }\n        else {\n            return null;\n        }\n    }\n\n    /**\n     * Return a shuffled list of locations adjacent to the given one.\n     * The list will not include the location itself.\n     * All locations will lie within the grid.\n     * @param location The location from which to generate adjacencies.\n     * @return A list of locations adjacent to that given.\n     */\n    public List<Location> adjacentLocations(Location location)\n    {\n        assert location != null : \"Null location passed to adjacentLocations\";\n        // The list of locations to be returned.\n        List<Location> locations = new LinkedList<>();\n        if(location != null) {\n            int row = location.getRow();\n            int col = location.getCol();\n            for(int roffset = -1; roffset <= 1; roffset++) {\n                int nextRow = row + roffset;\n                if(nextRow >= 0 && nextRow < depth) {\n                    for(int coffset = -1; coffset <= 1; coffset++) {\n                        int nextCol = col + coffset;\n                        // Exclude invalid locations and the original location.\n                        if(nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {\n                            locations.add(new Location(nextRow, nextCol));\n                        }\n                    }\n                }\n            }\n            \n            // Shuffle the list. Several other methods rely on the list\n            // being in a random order.\n            Collections.shuffle(locations, rand);\n        }\n        return locations;\n    }\n\n    /**\n     * Return the depth of the field.\n     * @return The depth of the field.\n     */\n    public int getDepth()\n    {\n        return depth;\n    }\n    \n    /**\n     * Return the width of the field.\n     * @return The width of the field.\n     */\n    public int getWidth()\n    {\n        return width;\n    }\n}\n","position":{"x":582.7309959770589,"y":-147.6332683474732}},{"name":"FieldStats","content":"import java.awt.Color;\nimport java.util.HashMap;\n\n/**\n * This class collects and provides some statistical data on the state \n * of a field. It is flexible: it will create and maintain a counter \n * for any class of object that is found within the field.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class FieldStats\n{\n    // Counters for each type of entity (fox, rabbit, etc.) in the simulation.\n    private HashMap<Class, Counter> counters;\n    // Whether the counters are currently up to date.\n    private boolean countsValid;\n\n    /**\n     * Construct a FieldStats object.\n     */\n    public FieldStats()\n    {\n        // Set up a collection for counters for each type of animal that\n        // we might find\n        counters = new HashMap<>();\n        countsValid = false;\n    }\n\n    /**\n     * Get details of what is in the field.\n     * @return A string describing what is in the field.\n     */\n    public String getPopulationDetails(Field field)\n    {\n        StringBuffer buffer = new StringBuffer();\n        if(!countsValid) {\n            generateCounts(field);\n        }\n        for(Class key : counters.keySet()) {\n            Counter info = counters.get(key);\n            buffer.append(info.getName());\n            buffer.append(\": \");\n            buffer.append(info.getCount());\n            buffer.append(' ');\n        }\n        return buffer.toString();\n    }\n    \n    /**\n     * Get the number of individuals in the population of a given class.\n     * @return  An int with the number for this class.\n     */\n    public int getPopulationCount(Field field, Class key)\n    {\n        if(!countsValid) {\n            generateCounts(field);\n        }\n\n        Counter counter = counters.get(key);\n        return counter.getCount();\n    }\n    \n    /**\n     * Invalidate the current set of statistics; reset all \n     * counts to zero.\n     */\n    public void reset()\n    {\n        countsValid = false;\n        for(Class key : counters.keySet()) {\n            Counter count = counters.get(key);\n            count.reset();\n        }\n    }\n\n    /**\n     * Increment the count for one class of animal.\n     * @param animalClass The class of animal to increment.\n     */\n    public void incrementCount(Class animalClass)\n    {\n        Counter count = counters.get(animalClass);\n        if(count == null) {\n            // We do not have a counter for this species yet.\n            // Create one.\n            count = new Counter(animalClass.getName());\n            counters.put(animalClass, count);\n        }\n        count.increment();\n    }\n\n    /**\n     * Indicate that an animal count has been completed.\n     */\n    public void countFinished()\n    {\n        countsValid = true;\n    }\n\n    /**\n     * Determine whether the simulation is still viable.\n     * I.e., should it continue to run.\n     * @return true If there is more than one species alive.\n     */\n    public boolean isViable(Field field)\n    {\n        // How many counts are non-zero.\n        int nonZero = 0;\n        if(!countsValid) {\n            generateCounts(field);\n        }\n        for(Class key : counters.keySet()) {\n            Counter info = counters.get(key);\n            if(info.getCount() > 0) {\n                nonZero++;\n            }\n        }\n        return nonZero > 1;\n    }\n    \n    /**\n     * Generate counts of the number of foxes and rabbits.\n     * These are not kept up to date as foxes and rabbits\n     * are placed in the field, but only when a request\n     * is made for the information.\n     * @param field The field to generate the stats for.\n     */\n    private void generateCounts(Field field)\n    {\n        reset();\n        for(int row = 0; row < field.getDepth(); row++) {\n            for(int col = 0; col < field.getWidth(); col++) {\n                Object animal = field.getObjectAt(row, col);\n                if(animal != null) {\n                    incrementCount(animal.getClass());\n                }\n            }\n        }\n        countsValid = true;\n    }\n}\n","position":{"x":383.6517944959677,"y":86.31844486975972}},{"name":"Fox","content":"import java.util.List;\nimport java.util.Iterator;\nimport java.util.Random;\n\n/**\n * A simple model of a fox.\n * Foxes age, move, eat rabbits, and die.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.03.18\n */\npublic class Fox extends Animal\n{\n    // Characteristics shared by all foxes (class variables).\n    \n    // The age at which a fox can start to breed.\n    private static final int BREEDING_AGE = 15;\n    // The age to which a fox can live.\n    private static final int MAX_AGE = 150;\n    // The likelihood of a fox breeding.\n    private static final double BREEDING_PROBABILITY = 0.08;\n    // The maximum number of births.\n    private static final int MAX_LITTER_SIZE = 2;\n    // The food value of a single rabbit. In effect, this is the\n    // number of steps a fox can go before it has to eat again.\n    private static final int RABBIT_FOOD_VALUE = 9;\n    // A shared random number generator to control breeding.\n    private static final Random rand = Randomizer.getRandom();\n    \n    // Individual characteristics (instance fields).\n    // The fox's age.\n    private int age;\n    // The fox's food level, which is increased by eating rabbits.\n    private int foodLevel;\n\n    /**\n     * Create a fox. A fox can be created as a new born (age zero\n     * and not hungry) or with a random age and food level.\n     * \n     * @param randomAge If true, the fox will have random age and hunger level.\n     * @param field The field currently occupied.\n     * @param location The location within the field.\n     */\n    public Fox(boolean randomAge, Field field, Location location)\n    {\n        super(field, location);\n        if(randomAge) {\n            age = rand.nextInt(MAX_AGE);\n            foodLevel = rand.nextInt(RABBIT_FOOD_VALUE);\n        }\n        else {\n            age = 0;\n            foodLevel = RABBIT_FOOD_VALUE;\n        }\n    }\n    \n    /**\n     * This is what the fox does most of the time: it hunts for\n     * rabbits. In the process, it might breed, die of hunger,\n     * or die of old age.\n     * @param field The field currently occupied.\n     * @param newFoxes A list to return newly born foxes.\n     */\n    public void act(List<Animal> newFoxes)\n    {\n        incrementAge();\n        incrementHunger();\n        if(isAlive()) {\n            giveBirth(newFoxes);            \n            // Move towards a source of food if found.\n            Location newLocation = findFood();\n            if(newLocation == null) { \n                // No food found - try to move to a free location.\n                newLocation = getField().freeAdjacentLocation(getLocation());\n            }\n            // See if it was possible to move.\n            if(newLocation != null) {\n                setLocation(newLocation);\n            }\n            else {\n                // Overcrowding.\n                setDead();\n            }\n        }\n    }\n\n    /**\n     * Increase the age. This could result in the fox's death.\n     */\n    private void incrementAge()\n    {\n        age++;\n        if(age > MAX_AGE) {\n            setDead();\n        }\n    }\n    \n    /**\n     * Make this fox more hungry. This could result in the fox's death.\n     */\n    private void incrementHunger()\n    {\n        foodLevel--;\n        if(foodLevel <= 0) {\n            setDead();\n        }\n    }\n    \n    /**\n     * Look for rabbits adjacent to the current location.\n     * Only the first live rabbit is eaten.\n     * @return Where food was found, or null if it wasn't.\n     */\n    private Location findFood()\n    {\n        Field field = getField();\n        List<Location> adjacent = field.adjacentLocations(getLocation());\n        Iterator<Location> it = adjacent.iterator();\n        while(it.hasNext()) {\n            Location where = it.next();\n            Object animal = field.getObjectAt(where);\n            if(animal instanceof Rabbit) {\n                Rabbit rabbit = (Rabbit) animal;\n                if(rabbit.isAlive()) { \n                    rabbit.setDead();\n                    foodLevel = RABBIT_FOOD_VALUE;\n                    return where;\n                }\n            }\n        }\n        return null;\n    }\n    \n    /**\n     * Check whether or not this fox is to give birth at this step.\n     * New births will be made into free adjacent locations.\n     * @param newFoxes A list to return newly born foxes.\n     */\n    private void giveBirth(List<Animal> newFoxes)\n    {\n        // New foxes are born into adjacent locations.\n        // Get a list of adjacent free locations.\n        Field field = getField();\n        List<Location> free = field.getFreeAdjacentLocations(getLocation());\n        int births = breed();\n        for(int b = 0; b < births && free.size() > 0; b++) {\n            Location loc = free.remove(0);\n            Fox young = new Fox(false, field, loc);\n            newFoxes.add(young);\n        }\n    }\n        \n    /**\n     * Generate a number representing the number of births,\n     * if it can breed.\n     * @return The number of births (may be zero).\n     */\n    private int breed()\n    {\n        int births = 0;\n        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {\n            births = rand.nextInt(MAX_LITTER_SIZE) + 1;\n        }\n        return births;\n    }\n\n    /**\n     * A fox can breed if it has reached the breeding age.\n     */\n    private boolean canBreed()\n    {\n        return age >= BREEDING_AGE;\n    }\n}\n","position":{"x":160.81292576062995,"y":-34.67903987939974}},{"name":"GraphView","content":"import java.awt.*;\nimport java.awt.image.*;\nimport javax.swing.*;\nimport java.util.*;\n\n/**\n * The GraphView provides a view of two populations of actors in the field as a line graph\n * over time. In its current version, it can only plot exactly two different classes of \n * animals. If further animals are introduced, they will not currently be displayed.\n * \n * @author Michael Kölling and David J. Barnes\n * @version 2016.03.18\n */\npublic class GraphView implements SimulatorView\n{\n    private static final Color LIGHT_GRAY = new Color(0, 0, 0, 40);\n\n    private static JFrame frame;\n    private static GraphPanel graph;\n    private static JLabel stepLabel;\n    private static JLabel countLabel;\n\n    // The classes being tracked by this view\n    private Set<Class<?>> classes;\n    // A map for storing colors for participants in the simulation\n    private Map<Class<?>, Color> colors;\n    // A statistics object computing and storing simulation information\n    private FieldStats stats;\n\n    /**\n     * Constructor.\n     * \n     * @param width The width of the plotter window (in pixels).\n     * @param height The height of the plotter window (in pixels).\n     * @param startMax The initial maximum value for the y axis.\n     */\n    public GraphView(int width, int height, int startMax)\n    {\n        stats = new FieldStats();\n        classes = new HashSet<>();\n        colors = new HashMap<>();\n\n        if (frame == null) {\n            frame = makeFrame(width, height, startMax);\n        }\n        else {\n            graph.newRun();\n        }\n\n        //showStatus(0, null);\n    }\n\n    /**\n     * Define a color to be used for a given class of animal.\n     * @param animalClass The animal's Class object.\n     * @param color The color to be used for the given class.\n     */\n    public void setColor(Class<?> animalClass, Color color)\n    {\n        colors.put(animalClass, color);\n        classes = colors.keySet();\n    }\n\n    /**\n     * Show the current status of the field. The status is shown by displaying a line graph for\n     * two classes in the field. This view currently does not work for more (or fewer) than exactly\n     * two classes. If the field contains more than two different types of animal, only two of the classes\n     * will be plotted.\n     * \n     * @param step Which iteration step it is.\n     * @param field The field whose status is to be displayed.\n     */\n    public void showStatus(int step, Field field)\n    {\n        graph.update(step, field, stats);\n    }\n\n    /**\n     * Determine whether the simulation should continue to run.\n     * @return true If there is more than one species alive.\n     */\n    public boolean isViable(Field field)\n    {\n        return stats.isViable(field);\n    }\n\n    /**\n     * Prepare for a new run.\n     */\n    public void reset()\n    {\n        stats.reset();\n        graph.newRun();\n    }\n    \n    /**\n     * Prepare the frame for the graph display.\n     */\n    private JFrame makeFrame(int width, int height, int startMax)\n    {\n        JFrame frame = new JFrame(\"Graph View\");\n        frame.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);\n\n        Container contentPane = frame.getContentPane();\n\n        graph = new GraphPanel(width, height, startMax);\n        contentPane.add(graph, BorderLayout.CENTER);\n\n        JPanel bottom = new JPanel();\n        bottom.add(new JLabel(\"Step:\"));\n        stepLabel = new JLabel(\"\");\n        bottom.add(stepLabel);\n        countLabel = new JLabel(\" \");\n        bottom.add(countLabel);\n        contentPane.add(bottom, BorderLayout.SOUTH);\n\n        frame.pack();\n        frame.setLocation(20, 600);\n\n        frame.setVisible(true);\n\n        return frame;\n    }\n\n    // ============================================================================\n    /**\n     * Nested class: a component to display the graph.\n     */\n    class GraphPanel extends JComponent\n    {\n        private static final double SCALE_FACTOR = 0.8;\n\n        // An internal image buffer that is used for painting. For\n        // actual display, this image buffer is then copied to screen.\n        private BufferedImage graphImage;\n        private int lastVal1, lastVal2;\n        private int yMax;\n\n        /**\n         * Create a new, empty GraphPanel.\n         */\n        public GraphPanel(int width, int height, int startMax)\n        {\n            graphImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n            clearImage();\n            lastVal1 = height;\n            lastVal2 = height;\n            yMax = startMax;\n        }\n\n        /**\n         * Indicate a new simulation run on this panel.\n         */\n        public void newRun()\n        {\n            int height = graphImage.getHeight();\n            int width = graphImage.getWidth();\n\n            Graphics g = graphImage.getGraphics();\n            g.copyArea(4, 0, width-4, height, -4, 0);            \n            g.setColor(Color.BLACK);\n            g.drawLine(width-4, 0, width-4, height);\n            g.drawLine(width-2, 0, width-2, height);\n            lastVal1 = height;\n            lastVal2 = height;\n            repaint();\n        }\n\n        /**\n         * Dispay a new point of data.\n         */\n        public void update(int step, Field field, FieldStats stats)\n        {\n            if (classes.size() >= 2) {\n                Iterator<Class<?>> it = classes.iterator();\n                Class<?> class1 = it.next();\n                Class<?> class2 = it.next();\n\n                stats.reset();\n                int count1 = stats.getPopulationCount(field, class1);\n                int count2 = stats.getPopulationCount(field, class2);\n\n                Graphics g = graphImage.getGraphics();\n\n                int height = graphImage.getHeight();\n                int width = graphImage.getWidth();\n\n                // move graph one pixel to left\n                g.copyArea(1, 0, width-1, height, -1, 0);\n\n                // calculate y, check whether it's out of screen. scale down if necessary.\n                int y = height - ((height * count1) / yMax) - 1;\n                while (y<0) {\n                    scaleDown();\n                    y = height - ((height * count1) / yMax) - 1;\n                }\n                g.setColor(LIGHT_GRAY);\n                g.drawLine(width-2, y, width-2, height);\n                g.setColor(colors.get(class1));\n                g.drawLine(width-3, lastVal1, width-2, y);\n                lastVal1 = y;\n\n                y = height - ((height * count2) / yMax) - 1;\n                while (y<0) {\n                    scaleDown();\n                    y = height - ((height * count2) / yMax) - 1;\n                }\n                g.setColor(LIGHT_GRAY);\n                g.drawLine(width-2, y, width-2, height);\n                g.setColor(colors.get(class2));\n                g.drawLine(width-3, lastVal2, width-2, y);\n                lastVal2 = y;\n\n                repaint();\n\n                stepLabel.setText(\"\" + step);\n                countLabel.setText(stats.getPopulationDetails(field));\n            }\n        }\n\n        /**\n         * Scale the current graph down vertically to make more room at the top.\n         */\n        public void scaleDown()\n        {\n            Graphics g = graphImage.getGraphics();\n            int height = graphImage.getHeight();\n            int width = graphImage.getWidth();\n\n            BufferedImage tmpImage = new BufferedImage(width, (int)(height*SCALE_FACTOR), \n                                                       BufferedImage.TYPE_INT_RGB);\n            Graphics2D gtmp = (Graphics2D) tmpImage.getGraphics();\n\n            gtmp.scale(1.0, SCALE_FACTOR);\n            gtmp.drawImage(graphImage, 0, 0, null);\n\n            int oldTop = (int) (height * (1.0-SCALE_FACTOR));\n\n            g.setColor(Color.WHITE);\n            g.fillRect(0, 0, width, oldTop);\n            g.drawImage(tmpImage, 0, oldTop, null);\n\n            yMax = (int) (yMax / SCALE_FACTOR);\n            lastVal1 = oldTop + (int) (lastVal1 * SCALE_FACTOR);\n            lastVal2 = oldTop + (int) (lastVal2 * SCALE_FACTOR);\n\n            repaint();\n        }\n\n        /**\n         * Clear the image on this panel.\n         */\n        final public void clearImage()\n        {\n            Graphics g = graphImage.getGraphics();\n            g.setColor(Color.WHITE);\n            g.fillRect(0, 0, graphImage.getWidth(), graphImage.getHeight());\n            repaint();\n        }\n\n        // The following methods are redefinitions of methods\n        // inherited from superclasses.\n\n        /**\n         * Tell the layout manager how big we would like to be.\n         * (This method gets called by layout managers for placing\n         * the components.)\n         * \n         * @return The preferred dimension for this component.\n         */\n        public Dimension getPreferredSize()\n        {\n            return new Dimension(graphImage.getWidth(), graphImage.getHeight());\n        }\n\n        /**\n         * This component is opaque.\n         */\n        public boolean isOpaque()\n        {\n            return true;\n        }\n\n        /**\n         * This component needs to be redisplayed. Copy the internal image \n         * to screen. (This method gets called by the Swing screen painter \n         * every time it want this component displayed.)\n         * \n         * @param g The graphics context that can be used to draw on this component.\n         */\n        public void paintComponent(Graphics g)\n        {\n            if(graphImage != null) {\n                g.drawImage(graphImage, 0, 0, null);\n            }\n        }\n    }\n}\n","position":{"x":118.37076874399936,"y":87.81041584350646}},{"name":"GridView","content":"import java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * A graphical view of the simulation grid.\n * The view displays a colored rectangle for each location representing its contents.\n * Colors for each type of species can be defined using the setColor method.\n * \n * @author Michael Kölling and David J. Barnes\n * @version 2016.03.18\n */\npublic class GridView extends JFrame implements SimulatorView\n{\n    // Colors used for empty locations.\n    private static final Color EMPTY_COLOR = Color.white;\n\n    // Color used for objects that have no defined color.\n    private static final Color UNKNOWN_COLOR = Color.gray;\n\n    private final String STEP_PREFIX = \"Step: \";\n    private final String POPULATION_PREFIX = \"Population: \";\n    private JLabel stepLabel, population;\n    private FieldView fieldView;\n    \n    // A map for storing colors for participants in the simulation\n    private Map<Class<?>, Color> colors;\n    // A statistics object computing and storing simulation information\n    private FieldStats stats;\n\n    /**\n     * Create a view of the given width and height.\n     * @param height The simulation's height.\n     * @param width  The simulation's width.\n     */\n    public GridView(int height, int width)\n    {\n        stats = new FieldStats();\n        colors = new HashMap<>();\n\n        setTitle(\"Fox and Rabbit Simulation\");\n        stepLabel = new JLabel(STEP_PREFIX, JLabel.CENTER);\n        population = new JLabel(POPULATION_PREFIX, JLabel.CENTER);\n        \n        setLocation(20, 50);\n        \n        fieldView = new FieldView(height, width);\n\n        Container contents = getContentPane();\n        contents.add(stepLabel, BorderLayout.NORTH);\n        contents.add(fieldView, BorderLayout.CENTER);\n        contents.add(population, BorderLayout.SOUTH);\n        pack();\n        setVisible(true);\n    }\n    \n    /**\n     * Define a color to be used for a given class of animal.\n     * @param animalClass The animal's Class object.\n     * @param color The color to be used for the given class.\n     */\n    public void setColor(Class<?> animalClass, Color color)\n    {\n        colors.put(animalClass, color);\n    }\n\n    /**\n     * @return The color to be used for a given class of animal.\n     */\n    private Color getColor(Class<?> animalClass)\n    {\n        Color col = colors.get(animalClass);\n        if(col == null) {\n            // no color defined for this class\n            return UNKNOWN_COLOR;\n        }\n        else {\n            return col;\n        }\n    }\n\n    /**\n     * Show the current status of the field.\n     * @param step Which iteration step it is.\n     * @param field The field whose status is to be displayed.\n     */\n    public void showStatus(int step, Field field)\n    {\n        if(!isVisible()) {\n            setVisible(true);\n        }\n            \n        stepLabel.setText(STEP_PREFIX + step);\n        stats.reset();\n        \n        fieldView.preparePaint();\n\n        for(int row = 0; row < field.getDepth(); row++) {\n            for(int col = 0; col < field.getWidth(); col++) {\n                Object animal = field.getObjectAt(row, col);\n                if(animal != null) {\n                    Class<?> cls = animal.getClass();\n                    stats.incrementCount(cls);\n                    fieldView.drawMark(col, row, getColor(cls));\n                }\n                else {\n                    fieldView.drawMark(col, row, EMPTY_COLOR);\n                }\n            }\n        }\n        stats.countFinished();\n\n        population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));\n        fieldView.repaint();\n    }\n\n    /**\n     * Determine whether the simulation should continue to run.\n     * @return true If there is more than one species alive.\n     */\n    public boolean isViable(Field field)\n    {\n        return stats.isViable(field);\n    }\n    \n    /**\n     * Prepare for a new run.\n     */\n    public void reset()\n    {\n        stats.reset();\n    }\n    \n    /**\n     * Provide a graphical view of a rectangular field. This is \n     * a nested class (a class defined inside a class) which\n     * defines a custom component for the user interface. This\n     * component displays the field.\n     * This is rather advanced GUI stuff - you can ignore this \n     * for your project if you like.\n     */\n    private class FieldView extends JPanel\n    {\n        private final int GRID_VIEW_SCALING_FACTOR = 6;\n\n        private int gridWidth, gridHeight;\n        private int xScale, yScale;\n        Dimension size;\n        private Graphics g;\n        private Image fieldImage;\n\n        /**\n         * Create a new FieldView component.\n         */\n        public FieldView(int height, int width)\n        {\n            gridHeight = height;\n            gridWidth = width;\n            size = new Dimension(0, 0);\n        }\n\n        /**\n         * Tell the GUI manager how big we would like to be.\n         */\n        public Dimension getPreferredSize()\n        {\n            return new Dimension(gridWidth * GRID_VIEW_SCALING_FACTOR,\n                                 gridHeight * GRID_VIEW_SCALING_FACTOR);\n        }\n\n        /**\n         * Prepare for a new round of painting. Since the component\n         * may be resized, compute the scaling factor again.\n         */\n        public void preparePaint()\n        {\n            if(! size.equals(getSize())) {  // if the size has changed...\n                size = getSize();\n                fieldImage = fieldView.createImage(size.width, size.height);\n                g = fieldImage.getGraphics();\n\n                xScale = size.width / gridWidth;\n                if(xScale < 1) {\n                    xScale = GRID_VIEW_SCALING_FACTOR;\n                }\n                yScale = size.height / gridHeight;\n                if(yScale < 1) {\n                    yScale = GRID_VIEW_SCALING_FACTOR;\n                }\n            }\n        }\n        \n        /**\n         * Paint on grid location on this field in a given color.\n         */\n        public void drawMark(int x, int y, Color color)\n        {\n            g.setColor(color);\n            g.fillRect(x * xScale, y * yScale, xScale-1, yScale-1);\n        }\n\n        /**\n         * The field view component needs to be redisplayed. Copy the\n         * internal image to screen.\n         */\n        public void paintComponent(Graphics g)\n        {\n            if(fieldImage != null) {\n                Dimension currentSize = getSize();\n                if(size.equals(currentSize)) {\n                    g.drawImage(fieldImage, 0, 0, null);\n                }\n                else {\n                    // Rescale the previous image.\n                    g.drawImage(fieldImage, 0, 0, currentSize.width, currentSize.height, null);\n                }\n            }\n        }\n    }\n}\n","position":{"x":152.11632101095063,"y":-196.36312014997696}},{"name":"Location","content":"/**\n * Represent a location in a rectangular grid.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class Location\n{\n    // Row and column positions.\n    private int row;\n    private int col;\n\n    /**\n     * Represent a row and column.\n     * @param row The row.\n     * @param col The column.\n     */\n    public Location(int row, int col)\n    {\n        this.row = row;\n        this.col = col;\n    }\n    \n    /**\n     * Implement content equality.\n     */\n    public boolean equals(Object obj)\n    {\n        if(obj instanceof Location) {\n            Location other = (Location) obj;\n            return row == other.getRow() && col == other.getCol();\n        }\n        else {\n            return false;\n        }\n    }\n    \n    /**\n     * Return a string of the form row,column\n     * @return A string representation of the location.\n     */\n    public String toString()\n    {\n        return row + \",\" + col;\n    }\n    \n    /**\n     * Use the top 16 bits for the row value and the bottom for\n     * the column. Except for very big grids, this should give a\n     * unique hash code for each (row, col) pair.\n     * @return A hashcode for the location.\n     */\n    public int hashCode()\n    {\n        return (row << 16) + col;\n    }\n    \n    /**\n     * @return The row.\n     */\n    public int getRow()\n    {\n        return row;\n    }\n    \n    /**\n     * @return The column.\n     */\n    public int getCol()\n    {\n        return col;\n    }\n}\n","position":{"x":725.8652592957123,"y":-258.26788255102053}},{"name":"Rabbit","content":"import java.util.List;\nimport java.util.Random;\n\n/**\n * A simple model of a rabbit.\n * Rabbits age, move, breed, and die.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.03.18\n */\npublic class Rabbit extends Animal\n{\n    // Characteristics shared by all rabbits (class variables).\n\n    // The age at which a rabbit can start to breed.\n    private static final int BREEDING_AGE = 5;\n    // The age to which a rabbit can live.\n    private static final int MAX_AGE = 40;\n    // The likelihood of a rabbit breeding.\n    private static final double BREEDING_PROBABILITY = 0.12;\n    // The maximum number of births.\n    private static final int MAX_LITTER_SIZE = 4;\n    // A shared random number generator to control breeding.\n    private static final Random rand = Randomizer.getRandom();\n    \n    // Individual characteristics (instance fields).\n    \n    // The rabbit's age.\n    private int age;\n\n    /**\n     * Create a new rabbit. A rabbit may be created with age\n     * zero (a new born) or with a random age.\n     * \n     * @param randomAge If true, the rabbit will have a random age.\n     * @param field The field currently occupied.\n     * @param location The location within the field.\n     */\n    public Rabbit(boolean randomAge, Field field, Location location)\n    {\n        super(field, location);\n        age = 0;\n        if(randomAge) {\n            age = rand.nextInt(MAX_AGE);\n        }\n    }\n    \n    /**\n     * This is what the rabbit does most of the time - it runs \n     * around. Sometimes it will breed or die of old age.\n     * @param newRabbits A list to return newly born rabbits.\n     */\n    public void act(List<Animal> newRabbits)\n    {\n        incrementAge();\n        if(isAlive()) {\n            giveBirth(newRabbits);            \n            // Try to move into a free location.\n            Location newLocation = getField().freeAdjacentLocation(getLocation());\n            if(newLocation != null) {\n                setLocation(newLocation);\n            }\n            else {\n                // Overcrowding.\n                setDead();\n            }\n        }\n    }\n\n    /**\n     * Increase the age.\n     * This could result in the rabbit's death.\n     */\n    private void incrementAge()\n    {\n        age++;\n        if(age > MAX_AGE) {\n            setDead();\n        }\n    }\n    \n    /**\n     * Check whether or not this rabbit is to give birth at this step.\n     * New births will be made into free adjacent locations.\n     * @param newRabbits A list to return newly born rabbits.\n     */\n    private void giveBirth(List<Animal> newRabbits)\n    {\n        // New rabbits are born into adjacent locations.\n        // Get a list of adjacent free locations.\n        Field field = getField();\n        List<Location> free = field.getFreeAdjacentLocations(getLocation());\n        int births = breed();\n        for(int b = 0; b < births && free.size() > 0; b++) {\n            Location loc = free.remove(0);\n            Rabbit young = new Rabbit(false, field, loc);\n            newRabbits.add(young);\n        }\n    }\n        \n    /**\n     * Generate a number representing the number of births,\n     * if it can breed.\n     * @return The number of births (may be zero).\n     */\n    private int breed()\n    {\n        int births = 0;\n        if(canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {\n            births = rand.nextInt(MAX_LITTER_SIZE) + 1;\n        }\n        return births;\n    }\n\n    /**\n     * A rabbit can breed if it has reached the breeding age.\n     * @return true if the rabbit can breed, false otherwise.\n     */\n    private boolean canBreed()\n    {\n        return age >= BREEDING_AGE;\n    }\n}\n","position":{"x":358.1774458830756,"y":-152.254032792082}},{"name":"Randomizer","content":"import java.util.Random;\n\n/**\n * Provide control over the randomization of the simulation. By using the shared, fixed-seed \n * randomizer, repeated runs will perform exactly the same (which helps with testing). Set \n * 'useShared' to false to get different random behaviour every time.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class Randomizer\n{\n    // The default seed for control of randomization.\n    private static final int SEED = 1111;\n    // A shared Random object, if required.\n    private static final Random rand = new Random(SEED);\n    // Determine whether a shared random generator is to be provided.\n    private static final boolean useShared = true;\n\n    /**\n     * Constructor for objects of class Randomizer\n     */\n    public Randomizer()\n    {\n    }\n\n    /**\n     * Provide a random generator.\n     * @return A random object.\n     */\n    public static Random getRandom()\n    {\n        if(useShared) {\n            return rand;\n        }\n        else {\n            return new Random();\n        }\n    }\n    \n    /**\n     * Reset the randomization.\n     * This will have no effect if randomization is not through\n     * a shared Random generator.\n     */\n    public static void reset()\n    {\n        if(useShared) {\n            rand.setSeed(SEED);\n        }\n    }\n}\n","position":{"x":750.2686638052943,"y":-70.23556139872815}},{"name":"Simulator","content":"import java.util.Random;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.awt.Color;\n\n/**\n * A simple predator-prey simulator, based on a rectangular field\n * containing rabbits and foxes.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.03.18\n */\npublic class Simulator\n{\n    // Constants representing configuration information for the simulation.\n    // The default width for the grid.\n    private static final int DEFAULT_WIDTH = 120;\n    // The default depth of the grid.\n    private static final int DEFAULT_DEPTH = 80;\n    // The probability that a fox will be created in any given grid position.\n    private static final double FOX_CREATION_PROBABILITY = 0.02;\n    // The probability that a rabbit will be created in any given grid position.\n    private static final double RABBIT_CREATION_PROBABILITY = 0.08;    \n\n    // List of animals in the field.\n    private List<Animal> animals;\n    // The current state of the field.\n    private Field field;\n    // The current step of the simulation.\n    private int step;\n    // A graphical view of the simulation.\n    private List<SimulatorView> views;\n    \n    /**\n     * Construct a simulation field with default size.\n     */\n    public Simulator()\n    {\n        this(DEFAULT_DEPTH, DEFAULT_WIDTH);\n    }\n    \n    /**\n     * Create a simulation field with the given size.\n     * @param depth Depth of the field. Must be greater than zero.\n     * @param width Width of the field. Must be greater than zero.\n     */\n    public Simulator(int depth, int width)\n    {\n        if(width <= 0 || depth <= 0) {\n            System.out.println(\"The dimensions must be greater than zero.\");\n            System.out.println(\"Using default values.\");\n            depth = DEFAULT_DEPTH;\n            width = DEFAULT_WIDTH;\n        }\n        \n        animals = new ArrayList<>();\n        field = new Field(depth, width);\n\n        views = new ArrayList<>();\n        \n        SimulatorView view = new GridView(depth, width);\n        view.setColor(Rabbit.class, Color.ORANGE);\n        view.setColor(Fox.class, Color.BLUE);\n        views.add(view);\n        \n        view = new GraphView(500, 150, 500);\n        view.setColor(Rabbit.class, Color.BLACK);\n        view.setColor(Fox.class, Color.RED);\n        views.add(view);\n\n        // Setup a valid starting point.\n        reset();\n    }\n    \n    /**\n     * Run the simulation from its current state for a reasonably long period,\n     * (4000 steps).\n     */\n    public void runLongSimulation()\n    {\n        simulate(4000);\n    }\n    \n    /**\n     * Run the simulation from its current state for the given number of steps.\n     * Stop before the given number of steps if it ceases to be viable.\n     * @param numSteps The number of steps to run for.\n     */\n    public void simulate(int numSteps)\n    {\n        for(int step = 1; step <= numSteps && views.get(0).isViable(field); step++) {\n            simulateOneStep();\n            // delay(60);   // uncomment this to run more slowly\n        }\n    }\n    \n    /**\n     * Run the simulation from its current state for a single step.\n     * Iterate over the whole field updating the state of each\n     * fox and rabbit.\n     */\n    public void simulateOneStep()\n    {\n        step++;\n\n        // Provide space for newborn animals.\n        List<Animal> newAnimals = new ArrayList<>();        \n        // Let all rabbits act.\n        for(Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {\n            Animal animal = it.next();\n            animal.act(newAnimals);\n            if(! animal.isAlive()) {\n                it.remove();\n            }\n        }\n               \n        // Add the newly born foxes and rabbits to the main lists.\n        animals.addAll(newAnimals);\n\n        updateViews();\n    }\n        \n    /**\n     * Reset the simulation to a starting position.\n     */\n    public void reset()\n    {\n        step = 0;\n        animals.clear();\n        for (SimulatorView view : views) {\n            view.reset();\n        }\n\n        populate();\n        updateViews();\n    }\n    \n    /**\n     * Update all existing views.\n     */\n    private void updateViews()\n    {\n        for (SimulatorView view : views) {\n            view.showStatus(step, field);\n        }\n    }\n    \n    /**\n     * Randomly populate the field with foxes and rabbits.\n     */\n    private void populate()\n    {\n        Random rand = Randomizer.getRandom();\n        field.clear();\n        for(int row = 0; row < field.getDepth(); row++) {\n            for(int col = 0; col < field.getWidth(); col++) {\n                if(rand.nextDouble() <= FOX_CREATION_PROBABILITY) {\n                    Location location = new Location(row, col);\n                    Fox fox = new Fox(true, field, location);\n                    animals.add(fox);\n                }\n                else if(rand.nextDouble() <= RABBIT_CREATION_PROBABILITY) {\n                    Location location = new Location(row, col);\n                    Rabbit rabbit = new Rabbit(true, field, location);\n                    animals.add(rabbit);\n                }\n                // else leave the location empty.\n            }\n        }\n    }\n    \n    /**\n     * Pause for a given time.\n     * @param millisec  The time to pause for, in milliseconds\n     */\n    private void delay(int millisec)\n    {\n        try {\n            Thread.sleep(millisec);\n        }\n        catch (InterruptedException ie) {\n            // wake up\n        }\n    }\n}\n","position":{"x":-28.753786186118184,"y":-87.3704407094472}},{"name":"SimulatorView","content":"import java.awt.Color;\n\n/**\n * A graphical view of the simulation grid. This interface defines all possible different\n * views.\n * \n * @author Michael Kölling and David J. Barnes\n * @version 2016.03.18\n */\npublic interface SimulatorView\n{\n    /**\n     * Define a color to be used for a given class of animal.\n     * @param animalClass The animal's Class object.\n     * @param color The color to be used for the given class.\n     */\n    void setColor(Class<?> animalClass, Color color);\n\n    /**\n     * Determine whether the simulation should continue to run.\n     * @return true If there is more than one species alive.\n     */\n    boolean isViable(Field field);\n\n    /**\n     * Show the current status of the field.\n     * @param step Which iteration step it is.\n     * @param field The field whose status is to be displayed.\n     */\n    void showStatus(int step, Field field);\n    \n    /**\n     * Prepare for a new run.\n     */\n    void reset();\n}","position":{"x":325.2422542983273,"y":-429.7036312426494}}]}