{"title":"World of Zuul","summary":"BlueJ Chapter 8","description":"`new Game()`\n\n`play()`\n\n> `go east`","lastUpdated":1728738956975,"output":"terminal","classes":[{"name":"Command","content":"/**\n * This class is part of the \"World of Zuul\" application. \n * \"World of Zuul\" is a very simple, text based adventure game.  \n *\n * This class holds information about a command that was issued by the user.\n * A command currently consists of two parts: a CommandWord and a string\n * (for example, if the command was \"take map\", then the two parts\n * are TAKE and \"map\").\n * \n * The way this is used is: Commands are already checked for being valid\n * command words. If the user entered an invalid command (a word that is not\n * known) then the CommandWord is UNKNOWN.\n *\n * If the command had only one word, then the second word is <null>.\n * \n * @author  Michael Kölling and David J. Barnes\n * @version 2016.02.29\n */\n\npublic class Command\n{\n    private CommandWord commandWord;\n    private String secondWord;\n\n    /**\n     * Create a command object. First and second words must be supplied, but\n     * the second may be null.\n     * @param commandWord The CommandWord. UNKNOWN if the command word\n     *                  was not recognised.\n     * @param secondWord The second word of the command. May be null.\n     */\n    public Command(CommandWord commandWord, String secondWord)\n    {\n        this.commandWord = commandWord;\n        this.secondWord = secondWord;\n    }\n\n    /**\n     * Return the command word (the first word) of this command.\n     * @return The command word.\n     */\n    public CommandWord getCommandWord()\n    {\n        return commandWord;\n    }\n\n    /**\n     * @return The second word of this command. Returns null if there was no\n     * second word.\n     */\n    public String getSecondWord()\n    {\n        return secondWord;\n    }\n\n    /**\n     * @return true if this command was not understood.\n     */\n    public boolean isUnknown()\n    {\n        return (commandWord == CommandWord.UNKNOWN);\n    }\n\n    /**\n     * @return true if the command has a second word.\n     */\n    public boolean hasSecondWord()\n    {\n        return (secondWord != null);\n    }\n}\n\n","position":{"x":98.92357205552219,"y":111.73167867398534}},{"name":"CommandWord","content":"/**\n * Representations for all the valid command words for the game\n * along with a string in a particular language.\n * \n * @author  Michael Kölling and David J. Barnes\n * @version 2016.02.29\n */\npublic enum CommandWord\n{\n    // A value for each command word along with its\n    // corresponding user interface string.\n    GO(\"go\"), QUIT(\"quit\"), HELP(\"help\"), UNKNOWN(\"?\");\n    \n    // The command string.\n    private String commandString;\n    \n    /**\n     * Initialise with the corresponding command string.\n     * @param commandString The command string.\n     */\n    CommandWord(String commandString)\n    {\n        this.commandString = commandString;\n    }\n    \n    /**\n     * @return The command word as a string.\n     */\n    public String toString()\n    {\n        return commandString;\n    }\n}\n","position":{"x":261.9593025542901,"y":5.769562325743351}},{"name":"CommandWords","content":"import java.util.HashMap;\n\n/**\n * This class is part of the \"World of Zuul\" application. \n * \"World of Zuul\" is a very simple, text based adventure game.\n * \n * This class holds an enumeration of all command words known to the game.\n * It is used to recognise commands as they are typed in.\n *\n * @author  Michael Kölling and David J. Barnes\n * @version 2016.02.29\n */\n\npublic class CommandWords\n{\n    // A mapping between a command word and the CommandWord\n    // associated with it.\n    private HashMap<String, CommandWord> validCommands;\n\n    /**\n     * Constructor - initialise the command words.\n     */\n    public CommandWords()\n    {\n        validCommands = new HashMap<>();\n        for(CommandWord command : CommandWord.values()) {\n            if(command != CommandWord.UNKNOWN) {\n                validCommands.put(command.toString(), command);\n            }\n        }\n    }\n\n    /**\n     * Find the CommandWord associated with a command word.\n     * @param commandWord The word to look up.\n     * @return The CommandWord correspondng to commandWord, or UNKNOWN\n     *         if it is not a valid command word.\n     */\n    public CommandWord getCommandWord(String commandWord)\n    {\n        CommandWord command = validCommands.get(commandWord);\n        if(command != null) {\n            return command;\n        }\n        else {\n            return CommandWord.UNKNOWN;\n        }\n    }\n    \n    /**\n     * Check whether a given String is a valid command word. \n     * @return true if it is, false if it isn't.\n     */\n    public boolean isCommand(String aString)\n    {\n        return validCommands.containsKey(aString);\n    }\n\n    /**\n     * Print all valid commands to System.out.\n     */\n    public void showAll() \n    {\n        for(String command : validCommands.keySet()) {\n            System.out.print(command + \"  \");\n        }\n        System.out.println();\n    }\n}\n","position":{"x":77.84125184539204,"y":-91.2565281932207}},{"name":"Game","content":"/**\n *  This class is the main class of the \"World of Zuul\" application. \n *  \"World of Zuul\" is a very simple, text based adventure game.  Users \n *  can walk around some scenery. That's all. It should really be extended \n *  to make it more interesting!\n * \n *  To play this game, create an instance of this class and call the \"play\"\n *  method.\n * \n *  This main class creates and initialises all the others: it creates all\n *  rooms, creates the parser and starts the game.  It also evaluates and\n *  executes the commands that the parser returns.\n * \n * @author  Michael Kölling and David J. Barnes\n * @version 2016.02.29\n */\n\npublic class Game \n{\n    private Parser parser;\n    private Room currentRoom;\n        \n    /**\n     * Create the game and initialise its internal map.\n     */\n    public Game() \n    {\n        createRooms();\n        parser = new Parser();\n    }\n\n    /**\n     * Create all the rooms and link their exits together.\n     */\n    private void createRooms()\n    {\n        Room outside, theater, pub, lab, office;\n      \n        // create the rooms\n        outside = new Room(\"outside the main entrance of the university\");\n        theater = new Room(\"in a lecture theater\");\n        pub = new Room(\"in the campus pub\");\n        lab = new Room(\"in a computing lab\");\n        office = new Room(\"in the computing admin office\");\n        \n        // initialise room exits\n        outside.setExit(\"east\", theater);\n        outside.setExit(\"south\", lab);\n        outside.setExit(\"west\", pub);\n\n        theater.setExit(\"west\", outside);\n\n        pub.setExit(\"east\", outside);\n\n        lab.setExit(\"north\", outside);\n        lab.setExit(\"east\", office);\n\n        office.setExit(\"west\", lab);\n\n        currentRoom = outside;  // start game outside\n    }\n\n    /**\n     *  Main play routine.  Loops until end of play.\n     */\n    public void play() \n    {            \n        printWelcome();\n\n        // Enter the main command loop.  Here we repeatedly read commands and\n        // execute them until the game is over.\n                \n        boolean finished = false;\n        while (! finished) {\n            Command command = parser.getCommand();\n            finished = processCommand(command);\n        }\n        System.out.println(\"Thank you for playing.  Good bye.\");\n    }\n\n    /**\n     * Print out the opening message for the player.\n     */\n    private void printWelcome()\n    {\n        System.out.println();\n        System.out.println(\"Welcome to the World of Zuul!\");\n        System.out.println(\"World of Zuul is a new, incredibly boring adventure game.\");\n        System.out.println(\"Type '\" + CommandWord.HELP + \"' if you need help.\");\n        System.out.println();\n        System.out.println(currentRoom.getLongDescription());\n    }\n\n    /**\n     * Given a command, process (that is: execute) the command.\n     * @param command The command to be processed.\n     * @return true If the command ends the game, false otherwise.\n     */\n    private boolean processCommand(Command command) \n    {\n        boolean wantToQuit = false;\n\n        CommandWord commandWord = command.getCommandWord();\n\n        switch (commandWord) {\n            case UNKNOWN:\n                System.out.println(\"I don't know what you mean...\");\n                break;\n\n            case HELP:\n                printHelp();\n                break;\n\n            case GO:\n                goRoom(command);\n                break;\n\n            case QUIT:\n                wantToQuit = quit(command);\n                break;\n        }\n        return wantToQuit;\n    }\n\n    // implementations of user commands:\n\n    /**\n     * Print out some help information.\n     * Here we print some stupid, cryptic message and a list of the \n     * command words.\n     */\n    private void printHelp() \n    {\n        System.out.println(\"You are lost. You are alone. You wander\");\n        System.out.println(\"around at the university.\");\n        System.out.println();\n        System.out.println(\"Your command words are:\");\n        parser.showCommands();\n    }\n\n    /** \n     * Try to go in one direction. If there is an exit, enter the new\n     * room, otherwise print an error message.\n     */\n    private void goRoom(Command command) \n    {\n        if(!command.hasSecondWord()) {\n            // if there is no second word, we don't know where to go...\n            System.out.println(\"Go where?\");\n            return;\n        }\n\n        String direction = command.getSecondWord();\n\n        // Try to leave current room.\n        Room nextRoom = currentRoom.getExit(direction);\n\n        if (nextRoom == null) {\n            System.out.println(\"There is no door!\");\n        }\n        else {\n            currentRoom = nextRoom;\n            System.out.println(currentRoom.getLongDescription());\n        }\n    }\n\n    /** \n     * \"Quit\" was entered. Check the rest of the command to see\n     * whether we really quit the game.\n     * @return true, if this command quits the game, false otherwise.\n     */\n    private boolean quit(Command command) \n    {\n        if(command.hasSecondWord()) {\n            System.out.println(\"Quit what?\");\n            return false;\n        }\n        else {\n            return true;  // signal that we want to quit\n        }\n    }\n}\n","position":{"x":-304.5274717699556,"y":73.29232030308495}},{"name":"Parser","content":"import java.util.Scanner;\n\n/**\n * This class is part of the \"World of Zuul\" application. \n * \"World of Zuul\" is a very simple, text based adventure game.  \n * \n * This parser reads user input and tries to interpret it as an \"Adventure\"\n * command. Every time it is called it reads a line from the terminal and\n * tries to interpret the line as a two-word command. It returns the command\n * as an object of class Command.\n *\n * The parser has a set of known command words. It checks user input against\n * the known commands, and if the input is not one of the known commands, it\n * returns a command object that is marked as an unknown command.\n * \n * @author  Michael Kölling and David J. Barnes\n * @version 2016.02.29\n */\npublic class Parser \n{\n    private CommandWords commands;  // holds all valid command words\n    private Scanner reader;         // source of command input\n\n    /**\n     * Create a parser to read from the terminal window.\n     */\n    public Parser() \n    {\n        commands = new CommandWords();\n        reader = new Scanner(System.in);\n    }\n\n    /**\n     * @return The next command from the user.\n     */\n    public Command getCommand() \n    {\n        String inputLine;   // will hold the full input line\n        String word1 = null;\n        String word2 = null;\n\n        System.out.print(\"> \");     // print prompt\n\n        inputLine = reader.nextLine();\n\n        // Find up to two words on the line.\n        Scanner tokenizer = new Scanner(inputLine);\n        if(tokenizer.hasNext()) {\n            word1 = tokenizer.next();      // get first word\n            if(tokenizer.hasNext()) {\n                word2 = tokenizer.next();      // get second word\n                // note: we just ignore the rest of the input line.\n            }\n        }\n\n        return new Command(commands.getCommandWord(word1), word2);\n    }\n\n    /**\n     * Print out a list of valid command words.\n     */\n    public void showCommands()\n    {\n        commands.showAll();\n    }\n}\n","position":{"x":-159.2772509863866,"y":-84.30402523011134}},{"name":"Room","content":"import java.util.Set;\nimport java.util.HashMap;\nimport java.util.Iterator;\n\n/**\n * Class Room - a room in an adventure game.\n *\n * This class is part of the \"World of Zuul\" application. \n * \"World of Zuul\" is a very simple, text based adventure game.  \n *\n * A \"Room\" represents one location in the scenery of the game.  It is \n * connected to other rooms via exits.  For each existing exit, the room \n * stores a reference to the neighboring room.\n * \n * @author  Michael Kölling and David J. Barnes\n * @version 2016.02.29\n */\n\npublic class Room \n{\n    private String description;\n    private HashMap<String, Room> exits;        // stores exits of this room.\n\n    /**\n     * Create a room described \"description\". Initially, it has\n     * no exits. \"description\" is something like \"a kitchen\" or\n     * \"an open court yard\".\n     * @param description The room's description.\n     */\n    public Room(String description) \n    {\n        this.description = description;\n        exits = new HashMap<>();\n    }\n\n    /**\n     * Define an exit from this room.\n     * @param direction The direction of the exit.\n     * @param neighbor  The room to which the exit leads.\n     */\n    public void setExit(String direction, Room neighbor) \n    {\n        exits.put(direction, neighbor);\n    }\n\n    /**\n     * @return The short description of the room\n     * (the one that was defined in the constructor).\n     */\n    public String getShortDescription()\n    {\n        return description;\n    }\n\n    /**\n     * Return a description of the room in the form:\n     *     You are in the kitchen.\n     *     Exits: north west\n     * @return A long description of this room\n     */\n    public String getLongDescription()\n    {\n        return \"You are \" + description + \".\\n\" + getExitString();\n    }\n\n    /**\n     * Return a string describing the room's exits, for example\n     * \"Exits: north west\".\n     * @return Details of the room's exits.\n     */\n    private String getExitString()\n    {\n        String returnString = \"Exits:\";\n        Set<String> keys = exits.keySet();\n        for(String exit : keys) {\n            returnString += \" \" + exit;\n        }\n        return returnString;\n    }\n\n    /**\n     * Return the room that is reached if we go from this room in direction\n     * \"direction\". If there is no room in that direction, return null.\n     * @param direction The exit's direction.\n     * @return The room in the given direction.\n     */\n    public Room getExit(String direction) \n    {\n        return exits.get(direction);\n    }\n}\n\n","position":{"x":-102.15660149156301,"y":186.99591183493013}}]}