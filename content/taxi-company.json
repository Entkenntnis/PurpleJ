{"title":"Taxi Company","summary":"BlueJ Chapter 16","description":"`new Simulation()`\n\n`step()` or `run()` ","lastUpdated":1728770309199,"output":"display","classes":[{"name":"Actor","content":"/**\n * An actor in the taxi-company simulation.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic interface Actor\n{\n    /**\n     * Implement the actor's behavior.\n     */\n    public void act();\n}\n","position":{"x":465.12021866506996,"y":-54.478320238707425}},{"name":"City","content":"import java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n    \n/**\n * A collection of items in the city.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class City\n{\n    private List<Item> items;\n    private int width;\n    private int height;\n    \n    private static final int DEFAULT_WIDTH = 35;\n    private static final int DEFAULT_HEIGHT = 35;\n\n    /**\n     * Constructor for objects of class City\n     * @param width The city's width.\n     * @param height The city's height.\n     */\n    public City(int width, int height)\n    {\n        if(width < 1) {\n            throw new IllegalArgumentException(\n                        \"Width must be positive: \" +\n                        width);\n        }\n        if(height < 1) {\n            throw new IllegalArgumentException(\n                        \"Height must be positive: \" +\n                        height);\n        }\n        this.width = width;\n        this.height = height;\n        items = new LinkedList<>();\n    }\n    \n    /**\n     * Create a city of default size.\n     */\n    public City()\n    {\n        this(DEFAULT_WIDTH, DEFAULT_HEIGHT);\n    }\n    \n    /**\n     * @return An iterator over the items.\n     */\n    public Iterator<Item> getItems()\n    {\n        return items.iterator();\n    }\n\n    /**\n     * Add the given item to the city's collection.\n     * @param item The item to be added.\n     */\n    public void addItem(Item item)\n    {\n        if(items.contains(item)) {\n            throw new IllegalArgumentException(\n                item + \" already recorded in the city.\");\n        }\n        items.add(item);\n    }\n\n    /**\n     * Remove the given item from the city's collection.\n     * @param item The item to be removed.\n     */\n    public void removeItem(Item item)\n    {\n        if(!items.remove(item)) {\n            throw new IllegalArgumentException(\n                        item + \" is not in the city.\");\n        }\n    }\n        \n    /**\n     * @return A string representation of the city.\n     */\n    public String toString()\n    {\n        return \"City size \" + width + \" by \" + height;\n    }\n    \n    /**\n     * @return The width.\n     */\n    public int getWidth()\n    {\n        return width;\n    }\n    \n    /**\n     * @return The height.\n     */\n    public int getHeight()\n    {\n        return height;\n    }\n}\n","position":{"x":433.66128046783456,"y":95.51114845381508}},{"name":"CityGUI","content":"import java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.awt.*;\nimport javax.swing.*;\n    \n/**\n * Provide a view of the vehicles and passengers in the city.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class CityGUI extends JFrame implements Actor\n{\n    // The dimensions of the GUI.\n    public static final int CITY_VIEW_WIDTH = 600;\n    public static final int CITY_VIEW_HEIGHT = 600;\n    private City city;\n    private CityView cityView;\n    \n    /**\n     * Constructor for objects of class CityGUI\n     * @param city The city whose state is to be displayed.\n     */\n    public CityGUI(City city)\n    {\n        this.city = city;\n        cityView = new CityView(city.getWidth(), city.getHeight());\n        getContentPane().add(cityView);\n        setTitle(\"Taxiville\");\n        setSize(CITY_VIEW_WIDTH, CITY_VIEW_HEIGHT);\n        setVisible(true);\n        cityView.preparePaint();\n        cityView.repaint();    \n    }\n    \n    /**\n     * Display the current state of the city.\n     */\n    public void act()\n    {\n        cityView.preparePaint();\n        Iterator<Item> items = city.getItems();\n        while(items.hasNext()) {\n            Item item = items.next();\n            if(item instanceof DrawableItem){\n                DrawableItem drawable = (DrawableItem) item;\n                Location location = item.getLocation();\n                cityView.drawImage(location.getX(), location.getY(), drawable.getImage());\n            }\n        }\n        cityView.repaint();    \n    }\n    \n    /**\n     * Provide a graphical view of a rectangular city. This is \n     * a nested class (a class defined inside a class) which\n     * defines a custom component for the user interface. This\n     * component displays the city.\n     * This is rather advanced GUI stuff - you can ignore this \n     * for your project if you like.\n     */\n    private class CityView extends JPanel\n    {\n        private final int VIEW_SCALING_FACTOR = 6;\n\n        private int cityWidth, cityHeight;\n        private int xScale, yScale;\n        private Dimension size;\n        private Graphics g;\n        private Image cityImage;\n\n        /**\n         * Create a new CityView component.\n         */\n        public CityView(int width, int height)\n        {\n            cityWidth = width;\n            cityHeight = height;\n            setBackground(Color.white);\n            size = new Dimension(0, 0);\n        }\n\n        /**\n         * Tell the GUI manager how big we would like to be.\n         */\n        public Dimension getPreferredSize()\n        {\n            return new Dimension(cityWidth * VIEW_SCALING_FACTOR,\n                                 cityHeight * VIEW_SCALING_FACTOR);\n        }\n        \n        /**\n         * Prepare for a new round of painting. Since the component\n         * may be resized, compute the scaling factor again.\n         */\n        public void preparePaint()\n        {\n            if(!size.equals(getSize())) {  // if the size has changed...\n                size = getSize();\n                cityImage = cityView.createImage(size.width, size.height);\n                g = cityImage.getGraphics();\n\n                xScale = size.width / cityWidth;\n                if(xScale < 1) {\n                    xScale = VIEW_SCALING_FACTOR;\n                }\n                yScale = size.height / cityHeight;\n                if(yScale < 1) {\n                    yScale = VIEW_SCALING_FACTOR;\n                }\n            }\n            g.setColor(Color.white);\n            g.fillRect(0, 0, size.width, size.height);\n            g.setColor(Color.gray);\n            for(int i = 0, x = 0; x < size.width; i++, x = i * xScale) {\n                g.drawLine(x, 0, x, size.height - 1);\n            }\n            for(int i = 0, y = 0; y < size.height; i++, y = i * yScale) {\n                g.drawLine(0, y, size.width - 1, y);\n            }\n        }\n        \n        /**\n         * Draw the image for a particular item.\n         */\n        public void drawImage(int x, int y, Image image)\n        {\n            g.drawImage(image, x * xScale + 1, y * yScale + 1,\n                        xScale - 1, yScale - 1, this);\n        }\n\n        /**\n         * The city view component needs to be redisplayed. Copy the\n         * internal image to screen.\n         */\n        public void paintComponent(Graphics g)\n        {\n            if(cityImage != null) {\n                Dimension currentSize = getSize();\n                if(size.equals(currentSize)) {\n                    g.drawImage(cityImage, 0, 0, null);\n                }\n                else {\n                    // Rescale the previous image.\n                    g.drawImage(cityImage, 0, 0, currentSize.width, currentSize.height, null);\n                }\n            }\n        }\n    }\n}\n","position":{"x":221.10130623200433,"y":-32.95021175126608}},{"name":"DrawableItem","content":"import java.awt.Image;\n    \n/**\n * An item that is able to return an image of itself.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\n\npublic interface DrawableItem extends Item\n{\n    public Image getImage();\n}\n","position":{"x":692.6396071944195,"y":254.59190944321273}},{"name":"Item","content":"/**\n * An item in the city.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\n\npublic interface Item\n{\n    public Location getLocation();\n}\n","position":{"x":643.4506075812114,"y":-176.53528901409268}},{"name":"Location","content":"/**\n * Model a location in a city.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class Location\n{\n    private int x;\n    private int y;\n\n    /**\n     * Model a location in the city.\n     * @param x The x coordinate. Must be positive.\n     * @param y The y coordinate. Must be positive.\n     * @throws IllegalArgumentException If a coordinate is negative.\n     */\n    public Location(int x, int y)\n    {\n        if(x < 0) {\n            throw new IllegalArgumentException(\n                        \"Negative x-coordinate: \" + x);\n        }\n        if(y < 0) {\n            throw new IllegalArgumentException(\n                        \"Negative y-coordinate: \" + y);\n        }\n        this.x = x;\n        this.y = y;\n    }\n    \n    /**\n     * Generate the next location to visit in order to\n     * reach the destination.\n     * @param destination Where we want to get to.\n     * @return A location in a direct line from this to\n     *         destination.\n     */\n    public Location nextLocation(Location destination)\n    {\n        int destX = destination.getX();\n        int destY = destination.getY();\n        int offsetX = x < destX ? 1 : x > destX ? -1 : 0;\n        int offsetY = y < destY ? 1 : y > destY ? -1 : 0;\n        if(offsetX != 0 || offsetY != 0) {\n            return new Location(x + offsetX, y + offsetY);\n        }\n        else {\n            return destination;\n        }\n    }\n\n    /**\n     * Determine the number of movements required to get\n     * from here to the destination.\n     * @param destination The required destination.\n     * @return The number of movement steps.\n     */\n    public int distance(Location destination)\n    {\n        int xDist = Math.abs(destination.getX() - x);\n        int yDist = Math.abs(destination.getY() - y);\n        return Math.max(xDist, yDist);\n    }\n    \n    /**\n     * Implement content equality for locations.\n     * @return true if this location matches the other,\n     *         false otherwise.\n     */\n    public boolean equals(Object other)\n    {\n        if(other instanceof Location) {\n            Location otherLocation = (Location) other;\n            return x == otherLocation.getX() &&\n                   y == otherLocation.getY();\n        }\n        else {\n            return false;\n        }\n    }\n    \n    /**\n     * @return A representation of the location.\n     */\n    public String toString()\n    {\n        return \"location \" + x + \",\" + y;\n    }\n\n    /**\n     * Use the top 16 bits for the y value and the bottom for the x.\n     * Except for very big grids, this should give a unique hash code\n     * for each (x, y) pair.\n     * @return A hashcode for the location.\n     */\n    public int hashCode()\n    {\n        return (y << 16) + x;\n    }\n\n    /**\n     * @return The x coordinate.\n     */\n    public int getX()\n    {\n        return x;\n    }\n\n    /**\n     * @return The y coordinate.\n     */\n    public int getY()\n    {\n        return y;\n    }\n}\n","position":{"x":801.5616673891263,"y":-101.45211907472128}},{"name":"MissingPassengerException","content":"\n/**\n * Indicate that there was no passenger at a pickup point.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class MissingPassengerException extends RuntimeException\n{\n    private Vehicle vehicle;\n    /**\n     * Constructor for objects of class MissingPassengerException.\n     * @param vehicle The vehicle expecting a passenger.\n     */\n    public MissingPassengerException(Vehicle vehicle)\n    {\n        super(\"Missing passenger at pickup location.\");\n    }\n\n    /**\n     * @return The vehicle for which there was no passenger.\n     */\n    public Vehicle getVehicle()\n    {\n        return vehicle;\n    }\n}\n","position":{"x":689.9083101814794,"y":77.9667586090313}},{"name":"Passenger","content":"import java.awt.Image;\nimport javax.swing.ImageIcon;\n\n/**\n * Model a passenger wishing to get from one\n * location to another.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class Passenger implements DrawableItem\n{\n    private Location pickup;\n    private Location destination;\n    private Image image;\n\n    /**\n     * Constructor for objects of class Passenger\n     * @param pickup The pickup location, must not be null.\n     * @param destination The destination location, must not be null.\n     * @throws NullPointerException If either location is null.\n     */\n    public Passenger(Location pickup, Location destination)\n    {\n        if(pickup == null) {\n            throw new NullPointerException(\"Pickup location\");\n        }\n        if(destination == null) {\n            throw new NullPointerException(\"Destination location\");\n        }\n        this.pickup = pickup;\n        this.destination = destination;\n        // Load the image used to represent a person.\n        image = new ImageIcon(\"/app/tmp_assets/person.jpg\").getImage();\n    }\n    \n    /**\n     * @return A string representation of this person.\n     */\n    public String toString()\n    {\n        return \"Passenger travelling from \" +\n               pickup + \" to \" + destination;\n    }\n\n    /**\n     * @return The image to be displayed on a GUI.\n     */\n    public Image getImage()\n    {\n        return image;\n    }\n    \n    /**\n     * @return The passenger's pickup location.\n     */\n    public Location getLocation()\n    {\n        return pickup;\n    }\n\n    /**\n     * @return The pickup location.\n     */\n    public Location getPickupLocation()\n    {\n        return pickup;\n    }\n    \n    /**\n     * @return The destination location.\n     */\n    public Location getDestination()\n    {\n        return destination;\n    }\n}\n","position":{"x":236.66924895016984,"y":-220.8725821277693}},{"name":"PassengerSource","content":"import java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Random;\n\n/**\n * Periodically generate passengers.\n * Keep track of the number of passengers for whom\n * a vehicle cannot be found.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class PassengerSource implements Actor\n{\n    private City city;\n    private TaxiCompany company;\n    private Random rand;\n    private static final double CREATION_PROBABILITY = 0.06;\n    private int missedPickups;\n\n    /**\n     * Constructor for objects of class PassengerSource.\n     * @param city The city. Must not be null.\n     * @param company The company to be used. Must not be null.\n     * @throws NullPointerException if city or company is null.\n     */\n    public PassengerSource(City city, TaxiCompany company)\n    {\n        if(city == null) {\n            throw new NullPointerException(\"city\");\n        }\n        if(company == null) {\n            throw new NullPointerException(\"company\");\n        }\n        this.city = city;\n        this.company = company;\n        // Use a fixed random seed for repeatable effects.\n        // Change this to produce more random effects.\n        rand = new Random(12345);\n        missedPickups = 0;\n    }\n\n    /**\n     * Randomly generate a new passenger.\n     * Keep a count of missed pickups.\n     */\n    public void act()\n    {\n        if(rand.nextDouble() <= CREATION_PROBABILITY) {\n            Passenger passenger = createPassenger();\n            if(company.requestPickup(passenger)) {\n                city.addItem(passenger);\n            }\n            else {\n                missedPickups++;\n            }\n        }\n    }\n\n    /**\n     * @return The number of passengers for whom a pickup\n     *         could not be found.\n     */\n    public int getMissedPickups()\n    {\n        return missedPickups;\n    }\n\n    /**\n     * Create a new passenger with distinct pickup and\n     * destination locations.\n     * @return The created passenger.\n     */\n    private Passenger createPassenger()\n    {\n        int cityWidth = city.getWidth();\n        int cityHeight = city.getHeight();\n\n        Location pickupLocation =\n                    new Location(rand.nextInt(cityWidth),\n                                 rand.nextInt(cityHeight));\n        Location destination;\n        do{\n            destination =\n                    new Location(rand.nextInt(cityWidth),\n                                 rand.nextInt(cityHeight));\n        } while(pickupLocation.equals(destination));\n        return new Passenger(pickupLocation, destination);\n    }\n}\n","position":{"x":65.81260099243997,"y":-150.1354386991723}},{"name":"Shuttle","content":"import java.util.List;\nimport java.util.LinkedList;\n    \n/**\n * A shuttle is able to carry multiple passengers.\n * This implementation is non-functional.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class Shuttle extends Vehicle\n{\n    // The list of destinations for the shuttle.\n    private List<Location> destinations;\n    // The list of passengers on the shuttle.\n    private List<Passenger> passengers;\n\n    /**\n     * Constructor for objects of class Shuttle\n     * @param company The taxi company. Must not be null.\n     * @param location The vehicle's starting point. Must not be null.\n     * @throws NullPointerException If company or location is null.\n     */\n    public Shuttle(TaxiCompany company, Location location)\n    {\n        super(company, location);\n        destinations = new LinkedList<>();\n        passengers = new LinkedList<>();\n    }\n\n    /**\n     * Carry out a shuttle's actions.\n     */\n    public void act()\n    {\n    }\n\n    /**\n     * Is the shuttle free?\n     * @return Whether or not this vehicle is free.\n     */\n    public boolean isFree()\n    {\n        return true;\n    }\n    \n    /**\n     * Receive a pickup location.\n     * @param location The pickup location.\n     */\n    public void setPickupLocation(Location location)\n    {\n        destinations.add(location);\n        chooseTargetLocation();\n    }\n    \n    /**\n     * Receive a passenger.\n     * Add their destination to the list.\n     * @param passenger The passenger.\n     */\n    public void pickup(Passenger passenger)\n    {\n        passengers.add(passenger);\n        destinations.add(passenger.getDestination());\n        chooseTargetLocation();\n    }\n\n    /**\n     * Decide where to go next, based on the list of\n     * possible destinations.\n     */\n    private void chooseTargetLocation()\n    {\n    }\n\n    /**\n     * Offload a passenger whose destination is the\n     * current location.\n     */\n    public void offloadPassenger()\n    {\n    }\n}\n","position":{"x":214.11195094990194,"y":116.48803818406479}},{"name":"Simulation","content":"import java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\n\n/**\n * Run the simulation by asking a collection of actors to act.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class Simulation\n{\n    private List<Actor> actors;\n    private int step;\n\n    /**\n     * Create the initial set of actors for the simulation.\n     */\n    public Simulation()\n    {\n        actors = new LinkedList<>();\n        step = 0;\n        City city = new City();\n        TaxiCompany company = new TaxiCompany(city);\n        PassengerSource source = new PassengerSource(city, company);\n        \n        actors.addAll(company.getVehicles());\n        actors.add(source);\n        actors.add(new CityGUI(city));\n    }\n    \n    /**\n     * Run the simulation for a fixed number of steps.\n     * Pause after each step to allow the GUI to keep up.\n     */\n    public void run()\n    {\n        for(int i = 0; i < 500; i++){\n            step++;\n            step();\n            wait(100);\n        }\n    }\n\n    /**\n     * Take a single step of the simulation.\n     */\n    public void step()\n    {\n        for(Actor actor : actors) {\n            actor.act();\n        }\n    }\n    \n    /**\n     * Wait for a specified number of milliseconds before finishing.\n     * This provides an easy way to cause a small delay.\n     * @param milliseconds The number of milliseconds to wait.\n     */\n    private void wait(int milliseconds)\n    {\n        try\n        {\n            Thread.sleep(milliseconds);\n        } \n        catch (InterruptedException e)\n        {\n            // ignore the exception\n        }\n    }\n}\n","position":{"x":426.96869457277165,"y":-320.83995677402817}},{"name":"Taxi","content":"import java.awt.Image;\nimport javax.swing.ImageIcon;\n\n/**\n * A taxi is able to carry a single passenger.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class Taxi extends Vehicle implements DrawableItem\n{\n    private Passenger passenger;\n    // Maintain separate images for when the taxi is empty\n    // and full.\n    private Image emptyImage, passengerImage;\n    \n    /**\n     * Constructor for objects of class Taxi\n     * @param company The taxi company. Must not be null.\n     * @param location The vehicle's starting point. Must not be null.\n     * @throws NullPointerException If company or location is null.\n     */\n    public Taxi(TaxiCompany company, Location location)\n    {\n        super(company, location);\n    // Load the two images.\n        emptyImage = new ImageIcon(\n                                \"/app/tmp_assets/taxi.jpg\").getImage();\n\n        passengerImage = new ImageIcon(\n                                \"/app/tmp_assets/taxi+person.jpg\").getImage();\n    }\n    \n    /**\n     * Move towards the target location if we have one.\n     * Otherwise record that we are idle.\n     */\n    public void act()\n    {\n        Location target = getTargetLocation();\n        if(target != null) {\n            // Find where to move to next.\n            Location next = getLocation().nextLocation(target);\n            setLocation(next);\n            if(next.equals(target)) {\n                if(passenger != null) {\n                    notifyPassengerArrival(passenger);\n                    offloadPassenger();\n                }\n                else {\n                    notifyPickupArrival();\n                }\n            }\n        }\n        else {\n            incrementIdleCount();\n        }\n    }\n\n    /**\n     * Is the taxi free?\n     * @return Whether or not this taxi is free.\n     */\n    public boolean isFree()\n    {\n        return getTargetLocation() == null && passenger == null;\n    }\n    \n    /**\n     * Receive a pickup location. This becomes the\n     * target location.\n     * @param location The pickup location.\n     */\n    public void setPickupLocation(Location location)\n    {\n        setTargetLocation(location);\n    }\n    \n    /**\n     * Receive a passenger.\n     * Set their destination as the target location.\n     * @param passenger The passenger.\n     */\n    public void pickup(Passenger passenger)\n    {\n        this.passenger = passenger;\n        setTargetLocation(passenger.getDestination());\n    }\n\n    /**\n     * Offload the passenger.\n     */\n    public void offloadPassenger()\n    {\n        passenger = null;\n        clearTargetLocation();\n    }\n    \n    /**\n     * Return an image that describes our state:\n     * either empty or carrying a passenger.\n     */\n    public Image getImage()\n    {\n        if(passenger != null) {\n            return passengerImage;\n        }\n        else {\n            return emptyImage;\n        }\n    }\n\n    /**\n     * Return details of the taxi, such as where it is.\n     * @return A string representation of the taxi.\n     */\n    public String toString()\n    {\n        return \"Taxi at \" + getLocation();\n    }\n}\n","position":{"x":363.37374225432023,"y":242.13842767354936}},{"name":"TaxiCompany","content":"import java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Random;\n\n/**\n * Model the operation of a taxi company, operating different\n * types of vehicle. This version operates a only taxis.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic class TaxiCompany  \n{\n    // The vehicles operated by the company.\n    private List<Vehicle> vehicles;\n    private City city;\n    // The associations between vehicles and the passengers\n    // they are to pick up.\n    private Map<Vehicle, Passenger> assignments;\n\n    private static final int NUMBER_OF_TAXIS = 3;\n\n    /**\n     * @param city The city.\n     */\n    public TaxiCompany(City city)\n    {\n        this.city = city;\n        vehicles = new LinkedList<>();\n        assignments = new HashMap<>();\n        setupVehicles();\n    }\n\n    /**\n     * Request a pickup for the given passenger.\n     * @param passenger The passenger requesting a pickup.\n     * @return Whether a free vehicle is available.\n     */\n    public boolean requestPickup(Passenger passenger)\n    {\n        Vehicle vehicle = scheduleVehicle();\n        if(vehicle != null) {\n            assignments.put(vehicle, passenger);\n            vehicle.setPickupLocation(passenger.getPickupLocation());\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n    \n    /**\n     * A vehicle has arrived at a pickup point.\n     * @param vehicle The vehicle at the pickup point.\n     * @throws MissingPassengerException If there is no passenger waiting.\n     */\n    public void arrivedAtPickup(Vehicle vehicle)\n    {\n        Passenger passenger = assignments.remove(vehicle);\n        if(passenger == null) {\n            throw new MissingPassengerException(vehicle);\n        }\n        city.removeItem(passenger);\n        vehicle.pickup(passenger);\n    }\n    \n    /**\n     * A vehicle has arrived at a passenger's destination.\n     * @param vehicle The vehicle at the destination.\n     * @param passenger The passenger being dropped off.\n     */\n    public void arrivedAtDestination(Vehicle vehicle,\n                                     Passenger passenger)\n    {\n    }\n    \n    /**\n     * @return The list of vehicles.\n     */\n    public List<Vehicle> getVehicles()\n    {\n        return vehicles;\n    }\n    \n    /**\n     * Find a free vehicle, if any.\n     * @return A free vehicle, or null if there is none.\n     */\n    private Vehicle scheduleVehicle()\n    {\n        Iterator<Vehicle> it = vehicles.iterator();\n        while(it.hasNext()) {\n            Vehicle vehicle = it.next();\n            if(vehicle.isFree()) {\n                return vehicle;\n            }\n        }\n        return null;\n    }\n\n    /**\n     * Set up this company's vehicles. The optimum number of\n     * vehicles should be determined by analysis of the\n     * data gathered from the simulation.\n     *\n     * Vehicles start at random locations.\n     */\n    private void setupVehicles()\n    {\n        int cityWidth = city.getWidth();\n        int cityHeight = city.getHeight();\n        // Used a fixed random seed for predictable behavior.\n        // Use different seeds for less predictable behavior.\n        Random rand = new Random(12345);\n\n        // Create the taxis.\n        for(int i = 0; i < NUMBER_OF_TAXIS; i++){\n            Taxi taxi =\n                new Taxi(this,\n                         new Location(rand.nextInt(cityWidth),\n                                      rand.nextInt(cityHeight)));\n            vehicles.add(taxi);\n            city.addItem(taxi);\n        }\n   }\n}\n","position":{"x":721.8881019452228,"y":-330.97149135101165}},{"name":"Vehicle","content":"/**\n * Model the common elements of taxis and shuttles.\n * \n * @author David J. Barnes and Michael Kölling\n * @version 2016.02.29\n */\npublic abstract class Vehicle implements Actor\n{\n    private TaxiCompany company;\n    // Where the vehicle is.\n    private Location location;\n    // Where the vehicle is headed.\n    private Location targetLocation;\n    // Record how often the vehicle has nothing to do.\n    private int idleCount;\n    \n    /**\n     * Constructor of class Vehicle\n     * @param company The taxi company. Must not be null.\n     * @param location The vehicle's starting point. Must not be null.\n     * @throws NullPointerException If company or location is null.\n     */\n    public Vehicle(TaxiCompany company, Location location)\n    {\n        if(company == null) {\n            throw new NullPointerException(\"company\");\n        }\n        if(location == null) {\n            throw new NullPointerException(\"location\");\n        }\n        this.company = company;\n        this.location = location;\n        targetLocation = null;\n        idleCount = 0;\n    }\n    \n    /**\n     * Notify the company of our arrival at a pickup location.\n     */\n    public void notifyPickupArrival()\n    {\n        company.arrivedAtPickup(this);\n    }\n    \n    /**\n     * Notify the company of our arrival at a\n     * passenger's destination.\n     */\n    public void notifyPassengerArrival(Passenger passenger)\n    {\n        company.arrivedAtDestination(this, passenger);\n    }\n    \n    /**\n     * Receive a pickup location.\n     * How this is handled depends on the type of vehicle.\n     * @param location The pickup location.\n     */\n    public abstract void setPickupLocation(Location location);\n    \n    /**\n     * Receive a passenger.\n     * How this is handled depends on the type of vehicle.\n     * @param passenger The passenger.\n     */\n    public abstract void pickup(Passenger passenger);\n    \n    /**\n     * Is the vehicle free?\n     * @return Whether or not this vehicle is free.\n     */\n    public abstract boolean isFree();\n    \n    /**\n     * Offload any passengers whose destination is the\n     * current location.\n     */\n    public abstract void offloadPassenger();\n    \n    /**\n     * @return Where this vehicle is currently located.\n     */\n    public Location getLocation()\n    {\n        return location;\n    }\n    \n    /**\n     * Set the current location.\n     * @param location Where it is. Must not be null.\n     * @throws NullPointerException If location is null.\n     */\n    public void setLocation(Location location)\n    {\n        if(location != null) {\n            this.location = location;\n        }\n        else {\n            throw new NullPointerException();\n        }\n    }\n    \n    /**\n     * Get the target location.\n     * @return Where this vehicle is currently headed, or null\n     *         if it is idle.\n     */\n    public Location getTargetLocation()\n    {\n        return targetLocation;\n    }\n    \n    /**\n     * Set the required target location.\n     * @param location Where to go. Must not be null.\n     * @throws NullPointerException If location is null.\n     */\n    public void setTargetLocation(Location location)\n    {\n        if(location != null) {\n            targetLocation = location;\n        }\n        else {\n            throw new NullPointerException();\n        }\n    }\n    \n    /**\n     * Clear the target location.\n     */\n    public void clearTargetLocation()\n    {\n        targetLocation = null;\n    }\n\n    /**\n     * @return On how many steps this vehicle has been idle.\n     */\n    public int getIdleCount()\n    {\n        return idleCount;\n    }\n    \n    /**\n     * Increment the number of steps on which this vehicle\n     * has been idle.\n     */\n    public void incrementIdleCount()\n    {\n        idleCount++;\n    }\n}\n","position":{"x":815.5234829808417,"y":-232.31532047157293}}]}