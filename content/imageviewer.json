{"title":"ImageViewer","summary":"BlueJ Chapter 13","description":"`new ImageViewer()`\n\nOpen -> /app/tm_assets/dover.jpg","lastUpdated":1728766877857,"output":"display","classes":[{"name":"DarkerFilter","content":"/**\n * An image filter to make the image a bit darker.\n * \n * @author Michael Kölling and David J. Barnes.\n * @version 1.0\n */\npublic class DarkerFilter extends Filter\n{\n    /**\n     * Constructor for objects of class DarkerFilter.\n     * @param name The name of the filter.\n     */\n    public DarkerFilter(String name)\n    {\n        super(name);\n    }\n\n    /**\n     * Apply this filter to an image.\n     * \n     * @param  image  The image to be changed by this filter.\n     */\n    public void apply(OFImage image)\n    {\n        int height = image.getHeight();\n        int width = image.getWidth();\n        for(int y = 0; y < height; y++) {\n            for(int x = 0; x < width; x++) {\n                image.setPixel(x, y, image.getPixel(x, y).darker());\n            }\n        }\n    }\n}\n","position":{"x":81.98170633542381,"y":-156.64353775060738}},{"name":"EdgeFilter","content":"import java.awt.Color;\n\nimport java.util.List;\nimport java.util.ArrayList;\n\n/**\n * An image filter to detect edges and highlight them, a bit like \n * a colored pencil drawing.\n * \n * @author Michael Kölling and David J. Barnes.\n * @version 1.0\n */\npublic class EdgeFilter extends Filter\n{\n    private static final int TOLERANCE = 20;\n    \n    private OFImage original;\n    private int width;\n    private int height;\n\n    /**\n     * Constructor for objects of class EdgeFilter.\n     * @param name The name of the filter.\n     */\n    public EdgeFilter(String name)\n    {\n        super(name);\n    }\n\n    /**\n     * Apply this filter to an image.\n     * \n     * @param  image  The image to be changed by this filter.\n     */\n    public void apply(OFImage image)\n    {\n        original = new OFImage(image);\n        width = original.getWidth();\n        height = original.getHeight();\n        \n        for(int y = 0; y < height; y++) {\n            for(int x = 0; x < width; x++) {\n                image.setPixel(x, y, edge(x, y));\n            }\n        }\n    }\n\n    /**\n     * Return a new color that is the smoothed color of a given\n     * position. The \"smoothed color\" is the color value that is the\n     * average of this pixel and all the adjacent pixels.\n     * @param xpos The x position of the pixel.\n     * @param ypos The y position of the pixel.\n     * @return The smoothed color.\n     */\n    private Color edge(int xpos, int ypos)\n    {\n        List<Color> pixels = new ArrayList<>(9);\n        \n        for(int y = ypos-1; y <= ypos+1; y++) {\n            for(int x = xpos-1; x <= xpos+1; x++) {\n                if( x >= 0 && x < width && y >= 0 && y < height ) {\n                    pixels.add(original.getPixel(x, y));\n                }\n            }\n        }\n\n        return new Color(255 - diffRed(pixels), 255 - diffGreen(pixels), 255 - diffBlue(pixels));\n    }\n\n    /**\n     * @param pixels The list of pixels to be averaged.\n     * @return The average of all the red values in the given list of pixels.\n     */\n    private int diffRed(List<Color> pixels)\n    {\n        int max = 0;\n        int min = 255;\n        for(Color color : pixels) {\n            int val = color.getRed();\n            if(val > max) {\n                max = val;\n            }\n            if(val < min) {\n                min = val;\n            }\n        }\n        int difference = max - min - TOLERANCE;\n        if(difference < 0) {\n            difference = 0;\n        }\n        return difference;\n    }\n\n    /**\n     * @param pixels The list of pixels to be averaged.\n     * @return The average of all the green values in the given list of pixels.\n     */\n    private int diffGreen(List<Color> pixels)\n    {\n        int max = 0;\n        int min = 255;\n        for(Color color : pixels) {\n            int val = color.getGreen();\n            if(val > max) {\n                max = val;\n            }\n            if(val < min) {\n                min = val;\n            }\n        }\n        int difference = max - min - TOLERANCE;\n        if(difference < 0) {\n            difference = 0;\n        }\n        return difference;\n    }\n\n    /**\n     * @param pixels The list of pixels to be averaged.\n     * @return The average of all the blue values in the given list of pixels.\n     */\n    private int diffBlue(List<Color> pixels)\n    {\n        int max = 0;\n        int min = 255;\n        for(Color color : pixels) {\n            int val = color.getBlue();\n            if(val > max) {\n                max = val;\n            }\n            if(val < min) {\n                min = val;\n            }\n        }\n        int difference = max - min - TOLERANCE;\n        if(difference < 0) {\n            difference = 0;\n        }\n        return difference;\n    }\n\n}\n","position":{"x":-27.197573296298543,"y":-263.3543451803612}},{"name":"FishEyeFilter","content":"import java.awt.Color;\n\n/**\n * An image filter to create an effect similar to a fisheye camera lens.\n * (Works especially well on portraits.)\n * \n * @author Michael Kölling and David J. Barnes.\n * @version 1.0\n */\npublic class FishEyeFilter extends Filter\n{\n    // constants:\n    private final static int SCALE = 20;   // this defines the strenght of the filter\n    private final static double TWO_PI = 2 * Math.PI;\n\n    /**\n     * Constructor for objects of class LensFilter.\n     * @param name The name of the filter.\n     */\n    public FishEyeFilter(String name)\n    {\n        super(name);\n    }\n\n    /**\n     * Apply this filter to an image.\n     * \n     * @param  image  The image to be changed by this filter.\n     */\n    public void apply(OFImage image)\n    {\n        int height = image.getHeight();\n        int width = image.getWidth();\n        OFImage original = new OFImage(image);\n\n        int[] xa = computeXArray(width);\n        int[] ya = computeYArray(height);\n        \n        for(int y = 0; y < height; y++) {\n            for(int x = 0; x < width; x++) {\n                image.setPixel(x, y, original.getPixel(x + xa[x], y + ya[y]));\n            }\n        }\n    }\n\n    /**\n     * Compute and return an array of horizontal offsets for each pixel column.\n     * These can then be applied as the horizontal offset for each pixel.\n     */\n    private int[] computeXArray(int width)\n    {\n        int[] xArray = new int[width];\n        \n        for(int i=0; i < width; i++) {\n            xArray[i] = (int)(Math.sin( ((double)i / width) * TWO_PI) * SCALE);\n        }\n        return xArray;\n    }\n\n    /**\n     * Compute and return an array of vertical offsets for each pixel row.\n     * These can then be applied as the vertical offset for each pixel.\n     */\n    private int[] computeYArray(int height)\n    {\n        int[] yArray = new int[height];\n        \n        for(int i=0; i < height; i++) {\n            yArray[i] = (int)(Math.sin( ((double)i / height) * TWO_PI) * SCALE);\n        }\n        return yArray;\n    }\n}\n","position":{"x":-28.9448347145005,"y":-118.51735144140963}},{"name":"GrayScaleFilter","content":"import java.awt.Color;\n\n/**\n * An image filter to remove color from an image.\n * \n * @author Michael Kölling and David J. Barnes.\n * @version 1.0\n */\npublic class GrayScaleFilter extends Filter\n{\n\t/**\n\t * Constructor for objects of class GrayScaleFilter.\n\t * @param name The name of the filter.\n\t */\n\tpublic GrayScaleFilter(String name)\n    {\n        super(name);\n\t}\n\n    /**\n     * Apply this filter to an image.\n     * \n     * @param  image  The image to be changed by this filter.\n     */\n    public void apply(OFImage image)\n    {\n        int height = image.getHeight();\n        int width = image.getWidth();\n        for(int y = 0; y < height; y++) {\n            for(int x = 0; x < width; x++) {\n                Color pix = image.getPixel(x, y);\n                int avg = (pix.getRed() + pix.getGreen() + pix.getBlue()) / 3;\n                image.setPixel(x, y, new Color(avg, avg, avg));\n            }\n        }\n    }\n}\n","position":{"x":270.00647245922903,"y":-326.94000294441537}},{"name":"ImageFileManager","content":"import java.awt.image.*;\nimport javax.imageio.*;\nimport java.io.*;\n\n/**\n * ImageFileManager is a small utility class with static methods to load\n * and save images.\n * \n * The files on disk can be in JPG or PNG image format. For files written\n * by this class, the format is determined by the constant IMAGE_FORMAT.\n * \n * @author Michael Kölling and David J. Barnes.\n * @version 2.0\n */\npublic class ImageFileManager\n{\n    // A constant for the image format that this writer uses for writing.\n    // Available formats are \"jpg\" and \"png\".\n    private static final String IMAGE_FORMAT = \"jpg\";\n    \n    /**\n     * Read an image file from disk and return it as an image. This method\n     * can read JPG and PNG file formats. In case of any problem (e.g the file \n     * does not exist, is in an undecodable format, or any other read error) \n     * this method returns null.\n     * \n     * @param imageFile  The image file to be loaded.\n     * @return           The image object or null if it could not be read.\n     */\n    public static OFImage loadImage(File imageFile)\n    {\n        try {\n            BufferedImage image = ImageIO.read(imageFile);\n            if(image == null || (image.getWidth(null) < 0)) {\n                // we could not load the image - probably invalid file format\n                return null;\n            }\n            return new OFImage(image);\n        }\n        catch(IOException exc) {\n            return null;\n        }\n    }\n\n    /**\n     * Write an image file to disk. The file format is JPG. In case of any \n     * problem the method just silently returns.\n     * \n     * @param image  The image to be saved.\n     * @param file   The file to save to.\n     */\n    public static void saveImage(OFImage image, File file)\n    {\n        try {\n            ImageIO.write(image, IMAGE_FORMAT, file);\n        }\n        catch(IOException exc) {\n            return;\n        }\n    }\n}\n","position":{"x":265.11389799452115,"y":95.39070183206775}},{"name":"ImagePanel","content":"import java.awt.*;\nimport javax.swing.*;\nimport java.awt.image.*;\n\n/**\n * An ImagePanel is a Swing component that can display an OFImage.\n * It is constructed as a subclass of JComponent with the added functionality\n * of setting an OFImage that will be displayed on the surface of this\n * component.\n * \n * @author Michael Kölling and David J. Barnes.\n * @version 1.0\n */\npublic class ImagePanel extends JComponent\n{\n    // The current width and height of this panel\n    private int width, height;\n\n    // An internal image buffer that is used for painting. For\n    // actual display, this image buffer is then copied to screen.\n    private OFImage panelImage;\n\n    /**\n     * Create a new, empty ImagePanel.\n     */\n    public ImagePanel()\n    {\n        width = 360;    // arbitrary size for empty panel\n        height = 240;\n        panelImage = null;\n    }\n\n    /**\n     * Set the image that this panel should show.\n     * \n     * @param image  The image to be displayed.\n     */\n    public void setImage(OFImage image)\n    {\n        if(image != null) {\n            width = image.getWidth();\n            height = image.getHeight();\n            panelImage = image;\n            repaint();\n        }\n    }\n    \n    /**\n     * Clear the image on this panel.\n     */\n    public void clearImage()\n    {\n        Graphics imageGraphics = panelImage.getGraphics();\n        imageGraphics.setColor(Color.LIGHT_GRAY);\n        imageGraphics.fillRect(0, 0, width, height);\n        repaint();\n    }\n    \n    // The following methods are redefinitions of methods\n    // inherited from superclasses.\n    \n    /**\n     * Tell the layout manager how big we would like to be.\n     * (This method gets called by layout managers for placing\n     * the components.)\n     * \n     * @return The preferred dimension for this component.\n     */\n    public Dimension getPreferredSize()\n    {\n        return new Dimension(width, height);\n    }\n    \n    /**\n     * This component needs to be redisplayed. Copy the internal image \n     * to screen. (This method gets called by the Swing screen painter \n     * every time it want this component displayed.)\n     * \n     * @param g The graphics context that can be used to draw on this component.\n     */\n    public void paintComponent(Graphics g)\n    {\n        Dimension size = getSize();\n        g.clearRect(0, 0, size.width, size.height);\n        if(panelImage != null) {\n            g.drawImage(panelImage, 0, 0, null);\n        }\n    }\n}\n","position":{"x":238.1676380553315,"y":246.59847112479622}},{"name":"ImageViewer","content":"import java.awt.*;\nimport java.awt.event.*;\nimport java.awt.image.*;\nimport javax.swing.*;\nimport javax.swing.border.*;\n\nimport java.io.File;\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Iterator;\n\n/**\n * ImageViewer is the main class of the image viewer application. It builds and\n * displays the application GUI and initialises all other components.\n * \n * To start the application, create an object of this class.\n * \n * @author Michael Kölling and David J. Barnes.\n * @version 3.1\n */\npublic class ImageViewer\n{\n    // static fields:\n    private static final String VERSION = \"Version 3.1\";\n    private static JFileChooser fileChooser = new JFileChooser(System.getProperty(\"user.dir\"));\n\n    // fields:\n    private JFrame frame;\n    private ImagePanel imagePanel;\n    private JLabel filenameLabel;\n    private JLabel statusLabel;\n    private JButton smallerButton;\n    private JButton largerButton;\n    private OFImage currentImage;\n    \n    private List<Filter> filters;\n    \n    /**\n     * Create an ImageViewer and display its GUI on screen.\n     */\n    public ImageViewer()\n    {\n        currentImage = null;\n        filters = createFilters();\n        makeFrame();\n    }\n\n\n    // ---- implementation of menu functions ----\n    \n    /**\n     * Open function: open a file chooser to select a new image file,\n     * and then display the chosen image.\n     */\n    private void openFile()\n    {\n        int returnVal = fileChooser.showOpenDialog(frame);\n\n        if(returnVal != JFileChooser.APPROVE_OPTION) {\n            return;  // cancelled\n        }\n        File selectedFile = fileChooser.getSelectedFile();\n        currentImage = ImageFileManager.loadImage(selectedFile);\n        \n        if(currentImage == null) {   // image file was not a valid image\n            JOptionPane.showMessageDialog(frame,\n                    \"The file was not in a recognized image file format.\",\n                    \"Image Load Error\",\n                    JOptionPane.ERROR_MESSAGE);\n            return;\n        }\n\n        imagePanel.setImage(currentImage);\n        setButtonsEnabled(true);\n        showFilename(selectedFile.getPath());\n        showStatus(\"File loaded.\");\n        frame.pack();\n    }\n\n    /**\n     * Close function: close the current image.\n     */\n    private void close()\n    {\n        currentImage = null;\n        imagePanel.clearImage();\n        showFilename(null);\n        setButtonsEnabled(false);\n    }\n\n    /**\n     * Save As function: save the current image to a file.\n     */\n    private void saveAs()\n    {\n        if(currentImage != null) {\n            int returnVal = fileChooser.showSaveDialog(frame);\n    \n            if(returnVal != JFileChooser.APPROVE_OPTION) {\n                return;  // cancelled\n            }\n            File selectedFile = fileChooser.getSelectedFile();\n            ImageFileManager.saveImage(currentImage, selectedFile);\n            \n            showFilename(selectedFile.getPath());\n        }\n    }\n\n    /**\n     * Quit function: quit the application.\n     */\n    private void quit()\n    {\n        System.exit(0);\n    }\n\n    /**\n     * Apply a given filter to the current image.\n     * \n     * @param filter   The filter object to be applied.\n     */\n    private void applyFilter(Filter filter)\n    {\n        if(currentImage != null) {\n            filter.apply(currentImage);\n            frame.repaint();\n            showStatus(\"Applied: \" + filter.getName());\n        }\n        else {\n            showStatus(\"No image loaded.\");\n        }\n    }\n\n    /**\n     * 'About' function: show the 'about' box.\n     */\n    private void showAbout()\n    {\n        JOptionPane.showMessageDialog(frame, \n                    \"ImageViewer\\n\" + VERSION,\n                    \"About ImageViewer\", \n                    JOptionPane.INFORMATION_MESSAGE);\n    }\n\n    /**\n     * Make the current picture larger.\n     */\n    private void makeLarger()\n    {\n        if(currentImage != null) {\n            // create new image with double size\n            int width = currentImage.getWidth();\n            int height = currentImage.getHeight();\n            OFImage newImage = new OFImage(width * 2, height * 2);\n\n            // copy pixel data into new image\n            for(int y = 0; y < height; y++) {\n                for(int x = 0; x < width; x++) {\n                    Color col = currentImage.getPixel(x, y);\n                    newImage.setPixel(x * 2, y * 2, col);\n                    newImage.setPixel(x * 2 + 1, y * 2, col);\n                    newImage.setPixel(x * 2, y * 2 + 1, col);\n                    newImage.setPixel(x * 2+1, y * 2 + 1, col);\n                }\n            }\n            \n            currentImage = newImage;\n            imagePanel.setImage(currentImage);\n            frame.pack();\n        }\n    }\n    \n\n    /**\n     * Make the current picture smaller.\n     */\n    private void makeSmaller()\n    {\n        if(currentImage != null) {\n            // create new image with double size\n            int width = currentImage.getWidth() / 2;\n            int height = currentImage.getHeight() / 2;\n            OFImage newImage = new OFImage(width, height);\n\n            // copy pixel data into new image\n            for(int y = 0; y < height; y++) {\n                for(int x = 0; x < width; x++) {\n                    newImage.setPixel(x, y, currentImage.getPixel(x * 2, y * 2));\n                }\n            }\n            \n            currentImage = newImage;\n            imagePanel.setImage(currentImage);\n            frame.pack();\n        }\n    }\n    \n    // ---- support methods ----\n\n    /**\n     * Show the file name of the current image in the fils display label.\n     * 'null' may be used as a parameter if no file is currently loaded.\n     * \n     * @param filename  The file name to be displayed, or null for 'no file'.\n     */\n    private void showFilename(String filename)\n    {\n        if(filename == null) {\n            filenameLabel.setText(\"No file displayed.\");\n        }\n        else {\n            filenameLabel.setText(\"File: \" + filename);\n        }\n    }\n    \n    \n    /**\n     * Show a message in the status bar at the bottom of the screen.\n     * @param text The status message.\n     */\n    private void showStatus(String text)\n    {\n        statusLabel.setText(text);\n    }\n    \n    \n    /**\n     * Enable or disable all toolbar buttons.\n     * \n     * @param status  'true' to enable the buttons, 'false' to disable.\n     */\n    private void setButtonsEnabled(boolean status)\n    {\n        smallerButton.setEnabled(status);\n        largerButton.setEnabled(status);\n    }\n    \n    \n    /**\n     * Create a list with all the known filters.\n     * @return The list of filters.\n     */\n    private List<Filter> createFilters()\n    {\n        List<Filter> filterList = new ArrayList<>();\n        filterList.add(new DarkerFilter(\"Darker\"));\n        filterList.add(new LighterFilter(\"Lighter\"));\n        filterList.add(new ThresholdFilter(\"Threshold\"));\n        filterList.add(new InvertFilter(\"Invert\"));\n        filterList.add(new SolarizeFilter(\"Solarize\"));\n        filterList.add(new SmoothFilter(\"Smooth\"));\n        filterList.add(new PixelizeFilter(\"Pixelize\"));\n        filterList.add(new MirrorFilter(\"Mirror\"));\n        filterList.add(new GrayScaleFilter(\"Grayscale\"));\n        filterList.add(new EdgeFilter(\"Edge Detection\"));\n        filterList.add(new FishEyeFilter(\"Fish Eye\"));\n       \n        return filterList;\n    }\n    \n    // ---- Swing stuff to build the frame and all its components and menus ----\n    \n    /**\n     * Create the Swing frame and its content.\n     */\n    private void makeFrame()\n    {\n        frame = new JFrame(\"ImageViewer\");\n        JPanel contentPane = (JPanel)frame.getContentPane();\n        contentPane.setBorder(new EmptyBorder(12, 12, 12, 12));\n\n        makeMenuBar(frame);\n        \n        // Specify the layout manager with nice spacing\n        contentPane.setLayout(new BorderLayout(6, 6));\n        \n        // Create the image pane in the center\n        imagePanel = new ImagePanel();\n        imagePanel.setBorder(new EtchedBorder());\n        contentPane.add(imagePanel, BorderLayout.CENTER);\n\n        // Create two labels at top and bottom for the file name and status messages\n        filenameLabel = new JLabel();\n        contentPane.add(filenameLabel, BorderLayout.NORTH);\n\n        statusLabel = new JLabel(VERSION);\n        contentPane.add(statusLabel, BorderLayout.SOUTH);\n        \n        // Create the toolbar with the buttons\n        JPanel toolbar = new JPanel();\n        toolbar.setLayout(new GridLayout(0, 1));\n        \n        smallerButton = new JButton(\"Smaller\");\n        smallerButton.addActionListener(e -> makeSmaller());\n        toolbar.add(smallerButton);\n        \n        largerButton = new JButton(\"Larger\");\n        largerButton.addActionListener(e -> makeLarger());\n        toolbar.add(largerButton);\n\n        // Add toolbar into panel with flow layout for spacing\n        JPanel flow = new JPanel();\n        flow.add(toolbar);\n        \n        contentPane.add(flow, BorderLayout.WEST);\n        \n        // building is done - arrange the components      \n        showFilename(null);\n        setButtonsEnabled(false);\n        frame.pack();\n        \n        // place the frame at the center of the screen and show\n        Dimension d = Toolkit.getDefaultToolkit().getScreenSize();\n        frame.setLocation(d.width/2 - frame.getWidth()/2, d.height/2 - frame.getHeight()/2);\n        frame.setVisible(true);\n    }\n    \n    /**\n     * Create the main frame's menu bar.\n     * \n     * @param frame   The frame that the menu bar should be added to.\n     */\n    private void makeMenuBar(JFrame frame)\n    {\n        final int SHORTCUT_MASK =\n            Toolkit.getDefaultToolkit().getMenuShortcutKeyMask();\n\n        JMenuBar menubar = new JMenuBar();\n        frame.setJMenuBar(menubar);\n        \n        JMenu menu;\n        JMenuItem item;\n        \n        // create the File menu\n        menu = new JMenu(\"File\");\n        menubar.add(menu);\n        \n        item = new JMenuItem(\"Open...\");\n            item.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, SHORTCUT_MASK));\n            item.addActionListener(e -> openFile());\n        menu.add(item);\n\n        item = new JMenuItem(\"Close\");\n            item.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_W, SHORTCUT_MASK));\n            item.addActionListener(e -> close());\n        menu.add(item);\n        menu.addSeparator();\n\n        item = new JMenuItem(\"Save As...\");\n            item.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_S, SHORTCUT_MASK));\n            item.addActionListener(e -> saveAs());\n        menu.add(item);\n        menu.addSeparator();\n        \n        item = new JMenuItem(\"Quit\");\n            item.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_Q, SHORTCUT_MASK));\n            item.addActionListener(e -> quit());\n        menu.add(item);\n\n\n        // create the Filter menu\n        menu = new JMenu(\"Filter\");\n        menubar.add(menu);\n        \n        for(Filter filter : filters) {\n            item = new JMenuItem(filter.getName());\n            item.addActionListener(e -> applyFilter(filter));\n             menu.add(item);\n         }\n\n        // create the Help menu\n        menu = new JMenu(\"Help\");\n        menubar.add(menu);\n        \n        item = new JMenuItem(\"About ImageViewer...\");\n            item.addActionListener(e -> showAbout());\n        menu.add(item);\n\n    }\n}\n","position":{"x":-136.67138710728332,"y":132.5289135281355}},{"name":"InvertFilter","content":"import java.awt.Color;\n\n/**\n * An image filter to invert colors.\n * \n * @author Michael Kölling and David J. Barnes.\n * @version 1.0\n */\npublic class InvertFilter extends Filter\n{\n    /**\n     * Constructor for objects of class InvertFilter.\n     * @param name The name of the filter.\n     */\n    public InvertFilter(String name)\n    {\n        super(name);\n    }\n\n    /**\n     * Apply this filter to an image.\n     * \n     * @param  image  The image to be changed by this filter.\n     */\n    public void apply(OFImage image)\n    {\n        int height = image.getHeight();\n        int width = image.getWidth();\n        for(int y = 0; y < height; y++) {\n            for(int x = 0; x < width; x++) {\n                Color pix = image.getPixel(x, y);\n                image.setPixel(x, y, new Color(255 - pix.getRed(),\n                                               255 - pix.getGreen(),\n                                               255 - pix.getBlue()));\n            }\n        }\n    }\n}\n","position":{"x":122.4424591483687,"y":-98.5618291628399}},{"name":"LighterFilter","content":"/**\n * An image filter to make the image a bit lighter.\n * \n * @author Michael Kölling and David J. Barnes.\n * @version 1.0\n */\npublic class LighterFilter extends Filter\n{\n\t/**\n\t * Constructor for objects of class LighterFilter.\n     * @param name The name of the filter.\n\t */\n\tpublic LighterFilter(String name)\n    {\n        super(name);\n\t}\n\n    /**\n     * Apply this filter to an image.\n     * \n     * @param  image  The image to be changed by this filter.\n     */\n    public void apply(OFImage image)\n    {\n        int height = image.getHeight();\n        int width = image.getWidth();\n        for(int y = 0; y < height; y++) {\n            for(int x = 0; x < width; x++) {\n                image.setPixel(x, y, image.getPixel(x, y).brighter());\n            }\n        }\n    }\n\n}\n","position":{"x":102.76466311497234,"y":-282.667648854411}},{"name":"MirrorFilter","content":"import java.awt.Color;\n\n/**\n * An image filter to mirror (flip) the image horizontally.\n * \n * @author Michael Kölling and David J. Barnes.\n * @version 1.0\n */\npublic class MirrorFilter extends Filter\n{\n\t/**\n\t * Constructor for objects of class MirrorFilter.\n     * @param name The name of the filter.\n\t */\n\tpublic MirrorFilter(String name)\n    {\n        super(name);\n\t}\n\n    /**\n     * Apply this filter to an image.\n     * \n     * @param  image  The image to be changed by this filter.\n     */\n    public void apply(OFImage image)\n    {\n        int height = image.getHeight();\n        int width = image.getWidth();\n        for(int y = 0; y < height; y++) {\n            for(int x = 0; x < width / 2; x++) {\n                Color left = image.getPixel(x, y);\n                image.setPixel(x, y, image.getPixel(width - 1 - x, y));\n                image.setPixel(width - 1 - x, y, left);\n            }\n        }\n    }\n}\n","position":{"x":-73.73027814217491,"y":-290.15834936827576}},{"name":"OFImage","content":"import java.awt.*;\nimport java.awt.image.*;\nimport javax.swing.*;\n\n/**\n * OFImage is a class that defines an image in OF (Objects First) format.\n * \n * @author Michael Kölling and David J. Barnes.\n * @version 2.0\n */\npublic class OFImage extends BufferedImage\n{\n    /**\n     * Create an OFImage copied from a BufferedImage.\n     * @param image The image to copy.\n     */\n    public OFImage(BufferedImage image)\n    {\n         super(image.getColorModel(), image.copyData(null), \n               image.isAlphaPremultiplied(), null);\n    }\n\n    /**\n     * Create an OFImage with specified size and unspecified content.\n     * @param width The width of the image.\n     * @param height The height of the image.\n     */\n    public OFImage(int width, int height)\n    {\n        super(width, height, TYPE_INT_RGB);\n    }\n\n    /**\n     * Set a given pixel of this image to a specified color. The\n     * color is represented as an (r,g,b) value.\n     * @param x The x position of the pixel.\n     * @param y The y position of the pixel.\n     * @param col The color of the pixel.\n     */\n    public void setPixel(int x, int y, Color col)\n    {\n        int pixel = col.getRGB();\n        setRGB(x, y, pixel);\n    }\n    \n    /**\n     * Get the color value at a specified pixel position.\n     * @param x The x position of the pixel.\n     * @param y The y position of the pixel.\n     * @return The color of the pixel at the given position.\n     */\n    public Color getPixel(int x, int y)\n    {\n        int pixel = getRGB(x, y);\n        return new Color(pixel);\n    }\n}\n","position":{"x":565.0948002249138,"y":-157.0027033706305}},{"name":"PixelizeFilter","content":"import java.awt.Color;\n\n/**\n * An image filter to create a pixelization effect, like an enlarged\n * low-resolution digital image.\n * \n * @author Michael Kölling and David J. Barnes.\n * @version 1.0\n */\npublic class PixelizeFilter extends Filter\n{\n    /**\n     * Constructor for objects of class PixelizeFilter.\n     * @param name The name of the filter.\n     */\n    public PixelizeFilter(String name)\n    {\n        super(name);\n    }\n\n    /**\n     * Apply this filter to an image.\n     * \n     * @param  image  The image to be changed by this filter.\n     */\n    public void apply(OFImage image)\n    {\n        final int PIXEL_SIZE = 5;\n        int width = image.getWidth();\n        int height = image.getHeight();\n        \n        for(int y = 0; y < height; y += PIXEL_SIZE) {\n            for(int x = 0; x < width; x += PIXEL_SIZE) {\n                Color pix = image.getPixel(x, y);\n                for(int dy = y; dy < y + PIXEL_SIZE; dy++) {\n                    for(int dx = x; dx < x + PIXEL_SIZE; dx++) {\n                        if( dx < width && dy < height )\n                            image.setPixel(dx, dy, pix);\n                    }\n                }\n            }\n        }\n    }\n}\n","position":{"x":289.694283345327,"y":-157.75491292308953}},{"name":"SmoothFilter","content":"import java.awt.Color;\nimport java.util.List;\nimport java.util.ArrayList;\n\n/**\n * An image filter to reduce sharp edges and pixelization. A bit like\n * a soft lens.\n * \n * @author Michael Kölling and David J. Barnes.\n * @version 1.0\n */\npublic class SmoothFilter extends Filter\n{\n    private OFImage original;\n    private int width;\n    private int height;\n    \n    /**\n     * Constructor for objects of class SmoothFilter.\n     * @param name The name of the filter.\n     */\n    public SmoothFilter(String name)\n    {\n        super(name);\n    }\n\n    /**\n     * Apply this filter to an image.\n     * \n     * @param  image  The image to be changed by this filter.\n     */\n    public void apply(OFImage image)\n    {\n        original = new OFImage(image);\n        width = original.getWidth();\n        height = original.getHeight();\n        \n        for(int y = 0; y < height; y++) {\n            for(int x = 0; x < width; x++) {\n                image.setPixel(x, y, smooth(x, y));\n            }\n        }\n    }\n    \n    /**\n     * Return a new color that is the smoothed color of a given\n     * position. The \"smoothed color\" is the color value that is the\n     * average of this pixel and all the adjacent pixels.\n     * @param xpos The xposition of the pixel.\n     * @param ypos The yposition of the pixel.\n     * @return The smoothed color.\n     */\n    private Color smooth(int xpos, int ypos)\n    {\n        List<Color> pixels = new ArrayList<>(9);\n        \n        for(int y = ypos - 1; y <= ypos + 1; y++) {\n            for(int x = xpos - 1; x <= xpos + 1; x++) {\n                if( x >= 0 && x < width && y >= 0 && y < height )\n                    pixels.add(original.getPixel(x, y));\n            }\n        }\n\n        return new Color(avgRed(pixels), avgGreen(pixels), avgBlue(pixels));\n    }\n\n    /**\n     * @param pixels The list of pixels.\n     * @return The average of all the red values in the given list of pixels.\n     */\n    private int avgRed(List<Color> pixels)\n    {\n        int total = 0;\n        for(Color color : pixels) {\n            total += color.getRed();\n        }\n        return total / pixels.size();\n    }\n\n    /**\n     * @param pixels The list of pixels.\n     * @return The average of all the green values in the given list of pixels.\n     */\n    private int avgGreen(List<Color> pixels)\n    {\n        int total = 0;\n        for(Color color : pixels) {\n            total += color.getGreen();\n        }\n        return total / pixels.size();\n    }\n\n    /**\n     * @param pixels The list of pixels.\n     * @return The average of all the blue values in the given list of pixels.\n     */\n    private int avgBlue(List<Color> pixels)\n    {\n        int total = 0;\n        for(Color color : pixels) {\n            total += color.getBlue();\n        }\n        return total / pixels.size();\n    }\n}\n","position":{"x":201.39452967832807,"y":-235.17129779352015}},{"name":"SolarizeFilter","content":"import java.awt.Color;\n\n/**\n * An image filter to create a solarization effect.\n * \n * @author Michael Kölling and David J. Barnes.\n * @version 1.0\n */\npublic class SolarizeFilter extends Filter\n{\n    /**\n     * Constructor for objects of class Solarize.\n     * @param name The name of the filter.\n     */\n    public SolarizeFilter(String name)\n    {\n        super(name);\n    }\n\n    /**\n     * Apply this filter to an image.\n     * \n     * @param  image  The image to be changed by this filter.\n     */\n    public void apply(OFImage image)\n    {\n        int height = image.getHeight();\n        int width = image.getWidth();\n        for(int y = 0; y < height; y++) {\n            for(int x = 0; x < width; x++) {\n                Color pix = image.getPixel(x, y);\n                int red = pix.getRed();\n                if(red <= 127) {\n                    red = 255 - red;\n                }\n                int green = pix.getGreen();\n                if(green <= 127) {\n                    green = 255 - green;\n                }\n                int blue = pix.getBlue();\n                if(blue <= 127) {\n                    blue = 255 - blue;\n                }\n                image.setPixel(x, y, new Color(red, green, blue));\n            }\n        }\n    }\n\n}\n","position":{"x":-64.84066535598056,"y":-183.61401543058528}},{"name":"ThresholdFilter","content":"import java.awt.Color;\n\n/**\n * An three-level gray-based threshold filter.\n * \n * @author Michael Kölling and David J. Barnes.\n * @version 1.0\n */\npublic class ThresholdFilter extends Filter\n{\n\t/**\n\t * Constructor for objects of class ThresholdFilter.\n     * @param name The name of the filter.\n\t */\n\tpublic ThresholdFilter(String name)\n    {\n        super(name);\n\t}\n\n    /**\n     * Apply this filter to an image.\n     * \n     * @param  image  The image to be changed by this filter.\n     */\n    public void apply(OFImage image)\n    {\n        int height = image.getHeight();\n        int width = image.getWidth();\n        for(int y = 0; y < height; y++) {\n            for(int x = 0; x < width; x++) {\n                Color pixel = image.getPixel(x, y);\n                int brightness = (pixel.getRed() + pixel.getBlue() + pixel.getGreen()) / 3;\n                if(brightness <= 85) {\n                    image.setPixel(x, y, Color.BLACK);\n                }\n                else if(brightness <= 170) {\n                    image.setPixel(x, y, Color.GRAY);\n                }\n                else {\n                    image.setPixel(x, y, Color.WHITE);\n                }\n            }\n        }\n    }\n}\n","position":{"x":12.132789547101453,"y":-72.44239527248882}},{"name":"Filter","content":"/**\n * Filter is an abstract superclass for all image filters in this\n * application. Filters can be applied to OFImages by invoking the apply \n * method.\n * \n * @author Michael Kölling and David J. Barnes.\n * @version 1.0\n */\npublic abstract class Filter\n{\n    private String name;\n\n    /**\n     * Create a new filter with a given name.\n     * @param name The name of the filter.\n     */\n    public Filter(String name)\n    {\n        this.name = name;\n    }\n    \n    /**\n     * Return the name of this filter.\n     * \n     * @return  The name of this filter.\n     */\n    public String getName()\n    {\n        return name;\n    }\n    \n    /**\n     * Apply this filter to an image.\n     * \n     * @param  image  The image to be changed by this filter.\n     */\n    public abstract void apply(OFImage image);\n}\n","position":{"x":438.23287237777055,"y":-300.39454862707294}}]}