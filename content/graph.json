{"title":"Dijkstra mit Graphen","summary":"Dijkstra Feld NWitt - Lsg","description":"Lösung, Animation zu Dijkstra","lastUpdated":1728054851771,"output":"display","classes":[{"name":"GraphDarstellung","content":"import java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.*;\n\n/** ******************************************* Angepasst ***************************\n * Darstellung eines Graphen\n * \n * GraphDarstellung zeigt den Graphen\n * \n * Dem Konstruktor wird der anzuzeigende Graph uebergeben.\n * \n * Mit der Methode aktualisieren() wird ein veraenderter Graph neu gezeichnet.\n * \n * Für alle Interfaces: leseInfo(); liefert den Anzeigetext\n * \n * Die Klasse Graph muss IGraph implementieren\n * \n * IKnoten [] leseKnotenArray() ; // Übergibt ein Array von Knoten\n * \n * int [][] leseKantenMatrix(); // Übergibt ein zweidimensionales Feld der\n * Kantengewichte // -1 bedeutet keine Kante Color [][] leseFarbKantenMatrix();\n * // Gibt Referenz die FarbKantenmatrix. Farbe null ist Standardfarbe // Ist\n * der Returnwert null, werden alle Kanten mit Standardfarbe dargestellt\n * \n * Die Klasse Knoten muss IKnoten implementieren Die Methode lesePosition()\n * liefert das Raster für die Anzeige des Knotens Beispiel: public Point\n * lesePosition() { return new Point(posX,posY); }\n * \n * \n * @author Hans Witt\n * \n */\n@SuppressWarnings(\"serial\")\npublic class GraphDarstellung extends JPanel {\n\n    public static int timeout = 333 ; \n\n    Graph graph = null;\n\n    int AnzeigeBreite = 1000;\n    int AnzeigeHoehe = 800;\n    \n    static int schriftGroesse;\n\n    boolean mitGewicht = false;\n\n    BufferedImage bBild ;        \n\n    public void MitKantenGewicht() {\n        this.mitGewicht = true;\n    }\n\n    G_Frame_1 frame;\n\n    public GraphDarstellung(Graph graph, boolean mitKantengewicht , String filename ) {\n        AnzeigeBreite = 1000;\n        AnzeigeHoehe = 800;\n        schriftGroesse = 14;\n        mitGewicht = mitKantengewicht;\n        frame = new G_Frame_1(this, 600, 700);\n        this.groesseAendern(600, 700);\n        this.graph = graph;\n        bBild = setzeBilddatei(filename) ;\n        warten(2500);\n        repeat(timeout);\n\n    }\n\n    public GraphDarstellung(Graph graph, boolean mitKantengewicht ) {\n        this(graph,mitKantengewicht,\"\");\n    }\n\n    private void repeat(int delay) {\n        ActionListener taskPerformer = new ActionListener() {\n                @Override\n                public void actionPerformed(ActionEvent arg0) {\n                    aktualisieren();\n                }\n            };\n        Timer t = new Timer(delay, taskPerformer);\n        t.setRepeats(true);\n        t.start();\n    }\n\n    public void zeigeGraph(Graph graph) {\n        this.graph = graph;\n        validate();\n    }\n\n    public void loescheGraph() {\n        graph = null;\n    }\n\n    void warten(int millisekunden) {\n        try {\n            Thread.sleep(millisekunden);\n        } catch (Exception e) {\n            // Exception ignorieren\n        }\n    }\n\n    public void aktualisieren(int millisekunden) {\n        aktualisieren();\n        warten(millisekunden);\n    }\n\n    public void aktualisieren() {\n        repaint();\n        frame.getContentPane().repaint();\n    }\n\n    private void groesseAendern(int breite, int hoehe) {\n        AnzeigeBreite = breite;\n        AnzeigeHoehe = hoehe;\n        this.setPreferredSize(new Dimension(breite, hoehe));\n        aktualisieren();\n    }\n\n    /** \n     * Darstellungsparameter \n     */\n    static int rasterBreiteX = 1; //Zoomfaktor in xRichtung belassen!\n    static int rasterHoeheY = 1;  //Zoomfaktor in yRichtung belassen!\n    static int kreisradius = 20;  //Kreisradius des Knotens  \n    static int bild_dx = kreisradius/2-10;    //Verschiebung des Bildes!\n    static int bild_dy = kreisradius/2-10;\n\n    /**\n     * Anzeigegröße ändern\n     * Startwerte: x=y=10, radius = 20\n     * \n     * @param X\n     * @param Y\n     * @param radius \n     */\n    public static void setzeZoom(int zoomX, int zoomY , int radius){\n        rasterBreiteX = zoomX;\n        rasterHoeheY = zoomY;\n        kreisradius = radius;\n    }\n    \n    public static void setzeRadius(int radius){\n        kreisradius = radius;\n        bild_dx = radius/2-10 ; //********* Versatz des Bildes\n        bild_dy = radius/2-10 ; //*********\n    }\n\n    public static void setzeSchriftGroesse(int schriftgroesse){\n        schriftGroesse = schriftgroesse;\n    }\n\n    int desc;\n    int zeichenhoehe = 30; // Startwert. Wird ueberschrieben\n\n    public void paintComponent(Graphics g) {\n        Graphics2D g2 = (Graphics2D) g;\n        g.setColor(Color.BLACK);\n        g2.setFont(new Font(g2.getFont().getFontName(),\n                g2.getFont().getStyle(), schriftGroesse));          // Schriftgröße KnotenBeschriftung ********* \n        FontMetrics fm = getFontMetrics(g2.getFont());\n        desc = fm.getDescent();\n        zeichenhoehe = fm.getHeight();\n        //        if( bBild != null ) g2.drawImage(bBild, -15, -45, null);\n        if( bBild != null ) g2.drawImage(bBild, bild_dx , bild_dy, null);\n        if (graph != null) {\n            zeichneGraph(g2);\n        }\n\n    }\n\n    private void zeichneGraph(Graphics2D g2) {\n\n        String zzGraph = graph.gibInfo();\n        g2.drawString(zzGraph, 1, zeichenhoehe);\n\n        Font fontNormal = g2.getFont();\n        Font fontKante = new Font(g2.getFont().getFontName(), g2.getFont()\n                .getStyle(), 18);                   // Schriftgröße KantenBeschriftung ********* \n        Stroke strokeNormal = g2.getStroke();\n        Stroke strokeKante = new BasicStroke(2, BasicStroke.CAP_ROUND,\n                BasicStroke.JOIN_MITER);\n        Knoten[] knotenfeld = graph.gibKnotenFeld();\n\n        if( knotenfeld == null) return ;\n\n        int anzahlKnoten = graph.gibKnotenAnzahl();\n\n        int[][] kantenmatrix = graph.gibAdjazenzMatrix();\n        Color[][] kantenFarbmatrix = graph.gibKantenFarbMatrix();\n        for (int i = 0; i < anzahlKnoten; i++) {\n            for (int j = i; j < anzahlKnoten; j++) { // nur oberes Halbfeld\n\n                if (kantenmatrix[i][j] == -1)\n                    continue; // Keine Kante\n                Point pA = knotenfeld[i].gibPosition();\n                Point pB = knotenfeld[j].gibPosition();\n\n                if ((kantenFarbmatrix == null)\n                || (kantenFarbmatrix[i][j] == null)) {\n                    g2.setColor(Color.BLUE);\n                } else {\n                    g2.setColor(kantenFarbmatrix[i][j]);\n                }\n\n                g2.setStroke(strokeKante);\n\n                g2.drawLine(pA.x * rasterBreiteX + kreisradius, pA.y\n                    * rasterHoeheY + kreisradius, pB.x * rasterBreiteX\n                    + kreisradius, pB.y * rasterHoeheY + kreisradius);\n                g2.setStroke(strokeNormal);\n\n                g2.setColor(Color.BLACK);\n\n                if (mitGewicht) {\n\n                    if ((kantenFarbmatrix == null)\n                    || (kantenFarbmatrix[i][j] == null)) {\n                        g2.setColor(Color.red);\n                    } else {\n                        g2.setColor(kantenFarbmatrix[i][j]);\n                    }\n\n                    String zzKante = \"\" + kantenmatrix[i][j];\n\n                    g2.setFont(fontKante);\n\n                    FontMetrics fm = getFontMetrics(g2.getFont());\n                    Rectangle2D r = fm.getStringBounds(zzKante, g2);\n                    int dx = (int) r.getWidth();\n\n                    g2.drawString(zzKante, ((pA.x + pB.x) * rasterBreiteX) / 2\n                        - dx / 2 + kreisradius,\n                        ((pA.y + pB.y) * rasterHoeheY) / 2 + kreisradius);\n                    g2.setFont(fontNormal);\n                }\n            }\n        }\n\n        for (int i = 0; i < anzahlKnoten; i++) {\n            Point p = knotenfeld[i].gibPosition();\n            if (knotenfeld[i].gibFarbe() == null) {\n                g2.setColor(Color.white);\n            } else {\n                g2.setColor(knotenfeld[i].gibFarbe());\n            }\n            g2.fillOval(p.x * rasterBreiteX, p.y * rasterHoeheY,\n                kreisradius * 2, kreisradius * 2);\n            g2.setColor(Color.black);\n            g2.drawOval(p.x * rasterBreiteX, p.y * rasterHoeheY,\n                kreisradius * 2, kreisradius * 2);\n\n            String zzKnoten = knotenfeld[i].gibSchluessel();\n\n            FontMetrics fm = getFontMetrics(g2.getFont());\n            Rectangle2D r = fm.getStringBounds(zzKnoten, g2);\n            int dx = (int) r.getWidth();\n            int desc = fm.getDescent();\n\n            g2.drawString(zzKnoten, p.x * rasterBreiteX + kreisradius - dx / 2,\n                p.y * rasterHoeheY + kreisradius + desc);\n\n        }\n\n    }\n\n    public BufferedImage setzeBilddatei(String filename) {\n        BufferedImage bBild ;        \n        try {\n            bBild = ImageIO.read(new File(filename));\n            return bBild ;\n        } catch (IOException e) {\n            return null ;\n        }\n    }\n\n}\n\n/**\n* \n* Beschreibung\n* \n* @version 1.0 vom 09.02.2010\n* @author\n*/\n\n@SuppressWarnings(\"serial\")\nclass G_Frame_1 extends JFrame {\n\n    public G_Frame_1(JPanel baum, int AnzeigeBreite, int AnzeigeHoehe) {\n        // Frame-Initialisierung\n        super(\"Graphdarstellung\");\n        setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n        setSize(AnzeigeBreite, AnzeigeHoehe);\n        Dimension d = Toolkit.getDefaultToolkit().getScreenSize();\n        int x = (d.width - AnzeigeBreite);\n        int y = (d.height - AnzeigeHoehe) / 2;\n        setLocation(x, y);\n\n        JPanel parentPannel = new JPanel();\n        parentPannel.setLayout(new BorderLayout());\n        JScrollPane parentPane = new JScrollPane();\n\n        parentPannel.add(parentPane, BorderLayout.CENTER);\n        parentPane.setViewportView(baum);\n        getContentPane().add(parentPannel);\n\n        // this.getContentPane().add(panel);\n\n        setExtendedState(Frame.NORMAL);\n        setResizable(true);\n        setVisible(true);\n\n        parentPane\n        .setHorizontalScrollBarPolicy(ScrollPaneConstants.HORIZONTAL_SCROLLBAR_AS_NEEDED);\n        parentPane\n        .setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_AS_NEEDED);\n    }\n\n}\n","position":{"x":-66.2306267675115,"y":-59.76302511912299}},{"name":"Main","content":"\n/**\n * Write a description of class Main here.\n * \n * @author (your name) \n * @version (a version number or a date)\n */\npublic class Main\n{\n    // MAIN Methode\n    public Main() {\n        Graph graph = new Graph(10); \n        GraphDarstellung gd = new GraphDarstellung(graph, true);\n        GraphDarstellung.setzeZoom(4,4 ,20);\n\n        graph.knotenHinzufuegen( \"A\", 32,43 );\n        graph.knotenHinzufuegen( \"B\", 77,64 );\n        graph.knotenHinzufuegen( \"C\", 38,80 );\n        graph.knotenHinzufuegen( \"D\", 74,92 );\n        graph.knotenHinzufuegen( \"E\", 54,110 );\n        graph.knotenHinzufuegen( \"F\", 104,98 );\n        graph.knotenHinzufuegen( \"G\", 91,118 );\n        graph.knotenHinzufuegen( \"H\", 109,63 );\n\n        // Kanten anlegen\n\n        graph.kanteHinzufuegen( \"B\",\"A\",7 );\n        graph.kanteHinzufuegen( \"C\",\"A\",4 );\n        graph.kanteHinzufuegen( \"C\",\"B\",2 );\n        graph.kanteHinzufuegen( \"B\",\"D\",2 );\n        graph.kanteHinzufuegen( \"E\",\"D\",4 );\n        graph.kanteHinzufuegen( \"C\",\"D\",5 );\n        graph.kanteHinzufuegen( \"B\",\"H\",4 );\n        graph.kanteHinzufuegen( \"D\",\"F\",3 );\n        graph.kanteHinzufuegen( \"E\",\"G\",5 );\n\n        //Darstellung instanzieren\n        graph.findeKuerzestenWeg(\"A\", \"G\");\n\n    }\n}\n","position":{"x":-228.43683526842858,"y":143.35798467450002}},{"name":"Graph","content":"import java.awt.Color;\nimport java.awt.Point;\nimport java.util.ArrayList;\n\n/**\n * Graph ungerichtet, gewichtet\n * mit Adjazenzmatrix und KnotenFeld\n * Darstellung über WIT\n * Dijkstra mit Knoten statt Indizes\n * @author Stoeckle \n * @version 16.11.22\n */\nclass Graph{\n    //Attribute\n    private String info = \"Graph mit Breitensuche und Knoten-ArrayList\";    //Info-Text als Überschrift für die Darstellung\n    private Knoten[] knotenFeld;\n    private int knotenAnzahl;     //Anzahl Knoten wird beim Hinzufügen um 1 erhöht! \n    private int[][] adjazenzMatrix;\n    private Color [][] kantenFarbMatrix;                                          //Gibt die Farbe der jeweiligen Kante an\n\n    // Konstruktor\n    Graph(int maxAnzahlKnoten) {\n        knotenFeld = new Knoten[maxAnzahlKnoten];\n        adjazenzMatrix = new int[maxAnzahlKnoten][maxAnzahlKnoten];\n        kantenFarbMatrix =new Color[maxAnzahlKnoten][maxAnzahlKnoten];\n        \n        //Initialisieren der Adjazenzmatrix (notwendig für Darstellung)\n        for (int i = 0; i < maxAnzahlKnoten; i++) {\n            for (int j = 0; j < maxAnzahlKnoten; j++) {\n                if (i != j) adjazenzMatrix[i][j] = -1;\n            }\n        }\n    }\n\n    /** \n     * \n     * Einen Knoten hinzufuegen\n     * fügt dem Graphen einen Knoten hinzu\n     * \n     */\n    public void knotenHinzufuegen(String schluessel, int x, int y) {\n        if (knotenAnzahl < knotenFeld.length) {\n            //Den Knoten an die erste freie Stelle im Feld setzen. \n            knotenFeld[knotenAnzahl] = new Knoten(schluessel, x, y);\n            knotenAnzahl++;\n        } else {\n            System.out.println(\"Es wurde kein Knoten erzeugt, da der Graph schon die maximale Anzahl an Knoten enthält.\");\n        }\n    }\n\n    //Eine Kante hinzufuegen\n    void kanteHinzufuegen(String startSchluessel, String zielSchluessel, int bewertung) {\n        // Position im Feld wird gesucht\n        int start = indexVon(startSchluessel);\n        int ziel = indexVon(zielSchluessel);\n        //hinzufuegen SYMMETRISCH\n        if (start >-1 && ziel >-1) {\n            adjazenzMatrix[start][ziel] = bewertung;\n            adjazenzMatrix[ziel][start] = bewertung;\n        } else {\n            System.out.println(\"Es wurde keine Kante erzeugt, da Start- oder Zielknoten nicht existieren.\");\n        }\n    }\n\n    /** \n     * Hilfsmethoden \n     */\n    //Gibt den Index zu einem Knoten mit einem bestimmten Schlüssel im knotenFeld\n    private int indexVon(String suchSchluessel) {\n        for (int i = 0; i< knotenAnzahl; i++) {\n            if (knotenFeld[i].gibSchluessel().equalsIgnoreCase(suchSchluessel)) {\n                return i;\n            }\n        }\n        return -1; //Wenn nicht gefunden\n    }\n    //Gibt den Index zu einem Knoten \n    private int indexVon(Knoten knoten) {\n        for (int i = 0; i< knotenAnzahl; i++) {\n            if (knotenFeld[i].gibSchluessel().equalsIgnoreCase(knoten.gibSchluessel())) {\n                return i;\n            }\n        }\n        return -1; //Wenn nicht gefunden\n    }\n\n    private Knoten gibKnoten(String schluessel){\n        return knotenFeld[indexVon(schluessel)];    \n    }\n\n    private int gibKantenGewicht(Knoten a, Knoten b){\n        return adjazenzMatrix[indexVon(a)][indexVon(b)];\n    }\n\n    //Prüft, ob knoten1 Nachbar von knoten2 ist\n    private boolean istNachbarVon(Knoten knoten1, Knoten knoten2){\n        if(adjazenzMatrix[indexVon(knoten1.gibSchluessel())][indexVon(knoten2.gibSchluessel())]>0) return true;\n        else return false;\n    }\n\n    /****************************************************************************************************\n     * Gebe Methoden (werden von der Darstellung verwendet und dürfen nicht umbenannt werden!)\n     ****************************************************************************************************/\n    public Knoten[] gibKnotenFeld(){ \n        return knotenFeld;\n    }\n\n    public int gibKnotenAnzahl(){\n        // System.out.println(knotenAnzahl);\n        return knotenAnzahl;\n    }\n\n    public int[][] gibAdjazenzMatrix(){ \n        return adjazenzMatrix;\n    } \n\n    public Color[][] gibKantenFarbMatrix(){ \n        return kantenFarbMatrix;\n    }\n\n    public String gibInfo(){\n        return info;\n    }\n\n    /****************************************************************************************************\n     * Breitensuche als Verfahren zum Graphendurchlauf\n     * Dijkstraalgorithmus\n     ****************************************************************************************************/\n\n    void dijkstra(String startKnotenSchluessel){\n        //initialisieren\n        Knoten startKnoten = gibKnoten(startKnotenSchluessel);   //Startknoten festlegen\n        Knoten ak;                                                      //Aktiver Knoten\n\n        //++++++++DijkstraVorbereitung+++++++\n        for (int i=0; i<knotenAnzahl; i++) {\n            Knoten knoten=knotenFeld[i];\n            knoten.setzeBesucht(false);                                 //Alle unbesucht setzen\n            knoten.setzeEntfernung(Integer.MAX_VALUE);                  //Alle Entfernungen \"unendlich\" setzen\n            knoten.setzeVorgaenger(null);\n        }\n        startKnoten.setzeEntfernung(0);                                 //Startknoten-Entfernung 0 setzen\n\n        //++++++++DijkstraDurchfuehrung+++++++\n        while(unbesuchteExistieren()){                                  //wiederhole bis alle Knoten besucht wurden\n            //AK = unbesuchter Knoten mit kleinster Distanz   \n            ak=knotenMinDistUnbesucht();\n            //Ak auf besucht setzen\n            if(ak!=null) ak.setzeBesucht(true);                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \n            //Darstellung\n            try {\n              Thread.sleep(1000);\n            } catch (InterruptedException e) {\n              Thread.currentThread().interrupt();\n            }//Verzögerung für die Darstellung\n\n            //Für alle Knoten, wenn unbesucht und Nachbar von AK\n            for (int i=0; i<knotenAnzahl; i++) {\n                Knoten knoten=knotenFeld[i];\n                if(!knoten.istBesucht() && istNachbarVon(knoten, ak)) {\n                    //Wenn der Weg über den AK zum Knoten K kleiner ist als dessen Distanz\n                    if(ak.gibEntfernung()+gibKantenGewicht(ak,knoten) < knoten.gibEntfernung()){\n                        //++++++++++++DijkstraUpdate+++++++++\n                        knoten.setzeEntfernung(ak.gibEntfernung()+gibKantenGewicht(ak,knoten));\n                        // knoten.setzeEntfernung(ak.gibEntfernung()+adjazenzMatrix[indexGeben(ak)][indexGeben(knoten)]);\n                        knoten.setzeVorgaenger(ak);\n                    }\n                }\n\n            }\n        }\n    }\n\n    private Knoten knotenMinDistUnbesucht(){\n        Knoten naechsterKnoten=null;\n        int aktuellKleinsteEntfernung = Integer.MAX_VALUE;\n        for (int i=0; i<knotenAnzahl; i++) {\n            Knoten knoten=knotenFeld[i];\n            if (knoten.gibEntfernung()<=aktuellKleinsteEntfernung && !knoten.istBesucht()) {\n                naechsterKnoten=knoten;\n                aktuellKleinsteEntfernung=knoten.gibEntfernung();\n            }\n        }\n        return naechsterKnoten;\n    }\n\n    private boolean unbesuchteExistieren(){\n        //Die Methode soll zurueckgeben, ob es noch unbesuchte Knoten im Graphen gibt\n        for (int i=0; i<knotenAnzahl; i++) {\n            Knoten knoten=knotenFeld[i];\n            if (knoten.istBesucht()==false)  return true;\n        }\n        return false;\n    }\n\n    //Kuezesten Weg bestimmen und ausgeben\n    void findeKuerzestenWeg(String startKnotenSchluessel, String zielKnotenSchluessel){\n        Knoten startKnoten = gibKnoten(startKnotenSchluessel);\n        Knoten zielKnoten = gibKnoten(zielKnotenSchluessel);\n\n        this.dijkstra(startKnotenSchluessel);\n\n        Knoten ak=zielKnoten;\n        System.out.println(\"Der Schnellste Weg zu \"+zielKnotenSchluessel+\" kommt über:\");\n        while(!ak.equals(startKnoten) && indexVon(ak)>-1 && indexVon(ak.gibVorgaenger())>-1){\n            System.out.println(ak.gibSchluessel());      \n            //KantenFarbe anpassen\n            kantenFarbMatrix[indexVon(ak)][indexVon(ak.gibVorgaenger())]=Color.GREEN;\n            kantenFarbMatrix[indexVon(ak.gibVorgaenger())][indexVon(ak)]=Color.GREEN;\n            //Setze Vorgaenger als neuen AK\n            ak=ak.gibVorgaenger();\n        }\n        System.out.println(startKnoten.gibSchluessel()); \n    }\n}\n\n","position":{"x":65.49051395963748,"y":246.96061503533832}},{"name":"Knoten","content":"import java.awt.Color;\nimport java.awt.Point;\n\nclass Knoten{\n    private String schluessel;\n    private int x,y;                    //Postition des Knotens in der Darstellung\n    private boolean besucht;            //Dieses Attribut wird für Verfahren zum Graphendurchlauf benötigt.\n    private int entfernung;             //Aktuelle Entfernung zum Startknoten der Suche\n    private Color farbe;                //Knotenfarbe (wird von der Darstellung übernommen)\n    // private Color farbeBesucht;      //Knotenfarbe für besuchten Knoten \n    private Knoten vorgaenger;          //Knoten der im optimalen Weg Vorgaenger ist\n\n    Knoten(String schluessel, int x, int y)\n    {\n        this.schluessel= schluessel;\n        this.x=x;\n        this.y=y;\n        besucht=false;\n        entfernung=Integer.MAX_VALUE;\n        farbe=Color.LIGHT_GRAY;\n        vorgaenger=null;\n        //farbeBesucht=Color.YELLOW;\n    }\n\n    /**\n     * Gib-Methoden (dürfen nicht verändert werden)\n     */\n    public Point gibPosition(){\n        return new Point(x,y);\n    }\n\n    public Color gibFarbe(){\n        return farbe;\n    } // null bedeutet Standardfarbe\n\n    public String gibSchluessel() {\n        return schluessel;\n    } \n\n    public boolean istBesucht()\n    {\n        return besucht;   \n    }\n\n    public int gibEntfernung(){\n        return entfernung;\n    }\n\n    public Knoten gibVorgaenger(){\n        return vorgaenger;\n    }\n\n    public void setzeEntfernung(int entfernung){\n        this.entfernung=entfernung;\n    }\n\n    public void setzeSchluessel(String schluessel){\n        this.schluessel= schluessel;\n    }\n\n    public void setzeVorgaenger(Knoten knoten){\n        vorgaenger= knoten;\n    }\n\n    public void setzeBesucht(boolean wert){  \n        besucht = wert;\n        if(wert==true){\n            this.farbe=Color.YELLOW; \n            // for(int i=0; i<entfernung;i++){\n            // farbe=farbe.darker();\n            // }\n        }\n        else farbe=Color.LIGHT_GRAY;\n    }\n}\n","position":{"x":235.07661939291984,"y":54.46525898321224}}]}