{"title":"House","summary":"BlueJ Chapter 1","description":"`new Picture()`\n\n-> `draw()`","lastUpdated":1728496759231,"output":"display","classes":[{"name":"Canvas","content":"import javax.swing.*;\nimport java.awt.*;\nimport java.util.List;\nimport java.util.*;\n\n/**\n * Canvas is a class to allow for simple graphical drawing on a canvas.\n * This is a modification of the general purpose Canvas, specially made for\n * the BlueJ \"shapes\" example. \n *\n * @author: Bruce Quig\n * @author: Michael Kölling (mik)\n *\n * @version 2016.02.29\n */\npublic class Canvas\n{\n    // Note: The implementation of this class (specifically the handling of\n    // shape identity and colors) is slightly more complex than necessary. This\n    // is done on purpose to keep the interface and instance fields of the\n    // shape objects in this project clean and simple for educational purposes.\n\n    private static Canvas canvasSingleton;\n\n    /**\n     * Factory method to get the canvas singleton object.\n     */\n    public static Canvas getCanvas()\n    {\n        if(canvasSingleton == null) {\n            canvasSingleton = new Canvas(\"BlueJ Picture Demo\", 500, 300, \n                                         Color.white);\n        }\n        canvasSingleton.setVisible(true);\n        return canvasSingleton;\n    }\n\n    //  ----- instance part -----\n\n    private JFrame frame;\n    private CanvasPane canvas;\n    private Graphics2D graphic;\n    private Color backgroundColor;\n    private Image canvasImage;\n    private List<Object> objects;\n    private HashMap<Object, ShapeDescription> shapes;\n    \n    /**\n     * Create a Canvas.\n     * @param title    title to appear in Canvas Frame\n     * @param width    the desired width for the canvas\n     * @param height   the desired height for the canvas\n     * @param bgColor the desired background color of the canvas\n     */\n    private Canvas(String title, int width, int height, Color bgColor)\n    {\n        frame = new JFrame();\n        canvas = new CanvasPane();\n        frame.setContentPane(canvas);\n        frame.setTitle(title);\n        frame.setLocation(30, 30);\n        canvas.setPreferredSize(new Dimension(width, height));\n        backgroundColor = bgColor;\n        frame.pack();\n        objects = new ArrayList<Object>();\n        shapes = new HashMap<Object, ShapeDescription>();\n    }\n\n    /**\n     * Set the canvas visibility and brings canvas to the front of screen\n     * when made visible. This method can also be used to bring an already\n     * visible canvas to the front of other windows.\n     * @param visible  boolean value representing the desired visibility of\n     * the canvas (true or false) \n     */\n    public void setVisible(boolean visible)\n    {\n        if(graphic == null) {\n            // first time: instantiate the offscreen image and fill it with\n            // the background color\n            Dimension size = canvas.getSize();\n            canvasImage = canvas.createImage(size.width, size.height);\n            graphic = (Graphics2D)canvasImage.getGraphics();\n            graphic.setColor(backgroundColor);\n            graphic.fillRect(0, 0, size.width, size.height);\n            graphic.setColor(Color.black);\n        }\n        frame.setVisible(visible);\n    }\n\n    /**\n     * Draw a given shape onto the canvas.\n     * @param  referenceObject  an object to define identity for this shape\n     * @param  color            the color of the shape\n     * @param  shape            the shape object to be drawn on the canvas\n     */\n     // Note: this is a slightly backwards way of maintaining the shape\n     // objects. It is carefully designed to keep the visible shape interfaces\n     // in this project clean and simple for educational purposes.\n    public void draw(Object referenceObject, String color, Shape shape)\n    {\n        objects.remove(referenceObject);   // just in case it was already there\n        objects.add(referenceObject);      // add at the end\n        shapes.put(referenceObject, new ShapeDescription(shape, color));\n        redraw();\n    }\n \n    /**\n     * Erase a given shape's from the screen.\n     * @param  referenceObject  the shape object to be erased \n     */\n    public void erase(Object referenceObject)\n    {\n        objects.remove(referenceObject);   // just in case it was already there\n        shapes.remove(referenceObject);\n        redraw();\n    }\n\n    /**\n     * Set the foreground color of the Canvas.\n     * @param  newColor   the new color for the foreground of the Canvas \n     */\n    public void setForegroundColor(String colorString)\n    {\n        if(colorString.equals(\"red\")) {\n            graphic.setColor(new Color(235, 25, 25));\n        }\n        else if(colorString.equals(\"black\")) {\n            graphic.setColor(Color.black);\n        }\n        else if(colorString.equals(\"blue\")) {\n            graphic.setColor(new Color(30, 75, 220));\n        }\n        else if(colorString.equals(\"yellow\")) {\n            graphic.setColor(new Color(255, 230, 0));\n        }\n        else if(colorString.equals(\"green\")) {\n            graphic.setColor(new Color(80, 160, 60));\n        }\n        else if(colorString.equals(\"magenta\")) {\n            graphic.setColor(Color.magenta);\n        }\n        else if(colorString.equals(\"white\")) {\n            graphic.setColor(Color.white);\n        }\n        else {\n            graphic.setColor(Color.black);\n        }\n    }\n\n    /**\n     * Wait for a specified number of milliseconds before finishing.\n     * This provides an easy way to specify a small delay which can be\n     * used when producing animations.\n     * @param  milliseconds  the number \n     */\n    public void wait(int milliseconds)\n    {\n        try\n        {\n            Thread.sleep(milliseconds);\n        } \n        catch (Exception e)\n        {\n            // ignoring exception at the moment\n        }\n    }\n\n    /**\n     * Redraw ell shapes currently on the Canvas.\n     */\n    private void redraw()\n    {\n        erase();\n        for(Object shape : objects) {\n            shapes.get(shape).draw(graphic);\n        }\n        canvas.repaint();\n    }\n       \n    /**\n     * Erase the whole canvas. (Does not repaint.)\n     */\n    private void erase()\n    {\n        Color original = graphic.getColor();\n        graphic.setColor(backgroundColor);\n        Dimension size = canvas.getSize();\n        graphic.fill(new Rectangle(0, 0, size.width, size.height));\n        graphic.setColor(original);\n    }\n\n\n    /************************************************************************\n     * Inner class CanvasPane - the actual canvas component contained in the\n     * Canvas frame. This is essentially a JPanel with added capability to\n     * refresh the image drawn on it.\n     */\n    private class CanvasPane extends JPanel\n    {\n        public void paint(Graphics g)\n        {\n            g.drawImage(canvasImage, 0, 0, null);\n        }\n    }\n    \n    /************************************************************************\n     * Inner class CanvasPane - the actual canvas component contained in the\n     * Canvas frame. This is essentially a JPanel with added capability to\n     * refresh the image drawn on it.\n     */\n    private class ShapeDescription\n    {\n        private Shape shape;\n        private String colorString;\n\n        public ShapeDescription(Shape shape, String color)\n        {\n            this.shape = shape;\n            colorString = color;\n        }\n\n        public void draw(Graphics2D graphic)\n        {\n            setForegroundColor(colorString);\n            graphic.fill(shape);\n        }\n    }\n\n}\n","position":{"x":403.869880860658,"y":-147.58598872964043}},{"name":"Circle","content":"import java.awt.*;\nimport java.awt.geom.*;\n\n/**\n * A circle that can be manipulated and that draws itself on a canvas.\n * \n * @author  Michael Kšlling and David J. Barnes\n * @version 2016.02.29\n */\n\npublic class Circle\n{\n    private int diameter;\n    private int xPosition;\n    private int yPosition;\n    private String color;\n    private boolean isVisible;\n    \n    /**\n     * Create a new circle at default position with default color.\n     */\n    public Circle()\n    {\n        diameter = 68;\n        xPosition = 230;\n        yPosition = 90;\n        color = \"blue\";\n    }\n\n    /**\n     * Make this circle visible. If it was already visible, do nothing.\n     */\n    public void makeVisible()\n    {\n        isVisible = true;\n        draw();\n    }\n    \n    /**\n     * Make this circle invisible. If it was already invisible, do nothing.\n     */\n    public void makeInvisible()\n    {\n        erase();\n        isVisible = false;\n    }\n    \n    /**\n     * Move the circle a few pixels to the right.\n     */\n    public void moveRight()\n    {\n        moveHorizontal(20);\n    }\n\n    /**\n     * Move the circle a few pixels to the left.\n     */\n    public void moveLeft()\n    {\n        moveHorizontal(-20);\n    }\n\n    /**\n     * Move the circle a few pixels up.\n     */\n    public void moveUp()\n    {\n        moveVertical(-20);\n    }\n\n    /**\n     * Move the circle a few pixels down.\n     */\n    public void moveDown()\n    {\n        moveVertical(20);\n    }\n\n    /**\n     * Move the circle horizontally by 'distance' pixels.\n     */\n    public void moveHorizontal(int distance)\n    {\n        erase();\n        xPosition += distance;\n        draw();\n    }\n\n    /**\n     * Move the circle vertically by 'distance' pixels.\n     */\n    public void moveVertical(int distance)\n    {\n        erase();\n        yPosition += distance;\n        draw();\n    }\n\n    /**\n     * Slowly move the circle horizontally by 'distance' pixels.\n     */\n    public void slowMoveHorizontal(int distance)\n    {\n        int delta;\n\n        if(distance < 0) \n        {\n            delta = -1;\n            distance = -distance;\n        }\n        else \n        {\n            delta = 1;\n        }\n\n        for(int i = 0; i < distance; i++)\n        {\n            xPosition += delta;\n            draw();\n        }\n    }\n\n    /**\n     * Slowly move the circle vertically by 'distance' pixels.\n     */\n    public void slowMoveVertical(int distance)\n    {\n        int delta;\n\n        if(distance < 0) \n        {\n            delta = -1;\n            distance = -distance;\n        }\n        else \n        {\n            delta = 1;\n        }\n\n        for(int i = 0; i < distance; i++)\n        {\n            yPosition += delta;\n            draw();\n        }\n    }\n\n    /**\n     * Change the size to the new size (in pixels). Size must be >= 0.\n     */\n    public void changeSize(int newDiameter)\n    {\n        erase();\n        diameter = newDiameter;\n        draw();\n    }\n\n    /**\n     * Change the color. Valid colors are \"red\", \"yellow\", \"blue\", \"green\",\n     * \"magenta\" and \"black\".\n     */\n    public void changeColor(String newColor)\n    {\n        color = newColor;\n        draw();\n    }\n\n    /**\n     * Draw the circle with current specifications on screen.\n     */\n    private void draw()\n    {\n        if(isVisible) {\n            Canvas canvas = Canvas.getCanvas();\n            canvas.draw(this, color, new Ellipse2D.Double(xPosition, yPosition, \n                                                          diameter, diameter));\n            canvas.wait(10);\n        }\n    }\n\n    /**\n     * Erase the circle on screen.\n     */\n    private void erase()\n    {\n        if(isVisible) {\n            Canvas canvas = Canvas.getCanvas();\n            canvas.erase(this);\n        }\n    }\n}\n","position":{"x":39.464058811687366,"y":187.82167341124628}},{"name":"Person","content":"import java.awt.*;\n\n/**\n * A person that can be manipulated and that draws itself on a canvas.\n * \n * @author  Michael Kšlling and David J. Barnes\n * @version 2016.02.29\n */\n\npublic class Person\n{\n    private int height;\n    private int width;\n    private int xPosition;\n    private int yPosition;\n    private String color;\n    private boolean isVisible;\n\n    /**\n     * Create a new person at default position with default color.\n     */\n    public Person()\n    {\n        height = 60;\n        width = 30;\n        xPosition = 280;\n        yPosition = 190;\n        color = \"black\";\n        isVisible = false;\n    }\n\n    /**\n     * Make this person visible. If it was already visible, do nothing.\n     */\n    public void makeVisible()\n    {\n        isVisible = true;\n        draw();\n    }\n    \n    /**\n     * Make this person invisible. If it was already invisible, do nothing.\n     */\n    public void makeInvisible()\n    {\n        erase();\n        isVisible = false;\n    }\n    \n    /**\n     * Move the person a few pixels to the right.\n     */\n    public void moveRight()\n    {\n        moveHorizontal(20);\n    }\n\n    /**\n     * Move the person a few pixels to the left.\n     */\n    public void moveLeft()\n    {\n        moveHorizontal(-20);\n    }\n\n    /**\n     * Move the person a few pixels up.\n     */\n    public void moveUp()\n    {\n        moveVertical(-20);\n    }\n\n    /**\n     * Move the person a few pixels down.\n     */\n    public void moveDown()\n    {\n        moveVertical(20);\n    }\n\n    /**\n     * Move the person horizontally by 'distance' pixels.\n     */\n    public void moveHorizontal(int distance)\n    {\n        erase();\n        xPosition += distance;\n        draw();\n    }\n\n    /**\n     * Move the person vertically by 'distance' pixels.\n     */\n    public void moveVertical(int distance)\n    {\n        erase();\n        yPosition += distance;\n        draw();\n    }\n\n    /**\n     * Slowly move the person horizontally by 'distance' pixels.\n     */\n    public void slowMoveHorizontal(int distance)\n    {\n        int delta;\n\n        if(distance < 0) \n        {\n            delta = -1;\n            distance = -distance;\n        }\n        else \n        {\n            delta = 1;\n        }\n\n        for(int i = 0; i < distance; i++)\n        {\n            xPosition += delta;\n            draw();\n        }\n    }\n\n    /**\n     * Slowly move the person vertically by 'distance' pixels.\n     */\n    public void slowMoveVertical(int distance)\n    {\n        int delta;\n\n        if(distance < 0) \n        {\n            delta = -1;\n            distance = -distance;\n        }\n        else \n        {\n            delta = 1;\n        }\n\n        for(int i = 0; i < distance; i++)\n        {\n            yPosition += delta;\n            draw();\n        }\n    }\n\n    /**\n     * Change the size to the new size (in pixels). Size must be >= 0.\n     */\n    public void changeSize(int newHeight, int newWidth)\n    {\n        erase();\n        height = newHeight;\n        width = newWidth;\n        draw();\n    }\n\n    /**\n     * Change the color. Valid colors are \"red\", \"yellow\", \"blue\", \"green\",\n     * \"magenta\" and \"black\".\n     */\n    public void changeColor(String newColor)\n    {\n        color = newColor;\n        draw();\n    }\n\n    /**\n     * Draw the person with current specifications on screen.\n     */\n    private void draw()\n    {\n        int bh = (int)(height * 0.7);  // body height\n        int hh = (height - bh) / 2;  // half head height\n        int hw = width / 2;  // half width\n        int x = xPosition;\n        int y = yPosition;\n        if(isVisible) {\n            Canvas canvas = Canvas.getCanvas();\n            int[] xpoints = { x-3, x-hw, x-hw, x-(int)(hw*0.2)-1, x-(int)(hw*0.2)-1, x-hw, \n                              x-hw+(int)(hw*0.4)+1, x, x+hw-(int)(hw*0.4)-1, x+hw, x+(int)(hw*0.2)+1, \n                              x+(int)(hw*0.2)+1, x+hw, x+hw, x+3, x+(int)(hw*0.6), \n                              x+(int)(hw*0.6), x+3, x-3, x-(int)(hw*0.6), x-(int)(hw*0.6) };\n            int[] ypoints = { y, y+(int)(bh*0.2), y+(int)(bh*0.4), y+(int)(bh*0.2), \n                              y+(int)(bh*0.5), y+bh, y+bh, y+(int)(bh*0.65), y+bh, y+bh, \n                              y+(int)(bh*0.5), y+(int)(bh*0.2), y+(int)(bh*0.4), y+(int)(bh*0.2), \n                              y, y-hh+3, y-hh-3, y-hh-hh, y-hh-hh, y-hh-3, y-hh+3 };\n            canvas.draw(this, color, new Polygon(xpoints, ypoints, 21));\n            canvas.wait(10);\n        }\n    }\n\n    /**\n     * Erase the person on screen.\n     */\n    private void erase()\n    {\n        if(isVisible) {\n            Canvas canvas = Canvas.getCanvas();\n            canvas.erase(this);\n        }\n    }\n}\n","position":{"x":328.72543326724343,"y":73.15666690326086}},{"name":"Picture","content":"/**\n * This class represents a simple picture. You can draw the picture using\n * the draw method. But wait, there's more: being an electronic picture, it\n * can be changed. You can set it to black-and-white display and back to\n * colors (only after it's been drawn, of course).\n *\n * This class was written as an early example for teaching Java with BlueJ.\n * \n * @author  Michael Kšlling and David J. Barnes\n * @version 2016.02.29\n */\npublic class Picture\n{\n    private Square wall;\n    private Square window;\n    private Triangle roof;\n    private Circle sun;\n    private boolean drawn;\n\n    /**\n     * Constructor for objects of class Picture\n     */\n    public Picture()\n    {\n        wall = new Square();\n        window = new Square();\n        roof = new Triangle();  \n        sun = new Circle();\n        drawn = false;\n    }\n\n    /**\n     * Draw this picture.\n     */\n    public void draw()\n    {\n        if(!drawn) {\n            wall.moveHorizontal(-140);\n            wall.moveVertical(20);\n            wall.changeSize(120);\n            wall.makeVisible();\n            \n            window.changeColor(\"black\");\n            window.moveHorizontal(-120);\n            window.moveVertical(40);\n            window.changeSize(40);\n            window.makeVisible();\n    \n            roof.changeSize(60, 180);\n            roof.moveHorizontal(20);\n            roof.moveVertical(-60);\n            roof.makeVisible();\n    \n            sun.changeColor(\"yellow\");\n            sun.moveHorizontal(100);\n            sun.moveVertical(-40);\n            sun.changeSize(80);\n            sun.makeVisible();\n            drawn = true;\n        }\n    }\n\n    /**\n     * Change this picture to black/white display\n     */\n    public void setBlackAndWhite()\n    {\n        wall.changeColor(\"black\");\n        window.changeColor(\"white\");\n        roof.changeColor(\"black\");\n        sun.changeColor(\"black\");\n    }\n\n    /**\n     * Change this picture to use color display\n     */\n    public void setColor()\n    {\n        wall.changeColor(\"red\");\n        window.changeColor(\"black\");\n        roof.changeColor(\"green\");\n        sun.changeColor(\"yellow\");\n    }\n}\n","position":{"x":-116.9547337659435,"y":3.13604619147074}},{"name":"Square","content":"import java.awt.*;\n\n/**\n * A square that can be manipulated and that draws itself on a canvas.\n * \n * @author  Michael Kšlling and David J. Barnes\n * @version 2016.02.29\n */\n\npublic class Square\n{\n    private int size;\n    private int xPosition;\n    private int yPosition;\n    private String color;\n    private boolean isVisible;\n\n    /**\n     * Create a new square at default position with default color.\n     */\n    public Square()\n    {\n        size = 60;\n        xPosition = 310;\n        yPosition = 120;\n        color = \"red\";\n        isVisible = false;\n    }\n\n    /**\n     * Make this square visible. If it was already visible, do nothing.\n     */\n    public void makeVisible()\n    {\n        isVisible = true;\n        draw();\n    }\n    \n    /**\n     * Make this square invisible. If it was already invisible, do nothing.\n     */\n    public void makeInvisible()\n    {\n        erase();\n        isVisible = false;\n    }\n    \n    /**\n     * Move the square a few pixels to the right.\n     */\n    public void moveRight()\n    {\n        moveHorizontal(20);\n    }\n\n    /**\n     * Move the square a few pixels to the left.\n     */\n    public void moveLeft()\n    {\n        moveHorizontal(-20);\n    }\n\n    /**\n     * Move the square a few pixels up.\n     */\n    public void moveUp()\n    {\n        moveVertical(-20);\n    }\n\n    /**\n     * Move the square a few pixels down.\n     */\n    public void moveDown()\n    {\n        moveVertical(20);\n    }\n\n    /**\n     * Move the square horizontally by 'distance' pixels.\n     */\n    public void moveHorizontal(int distance)\n    {\n        erase();\n        xPosition += distance;\n        draw();\n    }\n\n    /**\n     * Move the square vertically by 'distance' pixels.\n     */\n    public void moveVertical(int distance)\n    {\n        erase();\n        yPosition += distance;\n        draw();\n    }\n\n    /**\n     * Slowly move the square horizontally by 'distance' pixels.\n     */\n    public void slowMoveHorizontal(int distance)\n    {\n        int delta;\n\n        if(distance < 0) \n        {\n            delta = -1;\n            distance = -distance;\n        }\n        else \n        {\n            delta = 1;\n        }\n\n        for(int i = 0; i < distance; i++)\n        {\n            xPosition += delta;\n            draw();\n        }\n    }\n\n    /**\n     * Slowly move the square vertically by 'distance' pixels.\n     */\n    public void slowMoveVertical(int distance)\n    {\n        int delta;\n\n        if(distance < 0) \n        {\n            delta = -1;\n            distance = -distance;\n        }\n        else \n        {\n            delta = 1;\n        }\n\n        for(int i = 0; i < distance; i++)\n        {\n            yPosition += delta;\n            draw();\n        }\n    }\n\n    /**\n     * Change the size to the new size (in pixels). Size must be >= 0.\n     */\n    public void changeSize(int newSize)\n    {\n        erase();\n        size = newSize;\n        draw();\n    }\n\n    /**\n     * Change the color. Valid colors are \"red\", \"yellow\", \"blue\", \"green\",\n     * \"magenta\" and \"black\".\n     */\n    public void changeColor(String newColor)\n    {\n        color = newColor;\n        draw();\n    }\n\n    /**\n     * Draw the square with current specifications on screen.\n     */\n    private void draw()\n    {\n        if(isVisible) {\n            Canvas canvas = Canvas.getCanvas();\n            canvas.draw(this, color,\n                        new Rectangle(xPosition, yPosition, size, size));\n            canvas.wait(10);\n        }\n    }\n\n    /**\n     * Erase the square on screen.\n     */\n    private void erase()\n    {\n        if(isVisible) {\n            Canvas canvas = Canvas.getCanvas();\n            canvas.erase(this);\n        }\n    }\n}\n","position":{"x":109.83214850728234,"y":-107.99961411279386}},{"name":"Triangle","content":"import java.awt.*;\n\n/**\n * A triangle that can be manipulated and that draws itself on a canvas.\n * \n * @author  Michael Kšlling and David J. Barnes\n * @version 2016.02.29\n */\n\npublic class Triangle\n{\n    private int height;\n    private int width;\n    private int xPosition;\n    private int yPosition;\n    private String color;\n    private boolean isVisible;\n\n    /**\n     * Create a new triangle at default position with default color.\n     */\n    public Triangle()\n    {\n        height = 60;\n        width = 70;\n        xPosition = 210;\n        yPosition = 140;\n        color = \"green\";\n        isVisible = false;\n    }\n\n    /**\n     * Make this triangle visible. If it was already visible, do nothing.\n     */\n    public void makeVisible()\n    {\n        isVisible = true;\n        draw();\n    }\n    \n    /**\n     * Make this triangle invisible. If it was already invisible, do nothing.\n     */\n    public void makeInvisible()\n    {\n        erase();\n        isVisible = false;\n    }\n    \n    /**\n     * Move the triangle a few pixels to the right.\n     */\n    public void moveRight()\n    {\n        moveHorizontal(20);\n    }\n\n    /**\n     * Move the triangle a few pixels to the left.\n     */\n    public void moveLeft()\n    {\n        moveHorizontal(-20);\n    }\n\n    /**\n     * Move the triangle a few pixels up.\n     */\n    public void moveUp()\n    {\n        moveVertical(-20);\n    }\n\n    /**\n     * Move the triangle a few pixels down.\n     */\n    public void moveDown()\n    {\n        moveVertical(20);\n    }\n\n    /**\n     * Move the triangle horizontally by 'distance' pixels.\n     */\n    public void moveHorizontal(int distance)\n    {\n        erase();\n        xPosition += distance;\n        draw();\n    }\n\n    /**\n     * Move the triangle vertically by 'distance' pixels.\n     */\n    public void moveVertical(int distance)\n    {\n        erase();\n        yPosition += distance;\n        draw();\n    }\n\n    /**\n     * Slowly move the triangle horizontally by 'distance' pixels.\n     */\n    public void slowMoveHorizontal(int distance)\n    {\n        int delta;\n\n        if(distance < 0) \n        {\n            delta = -1;\n            distance = -distance;\n        }\n        else \n        {\n            delta = 1;\n        }\n\n        for(int i = 0; i < distance; i++)\n        {\n            xPosition += delta;\n            draw();\n        }\n    }\n\n    /**\n     * Slowly move the triangle vertically by 'distance' pixels.\n     */\n    public void slowMoveVertical(int distance)\n    {\n        int delta;\n\n        if(distance < 0) \n        {\n            delta = -1;\n            distance = -distance;\n        }\n        else \n        {\n            delta = 1;\n        }\n\n        for(int i = 0; i < distance; i++)\n        {\n            yPosition += delta;\n            draw();\n        }\n    }\n\n    /**\n     * Change the size to the new size (in pixels). Size must be >= 0.\n     */\n    public void changeSize(int newHeight, int newWidth)\n    {\n        erase();\n        height = newHeight;\n        width = newWidth;\n        draw();\n    }\n\n    /**\n     * Change the color. Valid colors are \"red\", \"yellow\", \"blue\", \"green\",\n     * \"magenta\" and \"black\".\n     */\n    public void changeColor(String newColor)\n    {\n        color = newColor;\n        draw();\n    }\n\n    /**\n     * Draw the triangle with current specifications on screen.\n     */\n    private void draw()\n    {\n        if(isVisible) {\n            Canvas canvas = Canvas.getCanvas();\n            int[] xpoints = { xPosition, xPosition + (width/2), xPosition - (width/2) };\n            int[] ypoints = { yPosition, yPosition + height, yPosition + height };\n            canvas.draw(this, color, new Polygon(xpoints, ypoints, 3));\n            canvas.wait(10);\n        }\n    }\n\n    /**\n     * Erase the triangle on screen.\n     */\n    private void erase()\n    {\n        if(isVisible) {\n            Canvas canvas = Canvas.getCanvas();\n            canvas.erase(this);\n        }\n    }\n}\n","position":{"x":234.89210748237747,"y":206.1968572135606}}]}