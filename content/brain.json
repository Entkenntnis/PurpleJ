{"title":"Brain","summary":"BlueJ Chapter 7","description":"`new Environment()`","lastUpdated":1728737839327,"output":"display","classes":[{"name":"Cell","content":"import java.util.*;\n\n/**\n * A cell in a 2D cellular automaton.\n * The cell has multiple possible states.\n * This is an implementation of the rules for Brian's Brain.\n * @see https://en.wikipedia.org/wiki/Brian%27s_Brain\n * \n * @author David J. Barnes and Michael Kölling\n * @version  2016.02.29\n */\npublic class Cell\n{\n    // The possible states.\n    public static final int ALIVE = 0, DEAD = 1, DYING = 2;\n    // The number of possible states.\n    public static final int NUM_STATES = 3;\n\n    // The cell's state.\n    private int state;\n    // The cell's neighbors.\n    private Cell[] neighbors;\n\n    /**\n     * Set the initial state to be DEAD.\n     */\n    public Cell()\n    {\n        this(DEAD);\n    }\n    \n    /**\n     * Set the initial state.\n     * @param initialState The initial state\n     */\n    public Cell(int initialState)\n    {\n        state = initialState;\n        neighbors = new Cell[0];\n    }\n    \n    /**\n     * Determine this cell's next state, based on the\n     * state of its neighbors.\n     * This is an implementation of the rules for Brian's Brain.\n     * @return The next state.\n     */\n    public int getNextState()\n    {\n        if(state == DEAD) {\n            // Count the number of neighbors that are alive.\n            int aliveCount = 0;\n            for(Cell n : neighbors) {\n                if(n.getState() == ALIVE) {\n                    aliveCount++;\n                }\n            }\n            return aliveCount == 2 ? ALIVE : DEAD;\n        }\n        else if(state == DYING) {\n            return DEAD;\n        }\n        else {\n            return DYING;\n        }\n    }\n    \n    /**\n     * Receive the list of neighboring cells and take\n     * a copy.\n     * @param neighborList Neighboring cells.\n     */\n    public void setNeighbors(ArrayList<Cell> neighborList)\n    {\n        neighbors = new Cell[neighborList.size()];\n        neighborList.toArray(neighbors);\n    }\n\n    /**\n     * Get the state of this cell.\n     * @return The state.\n     */\n    public int getState()\n    {\n        return state;\n    }\n    \n    /**\n     * Set the state of this cell.\n     * @param The state.\n     */\n    public void setState(int state)\n    {\n        this.state = state;\n    }   \n    \n}\n","position":{"x":300.33059651029254,"y":188.20568652656806}},{"name":"Environment","content":"import java.security.SecureRandom;\nimport java.util.*;\n\n/**\n * Maintain the environment for a 2D cellular automaton.\n * \n * @author David J. Barnes\n * @version  2016.02.29\n */\npublic class Environment\n{\n    // Default size for the environment.\n    private static final int DEFAULT_ROWS = 50;\n    private static final int DEFAULT_COLS = 50;\n    \n    // The grid of cells.\n    private Cell[][] cells;\n    // Visualization of the environment.\n    private final EnvironmentView view;\n\n    /**\n     * Create an environment with the default size.\n     */\n    public Environment()\n    {\n        this(DEFAULT_ROWS, DEFAULT_COLS);\n    }\n\n    /**\n     * Create an environment with the given size.\n     * @param numRows The number of rows.\n     * @param numCols The number of cols;\n     */\n    public Environment(int numRows, int numCols)\n    {\n        setup(numRows, numCols);\n        randomize();\n        view = new EnvironmentView(this, numRows, numCols);\n        view.showCells();\n    }\n    \n    /**\n     * Run the automaton for one step.\n     */\n    public void step()\n    {\n        int numRows = cells.length;\n        int numCols = cells[0].length;\n        // Build a record of the next state of each cell.\n        int[][] nextStates = new int[numRows][numCols];\n        // Ask each cell to determine its next state.\n        for(int row = 0; row < numRows; row++) {\n            int[] rowOfStates = nextStates[row];\n            for(int col = 0; col < numCols; col++) {\n                rowOfStates[col] = cells[row][col].getNextState();\n            }\n        }\n        // Update the cells' states.\n        for(int row = 0; row < numRows; row++) {\n            int[] rowOfStates = nextStates[row];\n            for(int col = 0; col < numCols; col++) {\n                setCellState(row, col, rowOfStates[col]);\n            }\n        }\n    }\n    \n    /**\n     * Reset the state of the automaton to all DEAD.\n     */\n    public void reset()\n    {\n        int numRows = cells.length;\n        int numCols = cells[0].length;\n        for(int row = 0; row < numRows; row++) {\n            for(int col = 0; col < numCols; col++) {\n                setCellState(row, col, Cell.DEAD);\n            }\n        }\n    }\n    \n    /**\n     * Generate a random setup.\n     */\n    public void randomize()\n    {\n        int numRows = cells.length;\n        int numCols = cells[0].length;\n        SecureRandom rand = new SecureRandom();\n        for(int row = 0; row < numRows; row++) {\n            for(int col = 0; col < numCols; col++) {\n                setCellState(row, col, rand.nextInt(Cell.NUM_STATES));\n            }\n        }\n    }\n    \n    /**\n     * Set the state of one cell.\n     * @param row The cell's row.\n     * @param col The cell's col.\n     * @param state The cell's state.\n     */\n    public void setCellState(int row, int col, int state)\n    {\n        cells[row][col].setState(state);\n    }\n    \n    /**\n     * Return the grid of cells.\n     * @return The grid of cells.\n     */\n    public Cell[][] getCells()\n    {\n        return cells;\n    }\n    \n    /**\n     * Setup a new environment of the given size.\n     * @param numRows The number of rows.\n     * @param numCols The number of cols;\n     */\n    private void setup(int numRows, int numCols)\n    {\n        cells = new Cell[numRows][numCols];\n        for(int row = 0; row < numRows; row++) {\n            for (int col = 0; col < numCols; col++) {\n                cells[row][col] = new Cell();\n            }\n        }\n        setupNeighbors();\n    }\n    \n    /**\n     * Give to a cell a list of its neighbors.\n     */\n    private void setupNeighbors()\n    {\n        int numRows = cells.length;\n        int numCols = cells[0].length;\n        // Allow for 8 neighbors plus the cell.\n        ArrayList<Cell> neighbors = new ArrayList<>(9);\n        for(int row = 0; row < numRows; row++) {\n            for(int col = 0; col < numCols; col++) {\n                Cell cell = cells[row][col];\n                // This process will also include the cell.\n                for(int dr = -1; dr <= 1; dr++) {\n                    for(int dc = -1; dc <= 1; dc++) {\n                        int nr = (numRows + row + dr) % numRows;\n                        int nc = (numCols + col + dc) % numCols;\n                        neighbors.add(cells[nr][nc]);\n                    }\n                }\n                // The neighbours should not include the cell at\n                // (row,col) so remove it.\n                neighbors.remove(cell);\n                cell.setNeighbors(neighbors);\n                neighbors.clear();\n            }\n        }\n    }\n\n}\n","position":{"x":130.62217089052677,"y":103.23899498504676}},{"name":"EnvironmentView","content":"import javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.event.*;\n\n/**\n * A GUI for the environment, with runtime controls.\n * \n * @author David J. Barnes and Michael Kölling\n * @version  2016.02.29\n */\npublic class EnvironmentView extends JFrame\n{\n    // The longest delay for the animation, in milliseconds.\n    private static final int LONGEST_DELAY = 1000;\n    // Colors for the different cell states.\n    private static final Color[] colors = {\n        Color.WHITE, // Alive\n        new Color(68, 100, 129), // Dead\n        new Color(204, 196, 72),  // Dying\n    };\n    \n    private GridView view;\n    private final Environment env;\n    private boolean running;\n    private int delay;\n    \n    /**\n     * Constructor for objects of class EnvironmentView\n     * @param env\n     */\n    public EnvironmentView(Environment env, int rows, int cols)\n    {\n        super(\"2D Cellular Automaton\");\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n        setLocation(20, 20);\n        this.env = env;\n        this.running = false;\n        setDelay(50);\n        setupControls();\n        setupGrid(rows, cols);\n        pack();\n        setVisible(true);\n    }\n\n    /**\n     * Setup a new environment of the given size.\n     * @param rows The number of rows.\n     * @param cols The number of cols;\n     */\n    private void setupGrid(int rows, int cols)\n    {\n        Container contents = getContentPane();\n        view = new GridView(rows, cols);\n        contents.add(view, BorderLayout.CENTER);\n    }\n    \n    /**\n     * Show the states of the cells.\n     */\n    public void showCells()\n    {\n        Cell[][] cells = env.getCells();\n        if(!isVisible()) {\n            setVisible(true);\n        }\n        \n        view.preparePaint();\n        for(int row = 0; row < cells.length; row++) {\n            Cell[] cellRow = cells[row];\n            int numCols = cellRow.length;\n            for(int col = 0; col < numCols; col++) {\n                int state = cellRow[col].getState();\n                view.drawMark(col, row, colors[state]);\n            }\n        }\n        \n        view.repaint();\n    }\n    \n    /**\n     * Set up the animation controls.\n     */\n    private void setupControls()\n    {\n        // Continuous running.\n        final JButton run = new JButton(\"Run\");\n        run.addActionListener(e -> {\n            if(!running) {\n                running = true;\n                try {\n                    new Runner().execute();\n                }\n                catch(Exception ex) {\n                }\n            }\n        });\n        \n        // Single stepping.\n        final JButton step = new JButton(\"Step\");\n        step.addActionListener(e -> {\n            running = false;\n            env.step();\n            showCells();\n        });\n        \n        // Pause the animation.\n        final JButton pause = new JButton(\"Pause\");\n        pause.addActionListener(e -> running = false);\n        \n        // Reset of the environment\n        final JButton reset = new JButton(\"Reset\");\n        reset.addActionListener(e -> {\n            running = false;\n            env.reset();\n            showCells();\n        });\n        \n        // Randomize the environment.\n        final JButton randomize = new JButton(\"Random\");\n        randomize.addActionListener(e -> {\n            running = false;\n            env.randomize();\n            showCells();\n        });\n        \n        Container contents = getContentPane();\n        \n        // A speed controller.\n        final JSlider speedSlider = new JSlider(0, 100);\n        speedSlider.addChangeListener(e -> {\n            setDelay(speedSlider.getValue());\n        });\n        Container speedPanel = new JPanel();\n        speedPanel.setLayout(new GridLayout(2, 1));\n        speedPanel.add(new JLabel(\"Animation Speed\", SwingConstants.CENTER));\n        speedPanel.add(speedSlider);\n        contents.add(speedPanel, BorderLayout.NORTH);\n        \n        // Place the button controls.\n        JPanel controls = new JPanel();\n        controls.add(run);\n        controls.add(step);\n        controls.add(pause);\n        controls.add(reset);\n        controls.add(randomize);\n        \n        contents.add(controls, BorderLayout.SOUTH);\n    }\n\n    \n    /**\n     * Set the animation delay.\n     * @param speedPercentage (100-speedPercentage) as a percentage of the LONGEST_DELAY.\n     */\n    private void setDelay(int speedPercentage)\n    {\n        delay = (int) ((100.0 - speedPercentage) * LONGEST_DELAY / 100);\n    }\n    \n    /**\n     * Provide stepping of the animation.\n     */\n    private class Runner extends SwingWorker<Boolean, Void>\n    {\n        @Override\n        /**\n         * Repeatedly single-step the environment as long\n         * as the animation is running.\n         */\n        public Boolean doInBackground()\n        {\n            while(running) {\n                env.step();\n                showCells();\n                try {\n                    Thread.sleep(delay);\n                }\n                catch(InterruptedException e) {\n                }\n            }\n            return true;\n        }\n    }\n\n\n    /**\n     * Provide a graphical view of a rectangular grid.\n     */\n    @SuppressWarnings(\"serial\")\n    private class GridView extends JPanel\n    {\n        private final int GRID_VIEW_SCALING_FACTOR = 10;\n\n        private final int gridWidth, gridHeight;\n        private int xScale, yScale;\n        private Dimension size;\n        private Graphics g;\n        private Image fieldImage;\n\n        /**\n         * Create a new GridView component.\n         */\n        public GridView(int height, int width)\n        {\n            gridHeight = height;\n            gridWidth = width;\n            size = new Dimension(0, 0);\n        }\n\n        /**\n         * Tell the GUI manager how big we would like to be.\n         */\n        @Override\n        public Dimension getPreferredSize()\n        {\n            return new Dimension(gridWidth * GRID_VIEW_SCALING_FACTOR,\n                                 gridHeight * GRID_VIEW_SCALING_FACTOR);\n        }\n\n        /**\n         * Prepare for a new round of painting. Since the component\n         * may be resized, compute the scaling factor again.\n         */\n        public void preparePaint()\n        {\n            if(! size.equals(getSize())) {\n                size = getSize();\n                fieldImage = view.createImage(size.width, size.height);\n                g = fieldImage.getGraphics();\n\n                xScale = size.width / gridWidth;\n                if(xScale < 1) {\n                    xScale = GRID_VIEW_SCALING_FACTOR;\n                }\n                yScale = size.height / gridHeight;\n                if(yScale < 1) {\n                    yScale = GRID_VIEW_SCALING_FACTOR;\n                }\n            }\n        }\n        \n        /**\n         * Paint on grid location on this field in a given color.\n         */\n        public void drawMark(int x, int y, Color color)\n        {\n            g.setColor(color);\n            g.fillRect(x * xScale, y * yScale, xScale-1, yScale-1);\n        }\n\n        /**\n         * The field view component needs to be redisplayed. Copy the\n         * internal image to screen.\n         */\n        @Override\n        public void paintComponent(Graphics g)\n        {\n            if(fieldImage != null) {\n                Dimension currentSize = getSize();\n                if(size.equals(currentSize)) {\n                    g.drawImage(fieldImage, 0, 0, null);\n                }\n                else {\n                    // Rescale the previous image.\n                    g.drawImage(fieldImage, 0, 0, currentSize.width, currentSize.height, null);\n                }\n            }\n        }\n    }\n}\n","position":{"x":122.7088346737533,"y":259.24059239462724}}]}